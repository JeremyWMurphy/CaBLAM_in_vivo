#Import Librariesimport configparser#import sysimport globfrom pathlib import Pathfrom datetime import timezoneimport datetimeimport timeimport numpy as npimport osimport gcimport copyimport platformfrom scipy.stats import normimport pandas as pdimport serialimport h5pyimport tkinter.font as tkFontimport tkinter as tkimport tkinter.filedialog as fdimport threadingimport jsonimport mathimport matplotlib as mplimport matplotlib.pyplot as pltfrom operator import itemgetterfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg#Import Classes#from ekTeensyClasses import genVariables, genGUI, teensySerial#from ekTeensyClasses import *# This class is the data structureclass genVariables(object):    ''' This is an instance for storing variables and trial data'''    #def __init__(self,sesVarDict={},sensory={},timing={},optical={}):    def __init__(self,sesVarDict={},sensory={},timing={},optical={}):        # File parameters and trial maintenance / timing         self.sesVarDict={'curSession':1,'comPath':'/dev/ttyACM0','sampRate':5000,\        'dirPath':'/Users/ericklein/Documents/GitHub/ekBehaviorControl/pythonCode','baudRate_teensy':115200,'subjID':'an1',\        'experimenter':'klein',\        'dprime':0,'criterion':0,\        'totalTrials':1,'trialNum':0,'sessionOn':0,'taskType':'detection','canQuit':1,'flagTrialUpdate':0,\        'serBufSize':4096,'loadBaseline':0,'loadScale':1,'dStreams':14,\        'chanPlot':5,'detectPlotNum':100,'updateCount':500,'plotSamps':200,\        'noRunTime':[],'noLickTime':2.0,'startCueDur':[],'rewardDur':0.3,'widthdrawDur':0.3,\        'rewardWindow':2.0,'timeoutDur':10.0,'timeoutCueDur':10.0,'startCueChannel':[],\        'rewardChannel':1,'widthdrawChannel':2,'timeoutCueChannel':[],'enforceNoLick':1,\        'lickLatch':0.1,'runLatch':0.1,'minStim':0.25,'endCueChannel':[],'endCueDur':[],'responseWindowMin':0.0,\        'enforceNoRun':1,'responseWindowMax':0.5,'rwdDelay':0.5,'respToCueDelay':0.25,\        'hitCueChannel':[],'hitCueDur':[],'missCueChannel':[],'missCueDur':[],'crCueChannel':[],\        'crCueDur':[],'faCueChannel':[],'faCueDur':[],'rewardHit':1,'rewardMiss':0,'rewardCr':1,\        'rewardFa':0,'timeoutHit':0,'timeoutMiss':0,'timeoutCr':0,'timeoutFa':1,\        'plotLicks':0,'plotPerformance':0\        #'logMQTT':0,'mqttUpDel':0.05,'hashPath':'/Users/cad',\        #'curWeight':0,'volPerRwd':0.0023,'waterConsumed':0,'waterNeeded':1.5,\        #'rewardDur':500,'lickAThr':3900,'lickLatch':0,'shapingTrial':1,\        #'minStim':1500,'ramp1Dur':2000,'ramp1Amp':4095,'ramp2Dur':2000,'ramp2Amp':4095,\        #'toTime':4000,'minStim':1500,'useFlybackOpto':1,'flybackScale':100,\        #'pulsefrequency':20,'pulsedutycycle':10\        #'hostName':'Compy386','debug':0,        }        # Used to validate input / user settings and set trial behaviors        self.cueSetDict = {'cueFields':['Channel','Dur'], #short-cut loop-able prefixes        'cueNames':['startCue','timeoutCue','endCue','hitCue','missCue','crCue','faCue'],#short-cut loop-able prefixes        'setZero':['respToCueDelay'], #set this to zero if not valid - prevents errors        # if fields are cross valid, set name to set-True on taskVar        }        self.rewardParametersDict = {        'enforcePairs':{'enforceNoLick':'noLickTime','enforceNoRun':'noRunTime'}, # cross validate no further set needed        'setZero':['lickLatch','minStim','responseWindowMin','rwdDelay'], #set zero if invalid to prevent error        'anyReward':['rewardHit','rewardMiss','rewardCr','rewardFa'], # If any of these and all of those reward-set = True        'allReward':{'intVars':['rewardChannel'],        'gtDt':['rewardDur','rewardWindow','responseWindowMax'],        'floatVars':['responseWindowMin','minStim','rwdDelay']},        'anyTimeOut':['timeoutHit','timeoutMiss','timeoutCr','timeoutFa'], #If any of these and all of those TO-set=True        'allTimeOut':{'gtDt':['timeoutDur']},        'allWidthdraw':['widthdrawChannel','widthdrawDur'], #if all of these - widthdraw set        }                        self.sesVarDict['dirPath']=Path(self.sesVarDict['dirPath'])        # All steps go in list, even if there aren't any.        # So: 0 steps = [];         # A pre-canned set: [19,22,40]        # Special cases:        # You can range between min/max with a code --> " :,integar,'dist' " to range between min and max         # over n=number increments, probability distribuited in shape 'dist'        # 'eq' = equal probs min->max, 'norm' = normal curve mix->max greatest prob at median (use for threshold)         # example: min: 10; max: 20; steps [':',4,'eq'] --> [12, 14, 16, 18] each w/ probls of         #         1 - (probMax+probMin) / 4        # step probabilities can be explicitly explicitly declaired in probs following requred min and max values        # this list must set values for all steps        # -- Max and min are always required. if max and/or min probs are left blank the max and/or min is incorporated into        #   the probs value range and probability distribution e.g. min:0, max:6 steps:[:,5,'eq'], probs:[0, ] creates         #   equidisant steps 1,2,3,4,5, gives zero probability to '0' (min) and equal probability to the steps and '6' (max)        self.sendParametersDict={'tState':'a','pulseDur':['p','r'],'startTime':['s','g'],'buffering':['n','b'],'stateTrigger':'f',\        'pulseTrainDur':'u','pulseUpDur':'y','flyBackDur':'q','interPulseDur':'d','amp':'v','waveform':'t','pulseCount':'m',\        'loadCell':'l','togglePin':'h','trigD':'g','chanToUseTypeNeeded':['pulseDur','startTime','buffering'],'chanToUseNeeded':[\        'pulseDur','startTime','buffering','stateTrigger','pulseTrainDur','pulseUpDur','interPulseDur','amp','waveform','trigD',\        'pulseCount'],'alwaysOverwrite':['startTime','buffering','pulseCount','trigD'],'timeValues':['pulseDur','startTime','pulseTrainDur',\        'pulseUpDur','flyBackDur','interPulseDur']}        self.dacVarsToSend=['offset','amp','pulseDur','pulseUpDur','interPulseDur','pulseCount','pulseTrainDur','waveform']        self.digitalVarsToSend=['offset','pulseDur']        #These lists are used to compile complete command messages depending on Teensy programming        # 'offset' is used to compute the start time.        self.timing={'varsToUse':['trialTime'],\        'trialCount':1000,\        'trialTime_min':100,'trialTime_max':2000000,'trialTime_steps':[':',5,'norm'],'trialTime_probs':[0,1]\        }        self.makeTrialsDict = {'chanToUse':[1,2,3,3],'chanToUseType':['0','0','1','1'],'varsToUse':\                  ['offset','amp', 'pulseDur','pulseUpDur','interPulseDur','pulseCount',\                   'pulseTrainDur'],'waveform':[0,0,0,0],'syncGroup':[1,1,0,0],'rewardStimulus':[1,0,0,0],'catchStimulus':[0,0,0,0]}                   #vtu, listbox text, add offset params in order, count, name, offset gen to add in order of channels, baseline params        self.makeBlockDict = {'varsToUse':['trialTime'],'getVars':['trialCount','blockName'],'outputSignalList':[],'addOffset':[],'trialCount':[],'blockName':'',\           'addOffsetNum':[],'trialTime':[]}        # Listbox text, Block identifiers in order, shuffle group in order, experiment name        self.makeBlockDesignDict = {'blockName':'','makeBlockDict':{},'makeTrialsDict':{},'blockFileAddress':[]}        # Listbox text, Block identifiers in order, shuffle group in order, experiment name        self.blockDesignDict={'blockList':[],'blockNumList':{},'shuffleGroup':{},'experimentName':[],'blocks':{}}        #Container for trial Pandas to resolve timing for a single block        self.makePandasDict={}        #Pre- shuffled pandads for all blocks        self.allBlocksPandas={}        # Mounted Pandas for the experiment        self.experimentPandas = {'blockIndex':[],'trialParameters':{},'trialBaselines':{}}        self.experimentPandasBuffer = {'blockIndex':[],'trialParameters':{},'trialBaselines':{}}        self.experimentDesignFiles = {'trials':[],'filenames':[],'taskFile':[]}        # current trial vars        #self.trialVars={}        self.makeCalTrialsDict = {'chanToUse':[],'moveIncSize':[],'sampleCount':[],'moveDistance':[],'varsToUse':\                  ['amp', 'pulseDur','pulseUpDur','interPulseDur'],'waveform':[],'pulseCount':[],\                  'baseline':[],'postTime':[],'calibrateName':''}        self.calDesignFile=[]        self.calDataFiles=[]        self.cal_Input=1    #Go through lists, suffle the shuffle groups and  compile a pandas (multiindexed for trial and channel)    def compileAllTrialVaribles(self):        self.blocksToPandas()        pandaDict=self.allBlocksPandas        blockDesign=self.blockDesignDict        #Changed to allow for updating of trials in-session        #self.resetDict('experimentPandas')        #pandaMount = self.experimentPandas        self.resetDict('experimentPandasBuffer')        taskGUI.variables.cal_trlsReady=False                pandaMount = self.experimentPandasBuffer        appendColumnsList =  ['chanToUse','chanToUseType','waveform','rewardStimulus','catchStimulus']        #validate shuffles - index  blocks by shuffle and make sure consecutive        shuffleDict={}        for key in blockDesign['blockNumList']:            #get key name  for the block num            blkName =  blockDesign['blockNumList'][key]            # if the block num is on a shuffle group, initialise a dict list for thar SG group and add block index as value            if type(blockDesign['shuffleGroup'][blkName])==int:                sGNum=blockDesign['shuffleGroup'][blkName]                if sGNum not in shuffleDict.keys():                    shuffleDict[sGNum]=[]                shuffleDict[sGNum].append(int(key))        # now that we have lists of block indexes for each shuffle group, validate consecutive block in         # each list and kick out non-consecutive        for key in shuffleDict.keys():            blkIndexList = shuffleDict[key]            blkIndexList.sort            diffList = np.diff(blkIndexList,prepend=blkIndexList[0]-1)            removeBlk = 1            while removeBlk:        # while / for loop and pop to avoid skipping with re-indexing for removing non consecutive                removeBlk=0                for dex in range(len(diffList)-1,-1,-1): # work from back to keep only                     if diffList[dex] !=1: # since sorted, even if trailing vals are consec, it's a sep chunk an only keeping first                        removeBlk=1    # so then propagate the loop                        blkIndexList.pop(dex);    # delete the val/index                         diffList = np.diff(blkIndexList,prepend=blkIndexList[0]-1) # recompute consecutive test and try again till                        # either all discrete chunks are removed from back to front or SG is removed entirely                        break            if len(blkIndexList)<len(shuffleDict[key]): # if something was removed overwrite the shuffle list                shuffleDict[key]=blkIndexList        # Need to verify that there are not duplicate targets across shuffle groups        shuffBlkList=[]        shuffBlkListInd=[]        shuffGrpNum=[]        sortedKeys = list(shuffleDict.keys())        sortedKeys.sort() # so that we can find occurances from first SG, already unique per SG        for key in sortedKeys:            [((shuffBlkListInd.append(ind), shuffBlkList.append(bNum)), shuffGrpNum.append(key))\             for ind, bNum in enumerate(shuffleDict[key])];        multiSgGroupBlks =[s for s in shuffBlkList if shuffBlkList.count(s) >1] # look for duplicate blocks across SG groups        if len(multiSgGroupBlks)>0: # if we have found duplicates, find the number for each and keep only the first block/group            duplicateBlks = []            dupCount = []            for bNum in set(multiSgGroupBlks): # for all the unique dup block indicies, get their val and count                duplicateBlks.append(bNum)                dupCount.append(shuffBlkList.count(bNum)) # count from the entire list (consecutive filtered)            for ind in range(len(duplicateBlks)):  # Find the occurance from the fist shuff group, and delete the rest                                 firstBlk = shuffBlkList.index(duplicateBlks[ind]) # first index                firstSG = shuffGrpNum[firstBlk] # first SG it's in, since lists w/in SGs were filterd for conscutives,                 # dups should only then occur in other groups                lastInd = copy.copy(firstBlk)                for dex in range(1,dupCount[ind]): # ignore the first (0)                    try:                        lastInd = shuffBlkList.index(duplicateBlks[ind],lastInd+1)                        delShuf = shuffGrpNum[lastInd]                        delInd = shuffleDict[delShuf].index(duplicateBlks[ind])                        del shuffleDict[delShuf][delInd]                    except:                        pass        sortedBlocks = list(blockDesign['blockNumList'].keys())  #now after all that error checking, just get the lists together         sortedBlocks = [int(s) for s in sortedBlocks]        sortedBlocks.sort()        sortedBlocks = [str(s) for s in sortedBlocks]        currentLine =0 # line number to start generation fron at each step        ind = 0  # iterator for this loop  will allow iteration through both singles and groups with a sub loop        breakLoop = 0        indexVector=[]        #pDictInd=0        concatPanda=pd.DataFrame()        concatBaselinePanda=pd.DataFrame()        while not breakLoop:            if ind< len(sortedBlocks):                key = sortedBlocks[ind]                blkName =  blockDesign['blockNumList'][key] # get the name key                sGNum = blockDesign['shuffleGroup'][blkName] # get the entered shuff group                tNum = blockDesign['blocks'][blkName]['makeBlockDict']['trialCount'] # get number of trials and verify by panda sheet                if tNum != pandaDict[blkName]['0'].shape[0]:                    print('Error list for {} not length requested'.format(blkName))                # Find the index range for this block                firstLine = currentLine                lastLine = currentLine+ tNum # (for non-inclusive for indexing)                if type(sGNum)==int and int(key) in shuffleDict[sGNum]: # if we have a valid shuffle group member                    prevInd = copy.copy(ind)    # store whrere we start                     sgLabel = copy.copy(sGNum)                    tNums=[]                    shuffGroupIndexes = shuffleDict[sGNum]    # get valid shuffG inds                    shuffGroupIndexes.sort()                    for dex in shuffGroupIndexes:                        if dex == ind:                #we filtered for consecutive so these should be equaL                            tNums.append(tNum)                            ind+=1                            if ind in shuffGroupIndexes: # if we haven't already gotten all the tNums, get the next otherwise ind is for next loop                                key = sortedBlocks[ind]                                blkName =  blockDesign['blockNumList'][key] # get the name key                                sGNum = blockDesign['shuffleGroup'][blkName] # get the entered shuff group                                tNum = blockDesign['blocks'][blkName]['makeBlockDict']['trialCount'] # get number of trials and verify by panda sheet                                if tNum != pandaDict[blkName]['0'].shape[0]:                                    print('Error list for {} not length requested'.format(blkName))                                # don't need to re-increment IND here for next loop already done                    sgLen = sum(tNums)                    lastLine = firstLine + sgLen                    pdIndexList = np.random.permutation(list(range(firstLine,lastLine,1)))                      tNumDex = 0                    #concatPanda=pd.DataFrame()                    for dex in shuffGroupIndexes:                        thisBlocksInds = pdIndexList[:tNums[tNumDex]]                        pdIndexList=pdIndexList[tNums[tNumDex]:]                        thisBlocksInds=np.sort(thisBlocksInds) # This line was added to allow dist sorting - interdigit between block still random                        key = sortedBlocks[dex]                        blkName =  blockDesign['blockNumList'][key] # get the name key                        makeBlock = blockDesign['blocks'][blkName]['makeTrialsDict']                        pandaBlock = pandaDict[blkName]                                                x=pd.Series(thisBlocksInds, name='Trials')                        nanCol = np.empty(tNums[tNumDex])                        nanCol[:]= np.NaN                        q=pd.Series(nanCol, name='tFired')                        pandaBase=pandaBlock['baselineTimes']                        pandaBase=pd.concat([pandaBase,x], axis=1, sort=False)                        pandaBase.set_index(['Trials'],drop=True, inplace=True)                        concatBaselinePanda = pd.concat([concatBaselinePanda,pandaBase])                        pandaBlock['baselineTimes']=pandaBase                        for chNum in range(len(pandaBlock.keys())-1): # !! TODO this will need to be '-1' for baseline                            y = pd.Series([int(chNum) for p in range(tNums[tNumDex])], name='Channel')                            pandaSheet = pandaBlock[str(chNum)]                            pandaSheet=pd.concat([pandaSheet,x,y,q], axis=1, sort=False)                            for mkKey in appendColumnsList:                                nVal= makeBlock[mkKey][chNum]                                apndLst=[nVal for s in range(tNums[tNumDex])]                                apndSeries = pd.Series(apndLst, name=mkKey)                                pandaSheet=pd.concat([pandaSheet,apndSeries], axis=1, sort=False)                            #pandaSheet.set_index(['Trials','Channel'],drop=True, inplace=True) #changed to sort by trials and offset                            pandaBlock[str(chNum)]=pandaSheet                            concatPanda=pd.concat([concatPanda,pandaSheet])                        pandaDict[blkName]=pandaBlock                        tNumDex+=1                    grpName = 'Blocks {}:{}, Shuffle Group {}'.format(shuffGroupIndexes[0],shuffGroupIndexes[-1],sgLabel)                    #pandaMount['blockIndex'].append((pDictInd,grpName))                    #pandaMount['shuffleBlock'][pDictInd]=concatPanda.copy()                    pandaMount['blockIndex'].append((firstLine,lastLine,grpName))                    pandaMount['trialParameters']=concatPanda.copy()                    pandaMount['trialBaselines']=concatBaselinePanda.copy()                                       #pDictInd+=1                    currentLine = lastLine                else:    # do all the same stuff for SINGLE blocks    FINISH FROM HERE                    pdIndexList = list(range(firstLine,lastLine,1))                    thisBlocksInds = pdIndexList                    makeBlock = blockDesign['blocks'][blkName]['makeTrialsDict']                    pandaBlock = pandaDict[blkName]                    x=pd.Series(thisBlocksInds, name='Trials')                    nanCol = np.empty(tNum)                    nanCol[:]= np.NaN                    q=pd.Series(nanCol, name='tFired')                    pandaBase=pandaBlock['baselineTimes']                    pandaBase=pd.concat([pandaBase,x], axis=1, sort=False)                    pandaBase.set_index(['Trials'],drop=True, inplace=True)                    concatBaselinePanda = pd.concat([concatBaselinePanda,pandaBase])                    pandaBlock['baselineTimes']=pandaBase                    #concatPanda=pd.DataFrame()                    for chNum in range(len(pandaBlock.keys())-1):                        y = pd.Series([int(chNum) for p in range(tNum)], name='Channel')                        pandaSheet = pandaBlock[str(chNum)]                        pandaSheet=pd.concat([pandaSheet,x,y,q], axis=1, sort=False)                        for mkKey in appendColumnsList:                            nVal= makeBlock[mkKey][chNum]                            apndLst=[nVal for s in range(tNum)]                            apndSeries = pd.Series(apndLst, name=mkKey)                            pandaSheet=pd.concat([pandaSheet,apndSeries], axis=1, sort=False)                        #pandaSheet.set_index(['Trials','Channel'],drop=True, inplace=True) #changed to sort by trials and offset                        pandaBlock[str(chNum)]=pandaSheet                        concatPanda=pd.concat([concatPanda,pandaSheet])                    pandaDict[blkName]=pandaBlock                    grpName = 'Block: {}'.format(blkName)                    #pandaMount['blockIndex'].append((pDictInd,grpName))                    #pandaMount['shuffleBlock'][pDictInd]=concatPanda.copy()                    #pDictInd+=1                    pandaMount['blockIndex'].append((firstLine,lastLine,grpName))                    pandaMount['trialParameters']=concatPanda.copy()                    pandaMount['trialBaselines']=concatBaselinePanda.copy()                                            currentLine = lastLine                    ind+=1            else:                breakLoop =1        #pandaMount['trialParameters'].sort_index(level='Trials',inplace=True)        pandaMount['trialParameters'].sort_values(by=['Trials','offset'],inplace=True)        pandaMount['trialParameters'].set_index(['Trials','Channel'],drop=True, inplace=True)        pandaMount['trialBaselines'].sort_index(level='Trials',inplace=True)        tStamp=datetime.datetime.now().strftime("_%Y_%m_%d_%H%M%S")        saveName=blockDesign['experimentName']+'_'+tStamp+'_channelParameters'        self.savePanda(pandaMount['trialParameters'],self.sesVarDict['dirPath'] / 'Trials' ,saveName)        saveName=blockDesign['experimentName']+'_'+tStamp+'_trialBaselines'        self.savePanda(pandaMount['trialBaselines'],self.sesVarDict['dirPath'] / 'Trials' ,saveName)        if taskVar.sesVarDict['sessionOn']==0:            #            taskVar.sesVarDict['totalTrials']=\            len(set(pandaMount['trialParameters'].index.get_level_values('Trials').to_list()))            self.experimentDesignFiles['trials']=[]            self.experimentDesignFiles['trials'].append(taskVar.sesVarDict['totalTrials'])            self.resetDict('experimentPandas')            self.experimentPandas=copy.deepcopy(pandaMount)            self.resetDict('experimentPandasBuffer')         #else:            #self.sesVarDict['flagTrialUpdate']=0            #This was skipped because not needed here and the variable will be used to trip functions in the active task loop        print('{} saved to {}'.format(blockDesign['experimentName'],str(self.sesVarDict['dirPath'] / 'Trials')))      # Take blocks process into Pandas, store into a compiled Dict    def blocksToPandas(self):        blockDesign=self.blockDesignDict        allPandasDict={}        for key in blockDesign['blockNumList'].keys():            #Pick a block            blkName = blockDesign['blockNumList'][key]            #get the design parameters            mkTrialsDict = blockDesign['blocks'][blkName]['makeTrialsDict']            mkBlockDict = blockDesign['blocks'][blkName]['makeBlockDict']            #make the variables/trials            self.channelParamsToPandasFrame(mkTrialsDict,mkBlockDict)            # Analyze and match sync groups            self.resolveSyncGroups(mkTrialsDict)            # Add offset timing            self.resolveAddOffset(mkBlockDict)            # Store the data            self.allBlocksPandas[blkName]=self.makePandasDict.copy()            # Reset the source            self.makePandasDict={}    #Take the channel info, for each, create probs/trials lists and save a pandas for each channel    def channelParamsToPandasFrame(self,trialsDict,blockDict):        tCount = blockDict['trialCount']        for ind in range(len(trialsDict['chanToUse'])):            if trialsDict['chanToUseType'][ind]==0:                channelPandaFrame, _ = self.getFeatureProb(trialsDict,tCount,[],ind)                self.makePandasDict[str(ind)]=channelPandaFrame.copy()            else:                channelPandaFrame, _ = self.getFeatureProb(trialsDict,tCount,['offset','pulseDur'],ind)                self.makePandasDict[str(ind)]=channelPandaFrame.copy()        channelPandaFrame,_ = self.getFeatureProb(blockDict,tCount,['trialTime'],0)        self.makePandasDict['baselineTimes']=channelPandaFrame.copy()    def calParamsToPandasFrame(self, calDict, numberPerms):        ptTm= calDict['postTime']        smpCt= calDict['sampleCount']        channelPandaFrame,_ = self.getFeatureProb(calDict, numberPerms, [],0)        ctgrys= channelPandaFrame.columns.tolist()        unqCnts=[]        srtByThese=[]        # sort all the parameters to ensure all permutations are realized. Strategy is leave alone categories with one or less values,         # find range of unique values for each category and sort the count of unique values per category from lowest increasing        # leave the first with fewest unique values (most instances of each unique values) alone, sort the next higests ramp-sorted instances across         # each of the previous categories unique values recursively        for s in range(len(ctgrys)):            ctgr=ctgrys[s]            if not np.any(np.isnan(np.unique(channelPandaFrame[ctgr]))):                unqCnts.append((s,len(np.unique(channelPandaFrame[ctgr]))))        for ctInd,ctCnt in sorted(unqCnts, key=itemgetter(1)):            if ctCnt>1:                srtByThese.append((ctgrys[ctInd],ctCnt))        if len(srtByThese)>1:            #            tempSortArray = np.empty([numberPerms,len(srtByThese)-1])            tempSortArray.fill(np.nan)            refProd=1                        for srtByInd in range(len(srtByThese)-1):                #                refCol=srtByInd                srtCol=refCol+1                srtColName=srtByThese[srtCol][0]                refColName=srtByThese[refCol][0]                refProd=srtByThese[refCol][1]*refProd                srtDenom=numberPerms/refProd                srtInd=0                for srtArryInd in range(int(srtDenom)):                    for refCylInd in range(refProd):                        tempSortArray[int(refCylInd*srtDenom)+srtArryInd,refCol]= channelPandaFrame.loc[srtInd,srtColName]# refCol used bc the result array is one less column, doesn't include first                        srtInd+=1            srtInd=0            for rCol,_ in srtByThese[1:]:                channelPandaFrame.loc[:,rCol]=tempSortArray[:,srtInd]                srtInd+=1        # if therew is a Post train time selected, create dummy channel lines for this based on the trains in each permutation and add under-the-hood columns        if (type(ptTm)==int or type(ptTm)==float) and ptTm >0:            filNan = np.empty(channelPandaFrame.shape)            filNan[:]=np.nan            trlLenDums=pd.DataFrame(filNan,columns=ctgrys)            trlLenDums.loc[:,'pulseDur']=0            trlLenDums.loc[:,'offset']= channelPandaFrame.loc[:,'pulseDur']+channelPandaFrame.loc[:,'interPulseDur']            trlLenDums.loc[:,'offset']=trlLenDums.loc[:,'offset']*channelPandaFrame.loc[:,'pulseCount']            trlLenDums.loc[:,'offset']=trlLenDums.loc[:,'offset']+channelPandaFrame.loc[:,'offset']            trlLenDums.loc[:,'offset']=trlLenDums.loc[:,'offset']+ptTm            apndLst=[1 for s in range(trlLenDums.shape[0])]            apndSeries=pd.Series(apndLst, name='Channel')            trlLenDums=pd.concat([trlLenDums,apndSeries], axis=1, sort=False)                nanCol = np.empty(trlLenDums.shape[0])            nanCol[:]= np.NaN            apndSeries=pd.Series(nanCol, name='tFired')            trlLenDums=pd.concat([trlLenDums,apndSeries], axis=1, sort=False)             apndLst=[0 for s in range(trlLenDums.shape[0])]            apndSeries=pd.Series(apndLst, name='chanToUse')            trlLenDums=pd.concat([trlLenDums,apndSeries], axis=1, sort=False)            apndLst=[2 for s in range(trlLenDums.shape[0])]            apndSeries=pd.Series(apndLst, name='chanToUseType')            trlLenDums=pd.concat([trlLenDums,apndSeries], axis=1, sort=False)            for apCoNm in ['waveform','rewardStimulus','catchStimulus']:                apndLst=[[] for s in range(trlLenDums.shape[0])]                apndSeries=pd.Series(apndLst, name=apCoNm)                trlLenDums=pd.concat([trlLenDums,apndSeries], axis=1, sort=False)        else:            trlLenDums=pd.DataFrame()        # Add under the hood columns for the signal permutations        #        apndLst=[0 for s in range(channelPandaFrame.shape[0])]        apndSeries=pd.Series(apndLst, name='Channel')        channelPandaFrame=pd.concat([channelPandaFrame,apndSeries], axis=1, sort=False)                    nanCol = np.empty(channelPandaFrame.shape[0])        nanCol[:]= np.NaN        apndSeries=pd.Series(nanCol, name='tFired')        channelPandaFrame=pd.concat([channelPandaFrame,apndSeries], axis=1, sort=False)         apndLst=[calDict['chanToUse'] for s in range(channelPandaFrame.shape[0])]        apndSeries=pd.Series(apndLst, name='chanToUse')        channelPandaFrame=pd.concat([channelPandaFrame,apndSeries], axis=1, sort=False)           apndLst=[0 for s in range(channelPandaFrame.shape[0])]        apndSeries=pd.Series(apndLst, name='chanToUseType')        channelPandaFrame=pd.concat([channelPandaFrame,apndSeries], axis=1, sort=False)        apndLst=[calDict['waveform'] for s in range(channelPandaFrame.shape[0])]        apndSeries=pd.Series(apndLst, name='waveform')        channelPandaFrame=pd.concat([channelPandaFrame,apndSeries], axis=1, sort=False)           for apCoNm in ['rewardStimulus','catchStimulus']:            apndLst=[[] for s in range(channelPandaFrame.shape[0])]            apndSeries=pd.Series(apndLst, name=apCoNm)            channelPandaFrame=pd.concat([channelPandaFrame,apndSeries], axis=1, sort=False)        # Set Trial Index for permuations, for code convenience, using one trial per repetition Trials = perms * sample trains        # This allows under the hood infrastructure to calculate timing for each rep on the fly.         trlList = np.arange(channelPandaFrame.shape[0]*smpCt)        chanPanCat = channelPandaFrame.copy()        if len(trlLenDums)>0:            trlLenDumCat = trlLenDums.copy()        for smplReps in range(smpCt-1):            chanPanCat=pd.concat([chanPanCat,channelPandaFrame], axis=0, sort=False)            if len(trlLenDums)>0:                trlLenDumCat=pd.concat([trlLenDumCat,trlLenDums], axis=0, sort=False)        chanPanCat.sort_index(inplace=True)        chanPanCat['Trials']=trlList        chanPanCat.set_index(['Trials','Channel'],drop=True, inplace=True)        if len(trlLenDums)>0:            trlLenDumCat.sort_index(inplace=True)            trlLenDumCat['Trials']=trlList            trlLenDumCat.set_index(['Trials','Channel'],drop=True, inplace=True)            chanPanCat=pd.concat([chanPanCat,trlLenDumCat], axis=0, sort=False)            chanPanCat.sort_values(by=['Trials','Channel'],inplace=True)            totalSampleBlockTime= sum(trlLenDumCat['offset'])        else:            tSampBlkTm = chanPanCat.loc[:,'pulseDur']+chanPanCat.loc[:,'interPulseDur']            tSampBlkTm = tSampBlkTm*chanPanCat.loc[:,'pulseCount']            tSampBlkTm = tSampBlkTm + chanPanCat.loc[:,'offset']            totalSampleBlockTime = tSampBlkTm.sum()        bslnCat = pd.DataFrame(pd.Series(np.zeros(len(trlList)), name='trialTime'))        bslnCat['Trials']=trlList        bslnCat.set_index(['Trials'],drop=True, inplace=True)        tStamp=datetime.datetime.now().strftime("_%Y_%m_%d_%H%M%S")        saveName=calDict['calibrateName']+'_'+tStamp+'_channelParameters'        saveDirectory= self.sesVarDict['dirPath'] / 'calibrationParams' / 'Trials'        self.savePanda(chanPanCat,saveDirectory,saveName)        print('{} saved to {}'.format(calDict['calibrateName'],str(saveDirectory)))        self.resetDict('experimentPandasBuffer')         self.experimentPandasBuffer['trialParameters']=chanPanCat.copy()        self.experimentPandasBuffer['trialBaselines']=bslnCat.copy()        taskGUI.variables.cal_trlsReady=True          # if taskVar.sesVarDict['sessionOn']==0:        #     #        #     taskVar.sesVarDict['totalTrials']=\        #     len(set(experimentPandasBuffer['trialParameters'].index.get_level_values('Trials').to_list()))        return totalSampleBlockTime    #Analyze sync group info, for each channel, if a sg member, and has no params for a var column     # copy the var column from the first member channel to it (e.g., sync where own params override)    def resolveSyncGroups(self,trialsDict,pandasDict={}):        if not pandasDict:            pandasDict=self.makePandasDict        channelSyncList =trialsDict['syncGroup']        #unique sync groups        syncGroupList =[]        for numstep in channelSyncList:            if numstep not in syncGroupList:                try:                    syncGroupList.append(int(numstep))                except:                    pass        if len(syncGroupList)==0:            return        syncGroupList.sort() # for indexing, unique groups        # find first channel for each group, indexed by syncGroupList        firstChannels =[channelSyncList.index(numstep) for numstep in syncGroupList]        for lineNum in range(len(trialsDict['chanToUse'])):            syncGrp=[]            fChan=[]            #look at the channels that are Not firsts (copy targets)            if lineNum not in firstChannels:                try:    #check if it's in a SG and record the number                    syncGrp = int(channelSyncList[lineNum])                    fChan = firstChannels[syncGroupList.index(syncGrp)] # get first channel for this group to copy from                    if type(syncGrp)==int:    # validate  and look at each distribution var                        for key in trialsDict['varsToUse']:                            # It it has it's own parameters, do nothing, else if                            if type(trialsDict[key][lineNum][0])==list or type(trialsDict[key][lineNum][1])==list:                                #set this var type column equal to                                pandasDict[str(lineNum)].at[:,key]=\                                pandasDict[str(fChan)].loc[:,key] # the column from the first channel in the sync group                                # Correct any reindexing                        reIndexList=[]                        for key in trialsDict['varsToUse']:                            if key in pandasDict[str(lineNum)].columns:                                reIndexList.append(key)                        for key in pandasDict[str(lineNum)].columns:                            if key not in reIndexList:                                reIndexList.append(key)                        pandasDict[str(lineNum)]=pandasDict[str(lineNum)].reindex(reIndexList, axis="columns")                except:                    pass    #  add offsets where ordered    def resolveAddOffset(self,blockDict,pandasDict={}):        if not pandasDict:            pandasDict=self.makePandasDict        # Get list of channels to modify        addOffsetList = blockDict['addOffsetNum']        # Get number of trials        tCount = blockDict['trialCount']        # for each offset distribution        for x in range(len(addOffsetList)):            #make the distribution for the offset line            offsetPd,_ = self.getFeatureProb(blockDict,tCount,['addOffset'],x)            try:                # add the offset to each channel specified                for ind in addOffsetList[x]:                    pandasDict[str(ind)].at[:,'offset']=\                    pandasDict[str(ind)].loc[:,'offset']+offsetPd.loc[:,'addOffset'] # the column from the first channel in the sync group            except:                print('warning extra offset, can not be addigned, channel may be missing')                pass    def blockNameIncrement(self,bName,checkList=[],incNum=1):        if bName in checkList:            cName = bName            while cName in checkList:                cName = bName + str(incNum)                incNum +=1            return cName        else:            return bName            def resetDict(self,varDict,exludeKeys=['varsToUse']):        vd = eval('self.{}'.format(varDict))        for key in list(vd.keys()):            if key not in exludeKeys:                if type(vd[key])==dict:                    vd[key]={}                else:                    vd[key]=[]        exec('self.{}=vd'.format(varDict))    def makeParamArray(self,probsDict={}):        if len(probsDict)==0:            probsDict=self.makeTrialsDict        #list of unique sync designations (zero means not part of a group)        pDict = np.array(probsDict['syncGroup'])        syncList = np.unique(pDict)        # list of actual sync groups        syncGroups = list(syncList[syncList>0])        # number of independent channels        indChanCount = sum([1 if (x==0) or not x else 0 for x in pDict])        #indChanCount = sum(pDict==0)        #row number for array        rowCount = indChanCount + len(syncGroups)        #Create syncGroup channel index relative to entered list        chanNumber =[]        chanType =[]        chanIndex =[]        # Store the channel and original list index information for every unique        # stimulus group        if len(syncGroups)>0:                        for x in syncGroups:# for each sync group                #get the line indices of sync group                sgInds = [index for index, element in enumerate(probsDict['syncGroup']) if element == x]                #save the indicies for the sync group                chanIndex.append(sgInds)                # save the channel numbers and type for the group                chanType.append([probsDict['chanToUseType'][i] for i in sgInds])                chanNumber.append([probsDict['chanToUse'][i] for i in sgInds])            lastInd = 0                    for x in range(indChanCount):# for each of the unique channels            #find the nth index loc (lastInd) index of these channel keys (it's a 'zero')            sgInd = probsDict['syncGroup'].index(0,lastInd)            # set locator to look after this index from now on            lastInd=sgInd+1            # save all the info            chanIndex.append(sgInd)            chanType.append(probsDict['chanToUseType'][sgInd])            chanNumber.append(probsDict['chanToUse'][sgInd])        paramTable = pd.DataFrame({'chanNumber':chanNumber,'chanType':chanType,'chanIndex':chanIndex},\         index=list(range(rowCount)))        emptyTable = pd.DataFrame(np.empty([rowCount,len(probsDict['varsToUse'])],dtype='object'),\            columns=probsDict['varsToUse'])        paramTable= pd.concat([paramTable, emptyTable], axis=1)    def getFeatureProb(self,probDict,countNum,varList=[],paramLine=0):        #prob dict contains all data        # count = lines to generate "trialCount"        #var list are keys within the dict containing min,mas,stps,probs        #param line designates the index ("row") within that list containing the mmsp list                # Create local copies of parameter labels        if len(varList)<1:            labelList = probDict['varsToUse']        else:            labelList = varList        # Why store a variable specific trial count?        # it seems smarter to parse trials based on task, or parameters needed        # then pass that to this for each block         trLen = countNum                # we make an array that is the length of         # the total number of trials we want numbers for.        tempArray = np.zeros((trLen,len(labelList)))        # we make a temporary array that is (min,max,steps) by total variables        tempCountArray = np.zeros((3,len(labelList)))        # we make a list of vairable names that have been iterated through.         # We return this list too, because it is often necessary to reconcile the item         varIndex = []        # iterate through parameter type names        for x in range(len(labelList)):            minEmptyFlag=0            maxEmptyFlag=0            curStr = labelList[x]            #store the names in another list            varIndex.append(curStr)            # list of 0 to trials number -1            availIndicies = np.arange(trLen)            # store Trial number again?            curAvail=len(availIndicies)            curMin=[]            curMinProb=[]            curMinCount=[]            minEmptyFlag=0            curMax=[]            curMaxProb=[]            curMaxCount=[]            maxEmptyFlag=0            try:                #Get the minimum limit for parameter type                curMin=eval("probDict['{}'][{}][0]".format(curStr,paramLine))            except:                curMin=[]            try:                #Get the minimum probability for parameter type                curMinProb=eval("probDict['{}'][{}][3][0]".format(curStr,paramLine))            except:                curMinProb=[]            if (type(curMinProb)==str) or (type(curMinProb)==list and len(curMinProb)==0):                minEmptyFlag=1                curMinCount=0                tempCountArray[0,x]=0                curMinProb=0            else:                # actual number of minimum trials                curMinCount = int(np.round(curAvail*curMinProb))                # save actual number of minimum trials in row 1                tempCountArray[0,x]=curMinCount            try:                #Get the max limit for parameter type                curMax=eval("probDict['{}'][{}][1]".format(curStr,paramLine))            except:                curMax=[]            try:                #Get the max probability for parameter type                curMaxProb=eval("probDict['{}'][{}][3][1]".format(curStr,paramLine))            except:                curMaxProb=[]            if (type(curMaxProb)==str) or (type(curMaxProb)==list and len(curMaxProb)==0):                maxEmptyFlag=1                curMaxCount=0                tempCountArray[1,x]=0                curMaxProb=0            else:                # actual number of max trials                curMaxCount = int(np.round(curAvail*curMaxProb))                # save actual number of max trials in row 2                tempCountArray[1,x]=curMaxCount                        if (type(curMax)==list and len(curMax) != 1) or (type(curMin)==list and len(curMin) != 1):                tempArray[:,x]=np.NaN                tempCountArray[2,x]=int(np.round(curAvail*(1-(curMaxProb+curMinProb))))                continue                        # do compute steps flag?            computeSteps = 1            curDist = ''            defaultDist='eq'            curArrange = ''            defaultArrange= 'random'            repOne=False            compDist=True            arrangeDone=False            # Get the steps list            curSteps = eval("probDict['{}'][{}][2]".format(curStr,paramLine))            #If steps probs are explicitly declared store them            probsAll = eval("probDict['{}'][{}][3]".format(curStr,paramLine))            tmpCurStps=[]            # This will look at the last steps field for strings, parse them for the current non-default distributions and arrangements            try:                if len(curSteps)>=1 and type(curSteps[-1])==str and curSteps[-1]!=':':                    tmpCurStps=curSteps[-1].split('_')                    if len(tmpCurStps)>1:                        if tmpCurStps[1] == 'saw' and (len(tmpCurStps[0])==0 or tmpCurStps[0]=='eq'):                            curArrange='saw'                            #curSteps=curSteps[:-1]                        elif tmpCurStps[1] in ['ramp','random']:                            curArrange=tmpCurStps[1] #'ramp'                            if len(tmpCurStps[0])>0 and (tmpCurStps[0] in ['eq','norm']):                                curDist=tmpCurStps[0]                        curSteps=curSteps[:-1]                    elif len(tmpCurStps)>0:                        if tmpCurStps[0] in ['eq','norm']:                            curDist=tmpCurStps[0]                        curSteps=curSteps[:-1]                    else:                        curSteps=curSteps[:-1]            except:                pass            #Determine step distrubution            if len(curDist)==0:                curDist=defaultDist            if len(curArrange)==0:                curArrange=defaultArrange            try:                # don't compute steps if there are none                if (maxEmptyFlag==1) and (minEmptyFlag==1) and (type(curMin)==int or type(curMin)==float)\                and (type(curMax)==int or type(curMax)==float) and curMax==curMin:                    repOne = True                    computeSteps = 0                    compDist=False                elif type(curSteps)!=int and type(curSteps)!=float and len(curSteps)==0:                    computeSteps = 0                    compDist=False                elif curSteps[0] == ':':                    ## Old behavior adds steps of X distance from min+X to                     # Max -X, but it can miss the last step on odd numbers                    # Also, I don't like this behavior, so changeing it to                     # Create X number of equidistant  steps from min to max                    # excluding min to max and rounded for uint                    #try:                    #    newSteps = []                    #    rangeDelta = int(curSteps[1])                    #    #Create a list that is                     #    tempRange = range(curMin+rangeDelta,(curMax - rangeDelta)+1,rangeDelta)                    #    for n in tempRange:                    #        newSteps.append(n)                    #    curSteps = newSteps                    #except:                    #    computeSteps = 0                    try:                        #get number of steps                        numSteps = int(curSteps[1])                        #Create a list that is X+2 (+2 bc linspace is inclusive and we don't                        # want the max and min here)                        tempRange = np.linspace(curMin,curMax,numSteps+2)                        # if len(curSteps)==3 and type(curSteps[2])==str:                        #     curDist = str(curSteps[2])                        # else:                        #     curDist = 'eq'                        #     curArrange='random'                        # obsolete                        if (minEmptyFlag==1) and (maxEmptyFlag==1):                            curSteps = tempRange                        elif minEmptyFlag ==1:                            curSteps = tempRange[:-1]                        elif maxEmptyFlag ==1:                            curSteps = tempRange[1:]                        else:                            curSteps = tempRange[1:-1]                    except:                        computeSteps = 0                        compDist=False                # elif (type(curSteps)== list or type(curSteps)== np.ndarray) and len(curSteps)>3 and type(curSteps[-1]==str):                #     try:                #         curDist = str(curSteps[-1])                #         curSteps = curSteps[:-1]                #     except:                #         computeSteps = 0                # elif (type(curSteps) == list or type(curSteps)== np.ndarray) and len(curSteps)>=2:                #     if type(curSteps[-1])==str:                #         curSteps = curSteps[:-1]                #     curDist = 'eq'                            except:                # then it is singular and numeric                #computeSteps = 0                pass            if type(curSteps)==str:                computeSteps=0                compDist=False            elif type(curSteps)!=int and type(curSteps)!=float and len(curSteps)>0:                curSteps = np.array([s for s in curSteps if type(s)!= str])            # If there are no step values to interpret and no max/min probs, and not m/m rep one, continue else likely bug            if maxEmptyFlag==1 and minEmptyFlag==1 and repOne==False and type(curSteps)!=int and type(curSteps)!=float and len(curSteps) ==0:                tempArray[:,x]=np.NaN                tempCountArray[2,x]=int(np.round(curAvail*(1-(curMaxProb+curMinProb))))                continue                           # Total probability of all steps combined                curStepProb=1-(curMaxProb+curMinProb)                        if curStepProb <= 0:                curStepCount = 0                computeSteps = 0                tempCountArray[2,x]=curStepCount                compDist=False            elif curStepProb > 0:    # If there are trial probs left for steps                # and the steps are explicityly entered                if (type(curSteps)== list or type(curSteps)== np.ndarray) and\                len(probsAll)>2 and len(probsAll[2:])==len(curSteps):                    # record the probs                    curSP = probsAll[2:]                    if np.round(np.sum(curSP),5)<=curStepProb:                        # compute the number of trials for each step                        curStepProb=curSP                        curStepCount = [int(np.round(curAvail*s)) for s in curStepProb]                        # record the total number of these                        tempCountArray[2,x]=np.sum(curStepCount)                        # no need to create curStepCount                        compDist=False                    else:                        #total number of 'steps' trials                        curStepCount = int(np.round(curAvail*curStepProb))                        # save total number as before                        tempCountArray[2,x]=curStepCount                else: # if the steps are not explicitly declared                    #total number of 'steps' trials                    curStepCount = int(np.round(curAvail*curStepProb))                    # save total number as before                    tempCountArray[2,x]=curStepCount                if repOne==True:                tInd=availIndicies[:]                tempCountArray[2,x]=0                tempCountArray[0,x]=len(tInd)                tempCountArray[1,x]=0                             if len(tInd)>0:                    #set those indicies to min val, max is equal                     tempArray[tInd,x]=curMin                    availIndicies=[]                    #number remaining                    curAvail=len(availIndicies)            else:                if computeSteps==1 and compDist==True:                    # assign probabilities to steps based on distribution check cur dist                    # Check if explicitly declaired                    #if (type(curStepCount)==list or type(curStepCount)== np.ndarray)\                    #and len(curStepCount)>1 and computeSteps == 1 and len(availIndicies)>0: #if step probs were explicitly declared # depreciated                    curStpPrb=[]                    #                    if (type(curSteps)==int or type(curSteps)==float or len(curSteps)==1):                        curStpPrb.append(1.0)                        #curStepCount already accounted for                    # if only one step set to 100% prob                                         #if the distrobution is norm                    # LEFT OFF                    elif len(curSteps)>0:                        if curDist == 'norm':                        #if the Normal Distribution was selected                            curStpPrb = self.makeDistBins(np.arange(len(curSteps)),distShape='norm',totalProb=1) # make dist bin probs, changed from prev for asym if steps entered                            #curStpPrb = self.makeDistBins(curSteps, distShape='norm') #make bin probs  # old behavior, makes norm based on step distances                        else:                            # assumes if not 'norm' that is default 'eq' due to only two current possibilities                            curStpPrb = [1.0/len(curSteps) for s in range(len(curSteps))]                    # Set the curStepProb=curStpPrb                    curStepProb = np.array(curStpPrb)*curStepProb                    curStepCount = [int(np.round(curAvail*s)) for s in curStepProb]                #Steps need not be computed to arrange values                #treat Saw uniquely because of requisite dist and make arrange done                    # removed case (curDist=='eq' and compDist==True )                if curArrange=='saw' and ( (computeSteps == 1 and len(np.unique(curStepProb))==1 and (\                    (np.unique(curStepProb)[0]==curMaxProb and np.unique(curStepProb)[0]==curMinProb) or (np.unique(curStepProb)[0]==curMaxProb\                    and curMinProb==0) or (curMaxProb==0 and np.unique(curStepProb)[0]==curMinProb) or (curMaxProb==0 and curMinProb==0)))\                    or (computeSteps == 0 and curMinProb==0.5 and curMaxProb==0.5) ):                    # act like saw                    sortCounter=[]                    #currTrInd=0                    minMaxProbInd=0                    whileBreaker=True                    #set iterrator                    if computeSteps==1:                        if type(curSteps)== int or type(curSteps)== float:                            sortCounter.append(0)                        elif len(curSteps)>0:                            sortCounter= [s for s in range(len(curSteps)) if type(curSteps[s])!= str]                    try:                        #                        while curAvail>0:                            if minMaxProbInd==0:                                if curMinProb>0:                                    #mins                                    whileBreaker=False                                    #tempArray[availIndicies[currTrInd],x]=curMin  # This would bug, address is alwasy '0'                                    tempArray[availIndicies[0],x]=curMin                                    availIndicies=availIndicies[1:]                                    curAvail=len(availIndicies)                                    #currTrInd+=1                                minMaxProbInd=1                            elif minMaxProbInd==1:                                #probs                                for s in sortCounter:                                    #if len sC>0 testing that we are doing a step all done above, wont affect breaker otherwise                                    if curAvail>0:                                        #for safety - retested on each loop iter                                        whileBreaker=False                                        if type(curSteps)== int or type(curSteps)== float:                                            tempArray[availIndicies[0],x]=curSteps                                        else:                                            tempArray[availIndicies[0],x]=curSteps[s]                                        availIndicies=availIndicies[1:]                                        curAvail=len(availIndicies)                                    #currTrInd+=1                                minMaxProbInd=2                            elif minMaxProbInd==2:                                if curMaxProb>0:                                    #maxs                                    whileBreaker=False                                    tempArray[availIndicies[0],x]=curMax                                    availIndicies=availIndicies[1:]                                    curAvail=len(availIndicies)                                                                        #currTrInd+=1                                minMaxProbInd=3                            else:                                if whileBreaker:                                    print("Caution possible sawtooth sig gen issue {} inds remaining".format(len(availIndicies)))                                    break                                    # Nothing is being set and interating, something is wrong, break the loop to avoid hang                                else:                                    minMaxProbInd=0                                    whileBreaker=True                        arrangeDone=True                    except:                        print("error, check format")                                    elif curArrange=='saw':                    curArrange=defaultArrange                        #If saw selected but not possible, go to default                if arrangeDone==False and curArrange=='ramp':                    #If ramp selected, take all the values and ramp 'em - This is actually easy, just assign probs to counts and give in order of min-max-steps                    try:                        # deal with mins                        tInd=[]                        tInd=availIndicies[:curMinCount]                        if len(tInd)>0:                            #set those indicies to min val                            tempArray[tInd,x]=curMin                            #detele used indicies                             availIndicies=np.setdiff1d(availIndicies,tInd)                            #number remaining                            curAvail=len(availIndicies)                        if computeSteps==1:                            #Do the steps in order                            if type(curSteps)== int or type(curSteps)== float:                                tInd=[]                                tInd=availIndicies[:np.sum(curStepCount)]                                if len(tInd)>0:                                    tempArray[tInd,x]=curSteps                                    availIndicies=np.setdiff1d(availIndicies,tInd)                                    #number remaining                                    curAvail=len(availIndicies)                            else:                                for s in range(len(curSteps)):                                    tInd=[]                                    tInd=availIndicies[:curStepCount[s]]                                    if len(tInd)>0:                                        #                                        tempArray[tInd,x]=curSteps[s]                                        availIndicies=np.setdiff1d(availIndicies,tInd)                                        #number remaining                                        curAvail=len(availIndicies)                        # do maxs                        # grab max indicies                        tInd=[]                        tInd=availIndicies[:curMaxCount]                        if len(tInd)>0:                            # set the array vals to max                            tempArray[tInd,x]=curMax                            # removed used inds                            availIndicies=np.setdiff1d(availIndicies,tInd)                            # reset remaining number                            curAvail=len(availIndicies)                        if curAvail>0 and len(availIndicies)>0:                            # clean up remaing if any trials left by setting to 'highest'/last ramp val                            lastCoefAd = availIndicies[0]-1                            if lastCoefAd>=0:                                tempArray[availIndicies,x]=tempArray[lastCoefAd,x]                                availIndicies=[]                                curAvail=0                        arrangeDone=True                    except:                        print("error, check format")                elif arrangeDone==False and curArrange=='random':                    try:                        #work as previously with random                        # deal with mins                        #shuffle trial num length index                        np.random.shuffle(availIndicies)                        #slice indicies for min val trials                        tInd=[]                        tInd=availIndicies[:curMinCount]                        if len(tInd)>0:                            #set those indicies to min val                            tempArray[tInd,x]=curMin                            #detele used indicies                             availIndicies=np.setdiff1d(availIndicies,tInd)                            #number remaining                            curAvail=len(availIndicies)                        # re-shuffle                        np.random.shuffle(availIndicies)                        # grab max indicies                        tInd=[]                        tInd=availIndicies[:curMaxCount]                        if len(tInd)>0:                            # set the array vals to max                            tempArray[tInd,x]=curMax                            # removed used inds                            availIndicies=np.setdiff1d(availIndicies,tInd)                            # reset remaining number                            curAvail=len(availIndicies)                        #                        if computeSteps==1:                            #Do the steps in order                            if type(curSteps)== int or type(curSteps)== float:                                np.random.shuffle(availIndicies)                                tInd=[]                                tInd=availIndicies[:np.sum(curStepCount)]                                if len(tInd)>0:                                    tempArray[tInd,x]=curSteps                                    availIndicies=np.setdiff1d(availIndicies,tInd)                                    #number remaining                                    curAvail=len(availIndicies)                            else:                                for s in range(len(curSteps)):                                    np.random.shuffle(availIndicies)                                    tInd=[]                                    tInd=availIndicies[:curStepCount[s]]                                    if len(tInd)>0:                                        #                                        tempArray[tInd,x]=curSteps[s]                                        availIndicies=np.setdiff1d(availIndicies,tInd)                                        #number remaining                                        curAvail=len(availIndicies)                        arrangeDone=True                    except:                        print("error, check format")                        # # Old method using loop, random on probs    #assume dist = 'eq' but if more are added change to elif                        #     for g in range(len(availIndicies)):            # for each available ind                        #         selectedStep = np.random.choice(np.arange(len(curSteps))) #pick a step                        #         tempArray[availIndicies[g],x]=curSteps[selectedStep]    #set array to step value                        # # and for norm                        # curStpPrb = self.makeDistBins(curSteps, distShape='norm') #make bin probs                        # for g in range(len(availIndicies)):            # for each available ind                        #     selectedStep = np.random.choice(np.arange(len(curSteps)),p=curStpPrb)                 if arrangeDone==True and len(availIndicies)>0:                    # if there are unassigned inds after an attempt to assign, give proportionally at random                     print("Warning sig gen inds unassigned {} inds assigning randomly".format(len(availIndicies)))                    extrVals=[]                    extrProbs=[]                    extrVals.append(curMin)                    extrProbs.append(curMinProb)                    if computeSteps==1:                        if type(curSteps)== int or type(curSteps)== float:                            extrVals.append(curSteps)                            extrProbs.append(np.sum(curStepProb))                        elif len(curSteps)>0:                            for s in range(len(curSteps)):                                if type(curSteps[s])!=str:                                    extrVals.append(curSteps[s])                                    extrProbs.append(curStepProb[s])                    extrVals.append(curMax)                    extrProbs.append(curMaxProb)                    for g in range(len(availIndicies)):                        selectedStep=np.random.choice(extrVals,p=extrProbs)                        tempArray[availIndicies[g],x]=selectedStep                    availIndicies=[]                    curAvail=len(availIndicies)                                                       trialVar_pandaFrame = pd.DataFrame(tempArray,columns = varIndex)        return trialVar_pandaFrame,tempCountArray    # This function creates normally     # This reads a config file object and updates global settings it finds    def makeDistBins(self, binList,distShape='norm',totalProb=1):        ''' create distribution probabilities for a scale distributed list using a distribution fucntion '''                 problist=[]        binList.sort()        if type(binList)==list:            binList=np.array(binList)        # implementation for normal gaussian        if distShape == 'norm':            for ind in range(len(binList)):                if ind <= np.round(len(binList)*.5): # for lower half of range                    mn = np.mean([binList[ind],binList[ind+1]]) # find mid pont of num and next num for bin                    dn = binList[ind]-mn  # find the half bin size                    qwq=norm.cdf(mn,loc=binList.mean(),scale=binList.std())\                    -norm.cdf(binList[ind]+dn,loc=binList.mean(),scale=binList.std())                    #use cdf to find interval probaility between upper and lower bin limits                    problist.append(qwq)                        else:                    dn = np.mean([binList[ind],binList[ind-1]]) #same thing but relative to last num for upper half                    mn = binList[ind]-dn                    qwq=norm.cdf(binList[ind]+mn,loc=binList.mean(),scale=binList.std())\                    -norm.cdf(dn,loc=binList.mean(),scale=binList.std())                    problist.append(qwq)        pwp = [totalProb*(p/sum(problist)) for p in problist] #assume bins account for all possibilities p/sum and scale         probList=pwp        return probList    def updateDictFromTXT(self,varDict,configF):        for key in list(varDict.keys()):            try:                a = config['sesVars']['{}'.format(key)]                try:                    a=float(a)                    if a.is_integer():                        a=int(a)                    exec('varDict["{}"]={}'.format(key,a))                except:                    exec('varDict["{}"]="{}"'.format(key,a))            except:                pass        return varDict    # def generateTrialVariables(self,varName):    #     ## Not using these lists:    #     #[self.trialVars_sensory,_]=self.getFeatureProb(self.sensory)    #     #[self.trialVars_optical,_]=self.getFeatureProb(self.optical)    #     ## Create a distribution of jittered parameter trials    #     # TODO : This is the fuction and nest needed to rewrite based on my task(s)    #     exec("[self.trialVars_{},_]=self.getFeatureProb(self.{})".format(varName,varName))    #     #return self.trialVars_sensory,self.trialVars_timing,self.trialVars_optical    #     return eval("self.trialVars_{}".format(varName))    #def getRig(self):        # returns a string that is the hostname        #mchString=socket.gethostname()        #self.hostMachine=mchString.split('.')[0]        #return self.hostMachine    def dictToPandas(self,dictName):        curKey=[]        curVal=[]        for key in list(dictName.keys()):            curKey.append(key)            curVal.append(dictName[key])            self.pdReturn=pd.Series(curVal,index=curKey)        return self.pdReturn    def pandasToDict(self,pdName,curDict,colNum):        # Note TODO if used, I think this is just incorrect,         # it should not make a dict of PD lines (which seems to be the case)        # rather it should make a list of all lines in a column,        # enter that into a dict with key= column name        # then get the index, figuring for the possibility of a multi-index and a named index        # (index to list, check index levels, if >1 break them out, save all index column names)        varIt=0        csvNum=0        for k in list(pdName.index):            if len(pdName.shape)>1:                a=pdName[colNum][varIt]                csvNum=pdName.shape[1]            elif len(pdName.shape)==1:                a=pdName[varIt]            try:                a=float(a)                if a.is_integer():                    a=int(a)                curDict[k]=a                varIt=varIt+1            except:                curDict[k]=a                varIt=varIt+1                return curDict    def splitStepsVar(self,stepStr):        selectedDist=''        #cInd=[]        distFlg=False        if ':' in stepStr:            stepStr=stepStr.replace(':','')            stepStr=':'+stepStr                        if stepStr[1]!=',':                stepStr=stepStr[0]+','+stepStr[1:]            if not (stepStr[2].isdigit()):                stepStr=stepStr[2:]                #Remove dist indicator if it doesn't make sense        if 'eq' in stepStr:            stepStr=stepStr.replace('eq','')            stepStr=stepStr.replace('norm','')            #cInd = stepStr.find('eq')            #stepStr = stepStr[:cInd] + ',' + stepStr[cInd:]            selectedDist='eq'            distFlg=True            if stepStr[-1]==',':                stepStr=stepStr+'eq'            else:                stepStr=stepStr+',eq'        elif 'norm' in stepStr:            stepStr=stepStr.replace('norm','')            if stepStr[-1]==',':                stepStr=stepStr+'norm'            else:                stepStr=stepStr+',norm'            selectedDist='norm'            distFlg=True            #cInd = stepStr.find('norm')            # if stepStr[stepStr.find('norm')-1] != ',':            #     stepStr = stepStr[:cInd] + ',' + stepStr[cInd:]            #     selectedDist='norm'        if 'ramp' in stepStr:            stepStr=stepStr.replace('ramp','')            stepStr=stepStr.replace('saw','')            stepStr=stepStr.replace('_','')            if distFlg:                stepStr=stepStr+'_ramp'            elif len(stepStr)>=1 and stepStr[-1]==',':                stepStr=stepStr+'_ramp'            elif len(stepStr)>=1 and stepStr[-1]!=',':                stepStr=stepStr+',_ramp'            else:                stepStr='_ramp'            # if type(cInd)==int:            #     if stepStr[stepStr.find('ramp')-1-len(selectedDist):stepStr.find('ramp')] != selectedDist+'_':            #         rInd = stepStr.find('ramp')            #         stepStr=stepStr[:rInd]+stepStr[rInd+4:]            #         stepStr=stepStr.strip('_ ') # LEFT OFF            #         cInd = stepStr.find(selectedDist)            #         stepStr = stepStr[:cInd+len(selectedDist)] + '_ramp' + stepStr[cInd+len(selectedDist):]            # elif stepStr[stepStr.find('ramp')-2:stepStr.find('ramp')] != ',_':            #     if stepStr[stepStr.find('ramp')-1] != '_':            #         rInd = stepStr.find('ramp')            #         stepStr = stepStr[:rInd] + '_' + stepStr[rInd:]            #     if stepStr[stepStr.find('_ramp')-1] != ',':            #         rInd = stepStr.find('_ramp')            #         stepStr = stepStr[:rInd] + ',' + stepStr[rInd:]                     elif 'saw' in stepStr:            stepStr=stepStr.replace('saw','')            stepStr=stepStr.replace('_','')            if distFlg and (selectedDist=='norm'):                pass                #This arrangement is incompatible with uneven distributions            elif distFlg:                stepStr=stepStr+'_saw'            elif len(stepStr)>=1 and stepStr[-1]==',':                stepStr=stepStr+'_saw'            elif len(stepStr)>=1 and stepStr[-1]!=',':                stepStr=stepStr+',_saw'             else:                stepStr='_saw'                        # if type(cInd)==int:            #     if stepStr[stepStr.find('saw')-1-len(selectedDist):stepStr.find('saw')] != selectedDist+'_':            #         rInd = stepStr.find('saw')            #         stepStr=stepStr[:rInd]+stepStr[rInd+3:]            #         stepStr=stepStr.strip('_ ') # LEFT OFF            #         cInd = stepStr.find(selectedDist)            #         stepStr = stepStr[:cInd+len(selectedDist)] + '_saw' + stepStr[cInd+len(selectedDist):]            # elif stepStr[stepStr.find('saw')-2:stepStr.find('saw')] != ',_':            #     if stepStr[stepStr.find('saw')-1] != '_':            #         rInd = stepStr.find('saw')            #         stepStr = stepStr[:rInd] + '_' + stepStr[rInd:]            #     if stepStr[stepStr.find('_saw')-1] != ',':            #         rInd = stepStr.find('_saw')            #         stepStr = stepStr[:rInd] + ',' + stepStr[rInd:]            #After editing, account for double (or more) commas:        while ',,' in stepStr:            stepStr=stepStr.replace(',,',',')        #no white space or trailing comma        stepStr=stepStr.replace(' ','')        # if stepStr[-1]==',':        #     stepStr=stepStr[:-1]        stepStr=stepStr.strip(',')                                  a=stepStr.strip().split(',')        tempList = []        if len(a)>1:            for n in a:                n= self.inferType(n)                tempList.append(n)        else:            a[0]= self.inferType(a[0])            tempList=a        return tempList    def inferType(self,singleCharNum):        try:            # if it is numeric, it can be a float            singleCharNum = float(singleCharNum)            # but it may be an int ...            if singleCharNum.is_integer():                singleCharNum = int(singleCharNum)        except:            # keep it as is, because it is empty or a char/string            pass        return singleCharNum    def makeHDF(self,basePath,subID,dateStamp,cNm=None, crPs=None):        if cNm==None and crPs==None:            if not os.path.isdir(basePath):                os.mkdir(basePath)                        cStr=datetime.datetime.now().strftime("%Y%m%d%H%M%S")            hdfFileName=basePath / "{}_behav_{}.hdf".format(subID,cStr)            self.sesHDF = h5py.File(hdfFileName,"a")            return self.sesHDF, str(hdfFileName)        elif cNm!=None and crPs!=None:            if not os.path.isdir(basePath):                os.mkdir(basePath)                           cStr=datetime.datetime.now().strftime("%Y%m%d%H%M%S")            hdfFileName=basePath / "calibration_{}_pos_{}_{}_.hdf".format(cNm,crPs,cStr)            self.sesHDF = h5py.File(hdfFileName,"a")            return self.sesHDF, str(hdfFileName)    def saveJSONDict(self,saveDict,savePath,fileName):        if not os.path.isdir(savePath):            os.mkdir(savePath)        fileName = savePath / fileName        fileName = str(fileName)        savePath=str(savePath)        tmpSvDt=copy.deepcopy(saveDict)        if 'dirPath' in tmpSvDt.keys():            tmpSvDt['dirPath']=str(tmpSvDt['dirPath'])        with open("{}.json".format(fileName), "w") as outfile:            json.dump(tmpSvDt,outfile)        outfile.close()    def openJSONDict(self,fileName):        with open(fileName,'r') as infile:            newData=json.load(infile)            infile.close()        return newData    def savePanda(self,pandaList,savePath,fileName):        if not os.path.isdir(savePath):            os.mkdir(savePath)        fileName = savePath / fileName         fileName = str(fileName) + '.csv'        pandaList.to_csv(path_or_buf=fileName)class teensySerial(object):    ''' This creates a serial object to communicate with ekBehavior Teensy'''    def connectComObj(self,comPath,baudRate):        self.comObj = serial.Serial(comPath,baudRate,timeout=0,write_timeout=0)        # experimental add write timeout        self.comObj.close()        self.comObj.open()        return self.comObj    def readSerialBuffer(self,comObj,curBuf,bufMaxSize):                comObj.timeOut=0        #curBuf=curBuf+comObj.read(1)    #read only one byte (TODO asked Chris why)        #curBuf=curBuf+comObj.read(min(bufMaxSize-1, comObj.in_waiting)) #read the rest        #Experimental don't read first then rest, read all        curBuf=curBuf+comObj.read(comObj.in_waiting) #read the rest        i = curBuf.find(b"\n") #find the line break        r = curBuf[:i+1]    # set r to bytes up to and including that        curBuf = curBuf[i+1:]    #peel off everything in front of the line byte from the buffered array                echoDecode=bytes()        # make immutable byte arrays        tDataDecode=bytes()        eR=[]                    # make lists        sR=[]        errR=[]        kiR = []        tDB=r.find(b"tData")    # index data header        tDE=r.find(b"\r")        # index data carriage rtn (second to last byte)        if tDB>=0 and tDE>=1:            tDataDecode=r[tDB:tDE]        # Same for Data header            sR=tDataDecode.strip().decode()            sR=sR.split(',')        else:            eB=r.find(b"echo")        # index callback header            eE=r.find(b"~")            # index callback footer                        if eB>=0 and eE>=1:                # If echo header                echoDecode=r[eB:eE+1]        # select all the non-strip Chars                eR=echoDecode.strip().decode()    #decode callback data                eR=eR.split(',')            # make it a list            else:                #                errB=r.find(b"error")                    errE=r.find(b"\r")        # Same for command errors                if errB>=0 and errE>=1:            # Same for Command Error                    tErrDecode=r[errB:errE]                    errR=tErrDecode.strip().decode()                    errR=errR.split(',')                else:                    kiB=r.find(b"Clock under run -> kill")                    kiE=r.find(b"\r")        # Same for teensy scram                    #                                        if kiB>=0 and kiE>=1:            # Same for Kill Message                        tKillDecode=r[kiB:kiE]                        kiR=tKillDecode.strip().decode()                        kiR=kiR.split(',')        self.curBuf = curBuf                    self.echoLine = eR        self.dataLine = sR        self.errorLine = errR        self.tKillLine = kiR        return self.curBuf,self.echoLine,self.dataLine,self.errorLine,self.tKillLine    def readSerialData(self,comObj,headerString,varCount):        sR=[]        newData=0        bytesAvail=comObj.inWaiting()        if bytesAvail>0:            sR=comObj.readline().strip().decode()            sR=sR.split(',')            if len(sR)==varCount and sR[0]==headerString:                newData=1        bytesAvail=comObj.inWaiting()        self.sR=sR        self.newData=newData        self.bytesAvail = bytesAvail        return self.sR,self.newData,self.bytesAvail    def flushBuffer(self,comObj):        while comObj.inWaiting()>0:            sR=comObj.readline().strip().decode()            sR=[]    def checkVariable(self,comObj,headChar,fltDelay):        comObj.write('{}<'.format(headChar).encode('utf-8'))        time.sleep(fltDelay)        [tString,self.dNew,self.bAvail]=self.readSerialData(comObj,'echo',4)        if self.dNew:            if tString[1]==headChar:                self.returnVar=int(tString[2])        elif self.dNew==0:            self.returnVar=np.nan        return self.returnVar,self.dNew    def checkCOMPort(self,varDict):        tempPath,isCorrect = self.guessComPort(varDict)        cp = platform.system()        if (len(tempPath)>1) and (isCorrect or (cp != 'Darwin')):            varDict['comPath'] = tempPath        return varDict,isCorrect    def guessComPort(self,vdct):        cp = platform.system()        defPth=False        # if mac then teensy devices will be a cu.usbmodemXXXXX in /dev/ where XXXXX is the serial        # if arm linux, then the teensy is most likely /dev/ttyACM0        # if windows it will be some random COM.        self.comPath=''        if cp == 'Darwin':            try:                 devNames = self.checkForDevicesUnix('cu.u')                if len(devNames)==1:                    defPth=True                    self.comPath='/dev/' + devNames[0]                elif 'comPath' in vdct.keys():                    for thisDevName in devNames:                        if ('/dev/' + thisDevName) == vdct['comPath']:                            defPth=True                            self.comPath='/dev/' + thisDevName            except:                pass        elif cp == 'Windows':            self.comPath='COM3'        elif cp == 'Linux':            self.comPath='/dev/ttyACM0'        return self.comPath,defPth    def checkForDevicesUnix(self,startString):        dpth=Path('/dev')        devPathStrings = []        for child in dpth.iterdir():            if startString in child.name:                devPathStrings.append(child.name)        self.devPathStrings = devPathStrings        return self.devPathStrings    def commandTeensy(self,cmPath,baudRt,commandStr):        try:            teensy=self.connectComObj(cmPath,baudRt)            self.flushBuffer(teensy)            teensy.write("{}".format(commandStr).encode('utf-8'))        except:            print("couldn't connect check serial path")        if '<' in commandStr:            time.sleep(0.01)            [tString,dNew,_]=self.readSerialData(teensy,'echo',4)            if dNew:                print('{} = {}'.format(commandStr[0],int(tString[2])))            elif dNew==0:                print("No response")        teensy.close()    #def sendVisualValues(self,comObj,trialNum):    #        #    comObj.write('c{}>'.format(int(csVar.contrast[trialNum])).encode('utf-8'))    #    comObj.write('o{}>'.format(int(csVar.orientation[trialNum])).encode('utf-8'))    #    comObj.write('s{}>'.format(int(csVar.spatialFreq[trialNum])).encode('utf-8'))    #def sendVisualPlaceValues(self,comObj,trialNum):    #    comObj.write('z{}>'.format(int(csVar.stimSize[trialNum])).encode('utf-8'))    #    comObj.write('x{}>'.format(int(csVar.xPos[trialNum])).encode('utf-8'))    #    comObj.write('y{}>'.format(int(csVar.yPos[trialNum])).encode('utf-8'))class guiVariables:    def __init__(self):        # Function Variables        self.inTaskFlag = 0        self.tareFlag = 0        #self.checkWeightFlag=0        self.lastSubject=''        #Main Window Variables        self.dirPath=tk.StringVar()        self.subjID=tk.StringVar()        self.curSession=tk.StringVar()        self.weightResult=tk.StringVar()        self.weightResult.set('0.0 g')        self.plotType = tk.IntVar()        self.plotOutputNumber = tk.StringVar()        self.plotSeconds = tk.StringVar()        self.plotMinMax = tk.StringVar()        self.quitButtonText = tk.StringVar()        self.quitButtonText.set('Quit')        #Calibrate Window Piezo Variables        self.cal_moveIncSize = tk.StringVar()        self.cal_waveform = tk.StringVar()        self.cal_sampleCount = tk.StringVar()        self.cal_pulseCount = tk.StringVar()        self.cal_moveDistance = tk.StringVar()        self.cal_amp_min = tk.StringVar()        self.cal_amp_max = tk.StringVar()        self.cal_amp_steps = tk.StringVar()        self.cal_pulseDur_min = tk.StringVar()        self.cal_pulseDur_max = tk.StringVar()        self.cal_pulseDur_steps = tk.StringVar()        self.cal_pulseUpDur_min = tk.StringVar()        self.cal_pulseUpDur_max = tk.StringVar()        self.cal_pulseUpDur_steps = tk.StringVar()        self.cal_interPulseDur_min = tk.StringVar()        self.cal_interPulseDur_max = tk.StringVar()        self.cal_interPulseDur_steps = tk.StringVar()        self.cal_baseline = tk.StringVar()        self.cal_postTime = tk.StringVar()                self.cal_chanToUse = tk.StringVar()        self.cal_calibrateName = tk.StringVar()        self.cal_calibrateName.set('wavelist')        self.cal_calcButtonText = tk.StringVar()        self.cal_calcButtonText.set('Make')        self.cal_permNum = tk.StringVar()        self.cal_permNum.set('... Permutations')        self.cal_moveNum = tk.StringVar()        self.cal_moveNum.set('... Total Moves')        self.cal_moveTime = tk.StringVar()        self.cal_moveTime.set('Time Till Move: ... [s]')        self.cal_totalTime = tk.StringVar()        self.cal_totalTime.set('Estimated Total Time: ... [s]')        self.cal_runButtonText = tk.StringVar()        self.cal_runButtonText.set('Run')        self.cal_findButtonText = tk.StringVar()        self.cal_findButtonText.set('Find Start')        self.cal_moveText = tk.StringVar()        self.cal_moveText.set('Make Protocol')        self.cal_positionText = tk.StringVar()        self.cal_positionText.set('Current position: ... um')        self.permNumber=[]        self.moveCount=[]        self.movesRemaining=[]        self.sweepDuration=[]        self.secsToNextMove=[]        self.estimatedTotalTime=[]        self.estTotalTimeRemaining=[]        self.cal_trlsReady=False        self.curPosition=0        self.calibrationActive=False        self.calPandaDict={}        #Calibrate sensor test Window variables        self.cal_curPositionUm=tk.StringVar()        self.cal_numPointsSet=tk.StringVar()        self.cal_numPointsSet.set('… Points Set')        self.cal_testStartStop=tk.StringVar()        self.cal_testChannel=tk.StringVar()        self.cal_testAmp=tk.StringVar()        self.cal_testPulseDur=tk.StringVar()        self.cal_testPulseUpDur=tk.StringVar()        self.cal_testInterPulseDur=tk.StringVar()        self.cal_testWaveShape=tk.StringVar()        self.cal_sensorValuesList=[]        self.cal_pulseRunning=False        self.cal_pulsingChannel=[]        # Detection Task Variables        self.noLickTime = tk.StringVar()        self.noRunTime = tk.StringVar()        self.startCueChannel = tk.StringVar()        self.startCueDur = tk.StringVar()        self.rewardChannel = tk.StringVar()        self.rewardDur = tk.StringVar()        self.widthdrawChannel = tk.StringVar()        self.widthdrawDur = tk.StringVar()        self.rewardWindow = tk.StringVar()        self.timeoutDur = tk.StringVar()        self.timeoutCueChannel = tk.StringVar()        self.timeoutCueDur = tk.StringVar()        self.enforceNoLick = tk.StringVar()        self.enforceNoRun = tk.StringVar()        self.taskName=tk.StringVar()        # self.enforceTimeOut = tk.StringVar()        # self.rewardAlways = tk.StringVar()        self.plotLicks = tk.StringVar()        self.plotPerformance = tk.StringVar()        #self.weight = tk.StringVar()        self.lickLatch = tk.StringVar()        self.minStim = tk.StringVar()        self.endCueChannel = tk.StringVar()        self.endCueDur = tk.StringVar()        # self.weight.set('Mass: ... [g]')        # self.weightChange = tk.StringVar()        # self.weightChange.set('Mass Change: >>> [g]')        self.det_buttonText = tk.StringVar()        self.det_buttonText.set('Run Task')        self.responseWindowMin = tk.StringVar()        self.responseWindowMax = tk.StringVar()        self.rwdDelay = tk.StringVar()        self.respToCueDelay = tk.StringVar()        self.hitCueChannel = tk.StringVar()        self.hitCueDur = tk.StringVar()        self.missCueChannel = tk.StringVar()        self.missCueDur = tk.StringVar()        self.crCueChannel = tk.StringVar()        self.crCueDur = tk.StringVar()        self.faCueChannel = tk.StringVar()        self.faCueDur = tk.StringVar()        self.rewardHit = tk.StringVar()        self.rewardMiss = tk.StringVar()        self.rewardCr = tk.StringVar()        self.rewardFa = tk.StringVar()        self.timeoutHit = tk.StringVar()        self.timeoutMiss = tk.StringVar()        self.timeoutCr = tk.StringVar()        self.timeoutFa = tk.StringVar()        #Teensy Setup Variables        self.comPath = tk.StringVar()        self.tsy_command = tk.StringVar()        self.tsy_command.set('a<  (example, check on/off command)')        self.sampRate = tk.StringVar()        # Design Variables        self.trialCount=tk.StringVar()        self.trialTime_min=tk.StringVar()        self.trialTime_max=tk.StringVar()        self.trialTime_steps=tk.StringVar()        self.trialTime_probs=tk.StringVar()        self.chanToUse=tk.StringVar()        self.chanToUseType=tk.StringVar()        self.syncGroup=tk.StringVar()        self.waveform=tk.StringVar()        self.rewardStimulus=tk.StringVar()        self.rewardStimulus.set('0')        self.catchStimulus=tk.StringVar()        self.catchStimulus.set('0')                self.offset_min=tk.StringVar()        self.offset_max=tk.StringVar()        self.offset_steps=tk.StringVar()        self.offset_probs=tk.StringVar()        self.amp_min=tk.StringVar()        self.amp_max=tk.StringVar()        self.amp_steps=tk.StringVar()        self.amp_probs=tk.StringVar()        self.pulseDur_min=tk.StringVar()        self.pulseDur_max=tk.StringVar()        self.pulseDur_steps=tk.StringVar()        self.pulseDur_probs=tk.StringVar()        self.pulseUpDur_min=tk.StringVar()        self.pulseUpDur_max=tk.StringVar()        self.pulseUpDur_steps=tk.StringVar()        self.pulseUpDur_probs=tk.StringVar()        self.interPulseDur_min=tk.StringVar()        self.interPulseDur_max=tk.StringVar()        self.interPulseDur_steps=tk.StringVar()        self.interPulseDur_probs=tk.StringVar()        self.pulseTrainDur_min=tk.StringVar()        self.pulseTrainDur_max=tk.StringVar()        self.pulseTrainDur_steps=tk.StringVar()        self.pulseTrainDur_probs=tk.StringVar()        self.pulseCount_min=tk.StringVar()        self.pulseCount_max=tk.StringVar()        self.pulseCount_steps=tk.StringVar()        self.pulseCount_probs=tk.StringVar()        self.designList=tk.StringVar()        self.addOffset_min=tk.StringVar()        self.addOffset_max=tk.StringVar()        self.addOffset_steps=tk.StringVar()        self.addOffset_probs=tk.StringVar()        self.blockName = tk.StringVar()        self.designVariablesDict ={        'channelFields':['chanToUse','chanToUseType','syncGroup','waveform','rewardStimulus','catchStimulus',        'offset_min','offset_max','offset_steps','offset_probs','amp_min','amp_max',        'amp_steps','amp_probs','pulseDur_min','pulseDur_max','pulseDur_steps',        'pulseDur_probs','pulseUpDur_min','pulseUpDur_max','pulseUpDur_steps',        'pulseUpDur_probs','interPulseDur_min','interPulseDur_max',        'interPulseDur_steps','interPulseDur_probs','pulseTrainDur_min',        'pulseTrainDur_max','pulseTrainDur_steps','pulseTrainDur_probs',        'pulseCount_min','pulseCount_max','pulseCount_steps','pulseCount_probs'],        'offsetFields':['addOffset_min','addOffset_max','addOffset_steps','addOffset_probs'],        'blockFields':['blockName','trialCount','trialTime_min','trialTime_max','trialTime_steps',        'trialTime_probs','designList']        }        # Block Design Variables        self.experimentName = tk.StringVar()        self.shuffleGroup = tk.StringVar()        self.blockList = tk.StringVar()        self.detectionVariablesDict = {        'floatFields':['noLickTime','noRunTime','startCueDur','rewardDur','widthdrawDur',        'rewardWindow','timeoutDur','timeoutCueDur','lickLatch','minStim','endCueDur',        'responseWindowMin','responseWindowMax','rwdDelay','respToCueDelay','hitCueDur',        'missCueDur','crCueDur','faCueDur'],        'intFields':['startCueChannel','rewardChannel','widthdrawChannel','timeoutCueChannel',        'enforceNoLick','endCueChannel','plotLicks','plotPerformance',        'enforceNoRun','hitCueChannel','missCueChannel','crCueChannel','faCueChannel',        'rewardHit','rewardMiss','rewardCr','rewardFa','timeoutHit','timeoutMiss','timeoutCr','timeoutFa']        }        #This contains the information to decode the outmessages per channel        # serial addresses are 9,10,11 in sesData        # // variable 1: [bils:mils[dac4],hundThous:hunds[dac1],tens:units[dout2,dout0]        # // variable 2: [bils:mils[potential dac5],hundThous:hunds[dac2],tens:units[dout3,dout1]        # // variable 3: [n/a (extra 2),TenMils:TenThous[dac3],thous:units[dac0]        # 9= DAC4*1000000, DAC1*100, dOut2*10,dOut0        # 10= DAC2*100, dOut3*10, dOut1        # 11= DAC3*10000, dac0        # subtract one from GUI# for GUI convention        self.outValsDict = {0:{4:(9,1000000),1:(9,100),2:(10,100),3:(11,10000),0:(11,1)},1:{2:(9,10),0:(9,1),3:(10,10),1:(10,1)}}        #Activity Monitor Variables:    def setActivityVars(self):        self.trialState = tk.StringVar()        self.massCurrent = tk.StringVar()        self.massDelta = tk.StringVar()        self.lckDelays = tk.StringVar()        self.rnDelays = tk.StringVar()        self.consumedCount = tk.StringVar()                # self.weight.set('Mass: ... [g]')        # self.weightChange = tk.StringVar()        # self.weightChange.set('Mass Change: >>> [g]')        class genGUI:    def defaultCom(self):        self.varObj.sesVarDict,isCor=self.serObj.checkCOMPort(self.varObj.sesVarDict)        if isCor:            self.saveDefaultDict()        self.variables.comPath.set(self.varObj.sesVarDict['comPath'])        self.variables.sampRate.set(self.varObj.sesVarDict['sampRate'])    def populateMain(self):        self.variables.dirPath.set(self.varObj.sesVarDict['dirPath'])        self.variables.subjID.set(self.varObj.sesVarDict['subjID'])        self.variables.curSession.set(self.varObj.sesVarDict['curSession'])    def __init__(self, master, varObj,serObj):        self.master = master        self.varObj=varObj        self.serObj=serObj        self.master.title('Teensy Experiment Control')        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.top = self.master.winfo_toplevel()        self.top.grid()        self.top.rowconfigure(0, weight=1)         self.top.columnconfigure(0, weight=1)         self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)         self.frame.columnconfigure(0, weight=1)        self.frame.columnconfigure(1, weight=1)        self.loadDefaultDict()        self.varObj.resetDict('blockDesignDict')        self.variables = guiVariables()        self.defaultCom()        self.savePathButton = tk.Button(self.frame, text='Save Path:', font=self.midFont, justify='right', command=self.getPath)        self.savePathButton.grid(row=0,column=0, sticky=tk.N+tk.S+tk.E+tk.W)        self.savePathEntry = tk.Entry(self.frame, font = self.smallFont, justify='left', textvariable=self.variables.dirPath)        self.savePathEntry.grid(row=0,column=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(1, weight=1)         self.subjectIDLabel = tk.Label(self.frame, text='Subject ID:',font=self.midFont, justify='right')        self.subjectIDLabel.grid(row=1,column=0)        self.subjectIDEntry = tk.Entry(self.frame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.subjID)        self.subjectIDEntry.grid(row=1,column=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(2, weight=1)        self.curSessionLabel = tk.Label(self.frame, text='Session #: ',font=self.midFont, justify='right')        self.curSessionLabel.grid(row=2,column=0)        self.curSessionEntry = tk.Entry(self.frame, width = 3, font = self.smallFont, justify='right', textvariable=self.variables.curSession)        self.curSessionEntry.grid(row=2,column=1, sticky=tk.N+tk.S+tk.E+tk.W)         self.frame.rowconfigure(3, weight=1)         self.weightLabel = tk.Label(self.frame, text='Weight: ',font=self.midFont, justify='right')        self.weightLabel.grid(row=3,column=0)        self.weightResultLabel = tk.Label(self.frame, font=self.midFont, justify='right', textvariable=self.variables.weightResult)        self.weightResultLabel.grid(row=3,column=1, sticky=tk.W)        self.frame.rowconfigure(4, weight=1)         self.scaleTareButton = tk.Button(self.frame, text='Tare', font=self.smallFont, justify='center', command=self.tareLoadCell)        self.scaleTareButton.grid(row=4,column=0, sticky=tk.N+tk.S+tk.E+tk.W)        self.scaleCheckButton = tk.Button(self.frame, text='Check', font=self.smallFont, justify='center', command =self.checkLoadCell)        self.scaleCheckButton.grid(row=4,column=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(5, weight=1)         self.detectionTaskButton = tk.Button(self.frame, text='Stimuli Experiment', font=self.midFont, justify='center', command = self.openDetection)        self.detectionTaskButton.grid(row=5,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        # self.frame.rowconfigure(6, weight=1)         # self.simpleStimulusButton = tk.Button(self.frame, text='Simple Stimuli Trials', font=self.midFont, justify='center')        # self.simpleStimulusButton.grid(row=6,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(6, weight=1)         self.recordOnlyButton = tk.Button(self.frame, text='Record Sensors Only', font=self.midFont, justify='center',\            command = self.recordOnly)        self.recordOnlyButton.grid(row=6,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(7, weight=1)         self.calibratePiezoButton = tk.Button(self.frame, text='Calibrate', font=self.midFont, justify='center', command = self.openCalibrate)        self.calibratePiezoButton.grid(row=7,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(8, weight=1)        self.monitorOnlyButton = tk.Button(self.frame, text='Monitor Only', font=self.midFont, justify='center', command = self.runMonitor)        self.monitorOnlyButton.grid(row=8,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(9, weight=1)        self.plotLabelFrame = tk.LabelFrame(self.frame, text='Plot Selection', labelanchor='nw')        self.plotLabelFrame.grid(row=9,column=0, columnspan=2, padx = 3, pady = 3, sticky=tk.N+tk.S+tk.E+tk.W)        self.plotLabelFrame.rowconfigure(0, weight=1)        self.plotLabelFrame.rowconfigure(1, weight=1)        self.plotLabelFrame.rowconfigure(2, weight=1)        self.plotLabelFrame.rowconfigure(3, weight=1)        self.plotLabelFrame.rowconfigure(4, weight=1)        self.plotLabelFrame.rowconfigure(5, weight=1)        self.plotLabelFrame.rowconfigure(6, weight=1)        self.plotLabelFrame.columnconfigure(0, weight = 1)        self.plotLabelFrame.columnconfigure(1, weight = 1)                self.plotNothing= tk.Radiobutton(self.plotLabelFrame, text = 'Nothing', font = self.smallFont, variable = self.variables.plotType,\            value = 0)        self.plotNothing.select()        self.plotNothing.grid(row=0,column=0, sticky=tk.W)        self.plotForce= tk.Radiobutton(self.plotLabelFrame, text = 'Load Cell Force (N)', font = self.smallFont, variable = self.variables.plotType,\            value = 3)        self.plotForce.grid(row=0,column=1, sticky=tk.W)        self.plotWheel= tk.Radiobutton(self.plotLabelFrame, text = 'Wheel Rotation', font = self.smallFont, variable = self.variables.plotType,\            value = 5)        self.plotWheel.grid(row=1,column=0, sticky=tk.W)        self.plotLick= tk.Radiobutton(self.plotLabelFrame, text = 'Licks', font = self.smallFont, variable = self.variables.plotType,\            value = 4)        self.plotLick.grid(row=1,column=1, sticky=tk.W)        self.plotInput0= tk.Radiobutton(self.plotLabelFrame, text = 'Input 1', font = self.smallFont, variable = self.variables.plotType,\            value = 7)        self.plotInput0.grid(row=2,column=0, sticky=tk.W)        self.plotInput1= tk.Radiobutton(self.plotLabelFrame, text = 'Input 2', font = self.smallFont, variable = self.variables.plotType,\            value = 8)        self.plotInput1.grid(row=3,column=0, sticky=tk.W)        self.plotDAC= tk.Radiobutton(self.plotLabelFrame, text = 'DAC: ', font = self.smallFont, variable = self.variables.plotType,\            value = 9)        self.plotDAC.grid(row=2,column=1, sticky=tk.W)        self.plotDO= tk.Radiobutton(self.plotLabelFrame, text = 'DOut: ', font = self.smallFont, variable = self.variables.plotType,\            value = 10)        self.plotDO.grid(row=3,column=1, sticky=tk.W)        self.plotOutputLabel = tk.Label(self.plotLabelFrame, text='DAC/DOut #: ',font=self.smallFont, justify='right')        self.plotOutputLabel.grid(row=4,column=0, sticky=tk.E)        self.plotOutputEntry = tk.Entry(self.plotLabelFrame, width = 2, font = self.smallFont, justify='right',\            textvariable=self.variables.plotOutputNumber)        self.variables.plotOutputNumber.set('1')        self.plotOutputEntry.grid(row=4,column=1,sticky=tk.W)        self.plotSecondsLabel = tk.Label(self.plotLabelFrame, text='Axis width [s]: ',font=self.smallFont, justify='right')        self.plotSecondsLabel.grid(row=5,column=0, sticky=tk.E)        self.plotSecondsEntry = tk.Entry(self.plotLabelFrame, width = 4, font = self.smallFont, justify='right',\            textvariable=self.variables.plotSeconds)        self.variables.plotSeconds.set('5.0')        self.plotSecondsEntry.grid(row=5,column=1, sticky=tk.W)        self.plotRangeLabel = tk.Label(self.plotLabelFrame, text='Axis Min/Max: ',font=self.smallFont, justify='right')        self.plotRangeLabel.grid(row=6,column=0, sticky=tk.E)        self.plotRangeEntry = tk.Entry(self.plotLabelFrame, width = 4, font = self.smallFont, justify='right',\            textvariable=self.variables.plotMinMax)        self.variables.plotMinMax.set('0,4096')        self.plotRangeEntry.grid(row=6,column=1, sticky=tk.W)                self.frame.rowconfigure(10, weight=1)                self.stimDesignButton = tk.Button(self.frame, text = 'Design Stimuli', font = self.midFont, command = self.openStimDesign)        self.stimDesignButton.grid(row=10,column=0,sticky=tk.N+tk.S+tk.E+tk.W)        self.teensyComButton = tk.Button(self.frame, text = 'Teensy Setup', font = self.midFont, command = self.openTeensyCom)        self.teensyComButton.grid(row=10,column=1,sticky=tk.N+tk.S+tk.E+tk.W)                self.frame.rowconfigure(11, weight=1)        self.quitButton = tk.Button(self.frame, textvariable=self.variables.quitButtonText, command = self.close_windows)        self.quitButton.grid(row=11,column=0, columnspan=2, padx=5,pady=5,sticky=tk.N+tk.S+tk.E+tk.W)        self.populateMain()        self.getMainFields()        self.saveDefaultDict()        #self.openActivityWindow()        #self.variables.lastSubject=taskVar.sesVarDict['subjID']    def getMainFields(self):        taskVar.sesVarDict['curSession']=int(self.variables.curSession.get())        taskVar.sesVarDict['dirPath']=Path(self.variables.dirPath.get())        taskVar.sesVarDict['subjID']=self.variables.subjID.get()    def loadDefaultDict(self):        #curDir = Path(os.getcwd())        curDir = Path(os.path.realpath(os.path.dirname(__file__)))        if Path(curDir / 'config.json').exists():            # load the file            configFile=curDir / 'config.json'            with open(configFile) as json_file:                tempTaskParams = json.load(json_file)                json_file.close()            #for varToLoad in taskVar.sesVarDict.keys():            for varToLoad in taskVar.sesVarDict.keys():                if varToLoad == 'dirPath':                    taskVar.sesVarDict[varToLoad]=Path(tempTaskParams[varToLoad])                elif varToLoad in tempTaskParams.keys():                    taskVar.sesVarDict[varToLoad]=self.varObj.inferType(tempTaskParams[varToLoad])        else:            taskVar.sesVarDict['dirPath']=curDir            #Create the file            self.varObj.saveJSONDict(taskVar.sesVarDict,curDir,'config')    def saveDefaultDict(self):        #curDir = Path(os.getcwd())        curDir = Path(os.path.realpath(os.path.dirname(__file__)))        self.varObj.saveJSONDict(taskVar.sesVarDict,curDir,'config')            def tareLoadCell(self):        if self.variables.inTaskFlag==1:            return        self.variables.tareFlag=1        self.variables.lastSubject=self.variables.subjID.get()        try:            teensy=taskSer.connectComObj(self.variables.comPath.get(),taskVar.sesVarDict['baudRate_teensy'])            taskSer.flushBuffer(teensy)            wVals=[]            lIt=0            while lIt<30:                [rV,vN]=taskSer.checkVariable(teensy,'l',0.100)                if vN:                    wVals.append(float(rV)/100.0)                    lIt=lIt+1            # iMass=np.mean(wVals)            # if iMass<0:            #     iMass=0.0                        taskVar.sesVarDict['loadBaseline']=np.mean(wVals)            print("Scale Tared, Baseline = {:.2f}g".format(taskVar.sesVarDict['loadBaseline']))            taskSer.flushBuffer(teensy)            teensy.close()        except:            try:                taskSer.flushBuffer(teensy)                teensy.close()                   except:                pass        # if len(self.varObj.experimentPandas['trialParameters'])==0:        #     self.variables.det_buttonText.set('Create Trials')        # elif self.variables.inTaskFlag==0:        #     self.variables.det_buttonText.set('Run Task')        # if self.variables.inTaskFlag==0:        #     self.recordOnlyButton['text']='Record Sensors Only'    def checkLoadCell(self):        if self.variables.inTaskFlag==1:            return        iMass=0.0                if self.variables.tareFlag==1:            if self.variables.lastSubject!=self.variables.subjID.get():                self.variables.tareFlag=0                self.variables.lastSubject=self.variables.subjID.get()                print('Warning, scale not tared')            #try:            teensy=taskSer.connectComObj(self.variables.comPath.get(),taskVar.sesVarDict['baudRate_teensy'])            taskSer.flushBuffer(teensy)                        wVals=[]            lIt=0            while lIt<30:                [rV,vN]=taskSer.checkVariable(teensy,'l',0.100)                if vN:                    wVals.append(float(rV)/100.0)                    lIt=lIt+1            iMass=np.mean(wVals)-taskVar.sesVarDict['loadBaseline']            if iMass<0:                iMass=0.0            taskSer.flushBuffer(teensy)            teensy.close()            # except:            #     iMass=0.0                # try:                #     taskSer.flushBuffer(teensy)                #     teensy.close()                # except:                #     pass        #self.variables.currentMass=iMass        print('{:.2f} g'.format(iMass))        self.variables.weightResult.set('{:.2f} g'.format(iMass))    def getPath(self):        try:            tPth = fd.askdirectory(title ="Choose Save Folder")            basePath = Path(tPth)        except:            # default to home directory            basePath=Path(str(Path.home()))        self.variables.tareFlag=0        #self.variables.checkWeightFlag=0        self.varObj.sesVarDict['dirPath']=basePath        self.varObj.sesVarDict['subjID']=basePath.name        self.variables.dirPath.set(basePath)        self.variables.subjID.set(basePath.name)        self.variables.tareFlag=0        self.toggleTaskButtons(1)        self.getMainFields()        self.saveDefaultDict()        #csVar.sesVarDict = self.loadCSVDictionary(csVar.sesVarDict,basePath.joinpath('sesVars.csv'))        #csVar.timing = self.loadCSVDictionary(csVar.timing,basePath.joinpath('timingVars.csv'))        #csVar.sensory = self.loadCSVDictionary(csVar.sensory,basePath.joinpath('sensVars.csv'))        #csVar.optical = self.loadCSVDictionary(csVar.optical,basePath.joinpath('opticalVars.csv'))    def toggleTaskButtons(self,boolState=1):        if boolState == 1:            self.detectionTaskButton['state'] = 'normal'            #self.simpleStimulusButton['state'] = 'normal'            self.recordOnlyButton['state'] = 'normal'            self.calibratePiezoButton['state'] = 'normal'        elif boolState == 0:            self.detectionTaskButton['state'] = 'disabled'            #self.simpleStimulusButton['state'] = 'disabled'            self.recordOnlyButton['state'] = 'disabled'            self.calibratePiezoButton['state'] = 'disabled'    def recordOnly(self):        if self.variables.inTaskFlag==0:            if self.variables.tareFlag==1:                if self.variables.lastSubject!=self.variables.subjID.get():                    self.variables.tareFlag=0                    self.variables.lastSubject=self.variables.subjID.get()                    print('Please Tare Scale')                else:                    self.getMainFields()                    self.saveDefaultDict()                    self.variables.inTaskFlag=1                    self.recordOnlyButton['text']='End Session'                    self.variables.quitButtonText.set('End Session')                    self.varObj.sesVarDict['taskType']='simpleRecording'                    self.openActivityWindow()                    threading.Thread(target=self.recordOnlyThread).start()            else:                #self.recordOnlyButton['text']='Please Tare Scale'                print('Please Tare Scale')        else:            self.varObj.sesVarDict['sessionOn']=0            self.variables.inTaskFlag=0            self.variables.quitButtonText.set('Quit')            self.recordOnlyButton['text']='Record Sensors Only'    def recordOnlyThread(self):        runSimpleRecord()    def runMonitor(self):        #        if self.variables.inTaskFlag==0:            #            self.getMainFields()            self.saveDefaultDict()            self.variables.inTaskFlag=1            self.monitorOnlyButton['text']='End Session'            self.variables.quitButtonText.set('End Session')            self.varObj.sesVarDict['taskType']='monitorOnly'            self.openActivityWindow()            threading.Thread(target=self.runMonitorThread).start()        else:            self.varObj.sesVarDict['sessionOn']=0            self.variables.inTaskFlag=0            self.variables.quitButtonText.set('Quit')            self.monitorOnlyButton['text']='Monitor Only'            self.variables.quitButtonText.set('Quit')    def runMonitorThread(self):        runMonitorOnly()    def checkStrVar(self):        tempStr = self.variables.dirPath.get()        self.subjectIDEntry.delete(0,tk.END)        self.subjectIDEntry.insert(tk.END,tempStr)    def openDetection(self):        self.getMainFields()        self.saveDefaultDict()                self.detectionTaskWindow = tk.Toplevel(self.master)        self.detectionTask = detectionTaskGUI(self.detectionTaskWindow,self.variables,self.varObj,self)    def openStimDesign(self):        self.getMainFields()        self.saveDefaultDict()                self.stimDesignWindow = tk.Toplevel(self.master)        self.stimDesign = stimDesignGUI(self.stimDesignWindow,self.variables,self.varObj,self)    def openTeensyCom(self):        self.getMainFields()        self.saveDefaultDict()                self.teensyComWindow = tk.Toplevel(self.master)        self.teensyCom = teensyComGUI(self.teensyComWindow,self.variables,self.varObj,self.serObj,self)    def openCalibrate(self):        self.getMainFields()        self.saveDefaultDict()                self.calibratePiezoWindow = tk.Toplevel(self.master)        self.calibratePiezo = calibratePiezoGUI(self.calibratePiezoWindow,self.variables,self.varObj,self)    def openActivityWindow(self):        #self.getMainFields()        #self.saveDefaultDict()        if hasattr(self,'activity') and ('normal'== self.activityWindow.state()):            self.activity.closeActivityMonitor()                         self.activityWindow = tk.Toplevel(self.master)        self.activity = activityMonitorGUI(self.activityWindow,self.variables,self.varObj,self)            def close_windows(self):        if not self.variables.inTaskFlag:            try:                if hasattr(self,'stimDesign') and ('normal'== self.stimDesignWindow.state()):                    self.stimDesign.close_windows()                            except:                pass            try:                if hasattr(self,'detectionTask') and ('normal'== self.detectionTaskWindow.state()):                    self.detectionTask.close_windows()                                                except:                pass            try:                if hasattr(self,'teensyCom') and ('normal'== self.teensyComWindow.state()):                    self.teensyCom.close_windows()                                          except:                pass            try:                if hasattr(self,'calibratePiezo') and ('normal'== self.calibratePiezoWindow.state()):                    self.calibratePiezo.close_windows()                                     except:                pass            try:                if hasattr(self,'activity') and ('normal'== self.activityWindow.state()):                    self.activity.closeActivityMonitor()                                    except:                pass                                           self.master.destroy()        else:            if self.variables.calibrationActive==True:                self.calibratePiezo.startCalibration() # Turn off calibration            else:                self.variables.inTaskFlag=0                self.variables.quitButtonText.set('Quit')                self.varObj.sesVarDict['sessionOn']=0                self.recordOnlyButton['text']='Record Sensors Only'                self.monitorOnlyButton['text']='Monitor Only'                self.variables.det_buttonText.set('Create Trials')class activityMonitorGUI:    def __init__(self, master, variables,varObj,mainGUI):        self.currSignals=[]        self.activityCallback=''        self.currentInt=[]        self.currentTime=[]        self.currentTrialTime=[]        self.currentTrial=[]        self.trialTotal=[]        self.lastSignalTime=[]        self.thisTrialSignals=np.array([],dtype=np.double)        self.massDtSample=[]        self.massStart=[]        self.plotRunning=False        self.master = master        self.variables=variables        self.variables.setActivityVars()        self.varObj=varObj        self.mainGUI=mainGUI        self.master.title("Activity Monitor")        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.top = self.master.winfo_toplevel()        self.top.grid()        self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)         self.frame.columnconfigure(0, minsize=500)        self.frame.columnconfigure(1, minsize=300, weight=1)        self.top.rowconfigure(0, weight=1)         self.top.columnconfigure(0, weight=1)                  self.variables.trialState.set('Standing By')        self.noLickTimeLabel = tk.Label(self.frame, textvariable=self.variables.trialState, font=self.midFont)        self.noLickTimeLabel.grid(row=0,column=0,columnspan=2)        self.frame.rowconfigure(1, weight=1)        #self.temporaryPlotLabel = tk.Label(self.frame, text='This will be a really great plot', font=self.midFont)        #self.temporaryPlotLabel.grid(row=1,column=0, padx = 3, pady = 3)        self.mainPlot=mainFigure(self.varObj,self.mainGUI,self.frame)        self.mainPlot.canvas.get_tk_widget().grid(row=1,column=0, padx = 3, pady = 3,sticky=tk.N+tk.S+tk.E+tk.W)        self.basicDataFrm = tk.Frame(self.frame)        self.basicDataFrm.grid(row=1, column=1, padx = 3, pady = 3, sticky=tk.N+tk.S+tk.E+tk.W)        self.basicDataFrm.rowconfigure(0, weight=1)         self.basicDataFrm.columnconfigure(0, weight=1)                self.variables.massCurrent.set('Load reading: {:.2f}g, {:.2f}N'.format(0.0,0.0*0.00980665))        self.massCurrentLabel= tk.Label(self.basicDataFrm, textvariable=self.variables.massCurrent, font=self.smallFont)        self.massCurrentLabel.grid(row=0, column=0, sticky=tk.W)        self.basicDataFrm.rowconfigure(1, weight=1)        self.variables.massDelta.set('Load Change: {:.2f}g, {:.2f}N'.format(0.0,0.0*0.00980665))        self.massDeltaLabel= tk.Label(self.basicDataFrm, textvariable=self.variables.massDelta, font=self.smallFont)        self.massDeltaLabel.grid(row=1, column=0, sticky=tk.W)        self.basicDataFrm.rowconfigure(2, weight=1)        self.variables.consumedCount.set('Rewards Taken: {}'.format(0))        self.consumedCountLabel= tk.Label(self.basicDataFrm, textvariable=self.variables.consumedCount, font=self.smallFont)        self.consumedCountLabel.grid(row=2, column=0, sticky=tk.W)        self.basicDataFrm.rowconfigure(3, weight=1)        self.variables.lckDelays.set('Lick Delays/Trial: {}'.format(0))        self.lckDelaysLabel= tk.Label(self.basicDataFrm, textvariable=self.variables.lckDelays, font=self.smallFont)        self.lckDelaysLabel.grid(row=3, column=0, sticky=tk.W)                self.basicDataFrm.rowconfigure(4, weight=1)        self.variables.rnDelays.set('Run Delays/Trial: {}'.format(0))        self.rnDelaysLabel= tk.Label(self.basicDataFrm, textvariable=self.variables.rnDelays, font=self.smallFont)        self.rnDelaysLabel.grid(row=4, column=0, sticky=tk.W)        self.closeActivityMonitorButton = tk.Button(self.frame, font=self.midFont, justify='center', text='Close Monitor Window',\            command=self.closeActivityMonitor)        self.closeActivityMonitorButton.grid(row=2,column=0,columnspan=1,sticky=tk.W)        self.updatePlotButton = tk.Button(self.frame, font=self.midFont, justify='center', text='Update Plotting',\            command=self.reDrawPlot)        self.updatePlotButton.grid(row=2,column=1,columnspan=1,sticky=tk.W)    def closeActivityMonitor(self):        self.stopActivityMonitor()        plt.close(self.mainPlot.fig)        self.master.destroy()        del taskGUI.activityWindow         del taskGUI.activity     def stopActivityMonitor(self):        try:            self.master.after_cancel(self.activityCallback)            self.stopPlot()        except:            pass    def startActivityMonitor(self):        if self.variables.inTaskFlag:            if taskVar.sesVarDict['sessionOn']:                # Ensure that telemetry exists before polling it                try:                    if not self.plotRunning:                        self.startPlot()                    self.currentInt=copy.copy(taskVar.curInt) # Data is running on another thread so mark this time and reference it for everything                    self.currentTime=copy.copy(taskVar.curTime)                    self.currentTrialTime=copy.copy(taskVar.curTrialTime)                    self.massStart=copy.copy(taskVar.initialMass)                    if self.currentInt>=99:                        #Arbitrarily use 100 samples to get current weight (load cell column 3)                        curWt = np.mean(np.double(taskVar.sesData[self.currentInt-99:self.currentInt+1,3])/100.0) #ind-99 equiv -100+1 (not inclusive), : ind+1 (current, thru indexing is not inclusive)                        self.massDtSample.append(curWt)                        if len(self.massDtSample)>13:                            #Manage ample for running average DT, at 200ms updates, roughly 2.5s average                            self.massDtSample=self.massDtSample[-13:]                        curWtDt=np.mean(self.massDtSample)                        self.variables.massCurrent.set('Load reading: {:.2f}g, {:.2f}N*e-3'.format(curWt,curWt*9.80665))                        self.variables.massDelta.set('Load Change: {:.2f}g, {:.2f}N*e-3'.format(curWtDt,curWtDt*9.80665))                    if taskVar.sesVarDict['taskType']=='detection' or taskVar.sesVarDict['taskType']=='calibrate':                        currentTrialLocal = copy.copy(taskVar.sesVarDict['trialNum'])                        self.trialTotal=copy.copy(taskVar.sesVarDict['totalTrials'])                        trialPhase = copy.copy(taskVar.pyState)                        # Update Monitor prompt text                        self.variables.trialState.set('Experiment Phase:{}, Trial {} of {}, Recording Time:{:.3f}, Trial Time:{:.3f}'.\                            format(self.translatePhase(trialPhase),currentTrialLocal,self.trialTotal,self.currentTime,self.currentTrialTime))                        if taskVar.sesVarDict['taskType']=='detection':                            try:                                consumedTotal=taskVar.trialData['consumed'].sum()                                self.variables.consumedCount.set('Rewards Taken: {}'.format(consumedTotal))                                ldlys=len(taskVar.noLickDelays)                                ldlysT=ldlys+taskVar.noLickDelaysCount                                rdlys=len(taskVar.noRunDelays)                                rdlysT=rdlys+taskVar.noRunDelaysCount                                self.variables.lckDelays.set('Lick Delays Trial: {}, Total:{}, Per Trial: {:.1f}'.format(ldlys,ldlysT,float(ldlysT)/(currentTrialLocal+1)))                                self.variables.rnDelays.set('Run Delays Trial: {}, Total:{}, Per Trial: {:.1f}'.format(rdlys,rdlysT,float(rdlysT)/(currentTrialLocal+1)))                            except:                                pass                        # Use the difference between currentTrialLocal and current trial to determine if it's a new trial then update current trial                        # Use indexing algorythm to pull trial siglas if new trial                            # trialSigalIndex = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial].index                            # trialIndexTuples =list(zip(np.full(trialSigalIndex.shape[0],taskVar.tTrial,dtype=np.uint32),trialSigalIndex))                        # each loop use the index and loop through it, look for tFired, if currentTime >= pop the index and print fire time, channel and duration                                           else:                        self.variables.trialState.set('Recording... Recording Time:{:.3f}'.format(self.currentTime))                except:                    pass            self.activityCallback = self.master.after(200,self.startActivityMonitor)    def translatePhase(self,stateInt):        if taskVar.sesVarDict['taskType']!='detection':            return taskVar.sesVarDict['taskType']        else:            if stateInt==1:                return "Behavior"            else:                return "Baseline"    def startPlot(self):        self.mainPlot.startSpinGraph()        self.plotRunning=True    def stopPlot(self):        self.mainPlot.stopGraph()        self.plotRunning=False    def reDrawPlot(self):        self.mainPlot.switchPlot()    def close_windows(self):        self.master.destroy()class calibratePiezoGUI:    def __init__(self, master, variables,varObj,mainGUI):        self.master = master        self.master.title("Calibrate Piezo")        self.variables = variables        self.varObj=varObj        self.mainGUI=mainGUI        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.top = self.master.winfo_toplevel()        self.top.grid()        self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)         self.frame.columnconfigure(0, weight=1)        self.frame.columnconfigure(1, weight=1)        self.frame.columnconfigure(2, weight=1)        self.frame.columnconfigure(3, weight=1)        self.frame.columnconfigure(4, weight=1)        self.frame.columnconfigure(5, weight=1)        self.top.rowconfigure(0, weight=1)         self.top.columnconfigure(0, weight=1)        self.variables.cal_sensorValuesList=[]        self.moveIncLabel = tk.Label(self.frame, text='Move step size [um]', \            justify='right', font=self.smallFont)        self.moveIncLabel.grid(row=0,column=0)        self.moveIncEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4, \            textvariable=self.variables.cal_moveIncSize)        self.moveIncEntry.grid(row=0,column=1, sticky=tk.W)        self.moveDistanceLabel = tk.Label(self.frame, text='Move Distance [um]: ', justify='right', font=self.smallFont)        self.moveDistanceLabel.grid(row=0,column=2)        self.moveDistanceEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_moveDistance)        self.moveDistanceEntry.grid(row=0,column=3, sticky=tk.W)        self.loadButton = tk.Button(self.frame, text='Load', font=self.midFont, justify='center', command=self.loadCalibrationParams)        self.loadButton.grid(row=0,column=4, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(1, weight=1)         self.samplesPerWaveLabel = tk.Label(self.frame, text='Pulses Per Waveform:\n(Per Position)', \            justify='right', font=self.smallFont)        self.samplesPerWaveLabel.grid(row=1,column=0)        self.samplesPerWaveEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_pulseCount)        self.samplesPerWaveEntry.grid(row=1,column=1, sticky=tk.W)                self.waveformLabel = tk.Label(self.frame, text='Wave Shape: \n(0=sqr, 2=AsymCos)', \            justify='right', font=self.smallFont)        self.waveformLabel.grid(row=1,column=2)        self.waveformEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_waveform)        self.waveformEntry.grid(row=1,column=3, sticky=tk.W)        self.saveButton = tk.Button(self.frame, text='Save', font=self.midFont, justify='center', command=self.saveCalibrationParameters)        self.saveButton.grid(row=1,column=4, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(2, weight=1)         self.amplitudeMinLabel = tk.Label(self.frame, text='Amplitude Min: ', justify='right', font=self.smallFont)        self.amplitudeMinLabel.grid(row=2,column=0)        self.amplitudeMinEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_amp_min)        self.amplitudeMinEntry.grid(row=2,column=1, sticky=tk.W)                self.amplitudeMaxLabel = tk.Label(self.frame, text='Max: ', justify='right', font=self.smallFont)        self.amplitudeMaxLabel.grid(row=2,column=2)        self.amplitudeMaxEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_amp_max)        self.amplitudeMaxEntry.grid(row=2,column=3, sticky=tk.W)        self.amplitudeStepsLabel = tk.Label(self.frame, text='Steps: ', justify='right', font=self.smallFont)        self.amplitudeStepsLabel.grid(row=2,column=4)        self.amplitudeStepsEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_amp_steps)        self.amplitudeStepsEntry.grid(row=2,column=5, sticky=tk.W)        self.frame.rowconfigure(3, weight=1)         self.pulseWidthMinLabel = tk.Label(self.frame, text='Pulse Width [s] Min: ', justify='right', font=self.smallFont)        self.pulseWidthMinLabel.grid(row=3,column=0)        self.pulseWidthMinEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_pulseDur_min)        self.pulseWidthMinEntry.grid(row=3,column=1, sticky=tk.W)                self.pulseWidthMaxLabel = tk.Label(self.frame, text='Max: ', justify='right', font=self.smallFont)        self.pulseWidthMaxLabel.grid(row=3,column=2)        self.pulseWidthMaxEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_pulseDur_max)        self.pulseWidthMaxEntry.grid(row=3,column=3, sticky=tk.W)        self.pulseWidthStepsLabel = tk.Label(self.frame, text='Steps: ', justify='right', font=self.smallFont)        self.pulseWidthStepsLabel.grid(row=3,column=4)        self.pulseWidthStepsEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_pulseDur_steps)        self.pulseWidthStepsEntry.grid(row=3,column=5, sticky=tk.W)        self.frame.rowconfigure(4, weight=1)         self.pulseUpWidthMinLabel = tk.Label(self.frame, text='Pulse Up Width [s] Min: ', justify='right', font=self.smallFont)        self.pulseUpWidthMinLabel.grid(row=4,column=0)        self.pulseUpWidthMinEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_pulseUpDur_min)        self.pulseUpWidthMinEntry.grid(row=4,column=1, sticky=tk.W)                self.pulseUpWidthMaxLabel = tk.Label(self.frame, text='Max: ', justify='right', font=self.smallFont)        self.pulseUpWidthMaxLabel.grid(row=4,column=2)        self.pulseUpWidthMaxEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_pulseUpDur_max)        self.pulseUpWidthMaxEntry.grid(row=4,column=3, sticky=tk.W)        self.pulseUpWidthStepsLabel = tk.Label(self.frame, text='Steps: ', justify='right', font=self.smallFont)        self.pulseUpWidthStepsLabel.grid(row=4,column=4)        self.pulseUpWidthStepsEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_pulseUpDur_steps)        self.pulseUpWidthStepsEntry.grid(row=4,column=5, sticky=tk.W)        self.frame.rowconfigure(5, weight=1)         self.interpulseWidthMinLabel = tk.Label(self.frame, text='Interpulse Width [s] Min: ', justify='right', font=self.smallFont)        self.interpulseWidthMinLabel.grid(row=5,column=0)        self.interpulseWidthMinEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_interPulseDur_min)        self.interpulseWidthMinEntry.grid(row=5,column=1, sticky=tk.W)                self.interpulseWidthMaxLabel = tk.Label(self.frame, text='Max: ', justify='right', font=self.smallFont)        self.interpulseWidthMaxLabel.grid(row=5,column=2)        self.interpulseWidthMaxEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_interPulseDur_max)        self.interpulseWidthMaxEntry.grid(row=5,column=3, sticky=tk.W)        self.interpulseWidthStepsLabel = tk.Label(self.frame, text='Steps: ', justify='right', font=self.smallFont)        self.interpulseWidthStepsLabel.grid(row=5,column=4)        self.interpulseWidthStepsEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_interPulseDur_steps)        self.interpulseWidthStepsEntry.grid(row=5,column=5, sticky=tk.W)        self.frame.rowconfigure(6, weight=1)        self.waveSampleCountLabel = tk.Label(self.frame, text='Train Count:\n(Per waveform/position) ', justify='right', font=self.smallFont)        self.waveSampleCountLabel.grid(row=6,column=0)        self.waveSampleCountEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_sampleCount)        self.waveSampleCountEntry.grid(row=6,column=1, sticky=tk.W)        self.baseTimeLabel = tk.Label(self.frame, text='Pre Pulse-Train:\nTime [s] ', justify='right', font=self.smallFont)        self.baseTimeLabel.grid(row=6,column=2)        self.baseTimeEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_baseline)        self.baseTimeEntry.grid(row=6,column=3, sticky=tk.W)                self.postTimeLabel = tk.Label(self.frame, text='Post Train:\nSettle Time [s] ', justify='right', font=self.smallFont)        self.postTimeLabel.grid(row=6,column=4)        self.postTimeEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_postTime)        self.postTimeEntry.grid(row=6,column=5, sticky=tk.W)                     self.frame.rowconfigure(7, weight=1)        self.calChanNumLabel = tk.Label(self.frame, text='Output Channel #: ', justify='right', font=self.smallFont)        self.calChanNumLabel.grid(row=7,column=0)        self.calChanNumEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_chanToUse)        self.calChanNumEntry.grid(row=7,column=1, sticky=tk.W)                        self.calibrateNameLabel = tk.Label(self.frame, text='File Name (optnl):', font=self.smallFont, justify='right')        self.calibrateNameEntry = tk.Entry(self.frame, width = 20, font = self.smallFont, justify='right',\            textvariable=self.variables.cal_calibrateName)        self.calibrateNameLabel.grid(row=7,column=2)        self.calibrateNameEntry.grid(row=7,column=3, columnspan=3, sticky=tk.W)        self.frame.rowconfigure(8, weight=1)         self.permLabel = tk.Label(self.frame, justify='right', font=self.smallFont, textvariable=self.variables.cal_permNum)        self.permLabel.grid(row=8,column=0, columnspan=3)                self.moveCountLabel = tk.Label(self.frame, justify='right', font=self.smallFont, textvariable=self.variables.cal_moveNum)        self.moveCountLabel.grid(row=8,column=3, columnspan=3)        self.frame.rowconfigure(9, weight=1)         self.moveTimeLabel = tk.Label(self.frame, justify='right', font=self.smallFont, textvariable=self.variables.cal_moveTime)        self.moveTimeLabel.grid(row=9,column=0, columnspan=3)                self.totalTimeLabel = tk.Label(self.frame, justify='right', font=self.smallFont, textvariable=self.variables.cal_totalTime)        self.totalTimeLabel.grid(row=9,column=3, columnspan=3)        self.frame.rowconfigure(10, weight=1)         self.calcButton = tk.Button(self.frame, font=self.midFont, justify='center', textvariable=self.variables.cal_calcButtonText, command=self.makeCalProtocol)        self.calcButton.grid(row=10,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)                self.findButton = tk.Button(self.frame, font=self.midFont, justify='center', textvariable=self.variables.cal_findButtonText, command=self.runFindStart)        self.findButton.grid(row=10,column=2, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.runButton = tk.Button(self.frame, font=self.midFont, justify='center', textvariable=self.variables.cal_runButtonText, state=tk.DISABLED, command=self.startCalibration)        self.runButton.grid(row=10,column=4, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)                self.frame.rowconfigure(11, weight=1)        self.moveLabel = tk.Label(self.frame, justify='right', font=self.midFont, textvariable=self.variables.cal_moveText)        self.moveLabel.grid(row=11,column=0, columnspan=3)        self.positionLabel = tk.Label(self.frame, justify='right', font=self.midFont, textvariable=self.variables.cal_positionText)        self.positionLabel.grid(row=11,column=3, columnspan=3)        self.frame.rowconfigure(12, weight=1)        self.openTestButton = tk.Button(self.frame, font=self.midFont, justify='center', text='Sensor Test Controls', command=self.openTestWindow)        self.openTestButton.grid(row=12,column=0, columnspan=6, sticky=tk.N+tk.S+tk.E+tk.W)                 self.toggleRunButton()    def close_windows(self):        if self.variables.calibrationActive==True:            self.startCalibration()        self.master.destroy()    def toggleRunButton(self):        if self.variables.calibrationActive==True:            self.variables.cal_runButtonText.set('End Test')            self.runButton['state'] = tk.NORMAL        else:            self.variables.cal_runButtonText.set('Run')            if self.variables.cal_trlsReady==True and self.variables.inTaskFlag==0 and self.varObj.sesVarDict['sessionOn']==0:                self.runButton['state'] = tk.NORMAL            else:                self.runButton['state'] = tk.DISABLED    def toggleCalTrialStats(self,resetFlds=0):        if resetFlds==0:            #            self.variables.cal_permNum.set('{} Permutations'.format(str(self.variables.permNumber)))            self.variables.cal_moveNum.set('{} Remaining Moves'.format(str(self.variables.movesRemaining-1)))            self.variables.cal_moveTime.set('Next move in '+\                time.strftime("%H Hours, %M Minutes, %S Seconds", time.gmtime(self.variables.secsToNextMove)))            self.variables.cal_totalTime.set('Time Remaining '+\                time.strftime("%H Hours, %M Minutes, %S Seconds", time.gmtime(self.variables.estTotalTimeRemaining)))            self.variables.cal_positionText.set('Current position: {}'.format(str(self.variables.curPosition+1)))        else:            #            self.variables.cal_permNum.set('... Permutations')            self.variables.cal_moveNum.set('... Total Moves')            self.variables.cal_moveTime.set('Time Till Move: ... [s]')            self.variables.cal_totalTime.set('Estimated Total Time: ... [s]')            self.variables.cal_positionText.set('Current position: ... um')            self.variables.cal_moveText.set('Make Protocol')    def calFieldsReset(self,resetList=[]):        for varName in resetList:            varType = str(type(eval('self.variables.{}'.format(varName))))            if varType == "<class 'tkinter.StringVar'>":                exec("self.variables.cal_{}.set('')".format(varName))            if varType == "<class 'tkinter.IntVar'>":                exec('self.variables.cal_{}.set(0)'.format(varName))            if varType == "<class 'tkinter.DoubleVar'>":                exec('self.variables.cal_{}.set([])'.format(varName))    def loadCalibrationParams(self):        # Open file path        # set self.varObj.tempBlockDict         # set make dicts         # set list and line count and other block fields        try:            tPth = fd.askopenfilename(title ="Select Calibration File", filetypes = [("Cal file", "*.json")])            filePath = Path(tPth)            with open(filePath) as json_file:                self.varObj.makeCalTrialsDict = json.load(json_file)            vList= [s for s in self.varObj.makeCalTrialsDict.keys() if s != 'varsToUse']            self.setFields(vList,'self.varObj.makeCalTrialsDict')            self.setFields(self.varObj.makeCalTrialsDict['varsToUse'],'self.varObj.makeCalTrialsDict',0)        except:            pass    def setFields(self, fieldsList =[], sourceDict='', mnMxStpsPrbs='n'):        if mnMxStpsPrbs=='n':            for varName in fieldsList:                valToSet=''                try:                    valToSet = eval("{}['{}']".format(sourceDict,varName))                    valToSet = self.valToString(valToSet)                    exec("self.variables.cal_{}.set(valToSet)".format(varName))                except:                    pass        else:            for varName in fieldsList:                valToSet=''                mmspCol = 0                for suffix in ['_min','_max','_steps']:                    #try:                    valToSet = eval("{}['{}'][{}][{}]".format(sourceDict,varName,mnMxStpsPrbs,mmspCol))                    valToSet = self.valToString(valToSet)                    exec("self.variables.cal_{}{}.set(valToSet)".format(varName,suffix))                    #except:                        #pass                    mmspCol+=1    def valToString(self,valToChange):        if (type(valToChange)==list) or (type(valToChange)==tuple):            if len(valToChange)>1:                codedString =''                strInd = 0                for x in range(len(valToChange)-1):                    codedString=codedString+str(valToChange[x]).strip('"').strip("'")+','                    strInd+=1                codedString=codedString+str(valToChange[strInd]).strip('"').strip("'")            elif len(valToChange)==0:                codedString=''            else:                codedString=str(valToChange[0]).strip('"').strip("'")        else:            codedString = str(valToChange).strip('"').strip("'")        return codedString    def saveCalibrationParameters(self):        tStamp=datetime.datetime.now().strftime("_%Y_%m_%d_%H%M%S")        nameNum=''        calName=''        if self.variables.cal_calibrateName.get()[:8]=='wavelist':            # If the default name is not changed            calName ='wavelist'            if len(self.variables.cal_calibrateName.get())>8:                try:                    nameNum = int(self.variables.cal_calibrateName.get()[9:])+1                    self.variables.cal_calibrateName.set(calName+'_'+str(nameNum))                except:                    pass            else:                nameNum = 1                self.variables.cal_calibrateName.set(calName+'_'+str(nameNum))        self.varObj.makeCalTrialsDict['calibrateName']=self.variables.cal_calibrateName.get()        saveName=self.variables.cal_calibrateName.get()+'_'+tStamp        saveDirectory= self.varObj.sesVarDict['dirPath'] / 'calibrationParams'         self.getCalFields()        vList= [s for s in self.varObj.makeCalTrialsDict.keys() if s != 'varsToUse' and s != 'offset']        self.setFields(vList,'self.varObj.makeCalTrialsDict')        self.setFields(self.varObj.makeCalTrialsDict['varsToUse'],'self.varObj.makeCalTrialsDict',0)        self.varObj.saveJSONDict(self.varObj.makeCalTrialsDict,saveDirectory,saveName)        self.varObj.calDesignFile=str(saveDirectory / saveName ) + '.json'        print('{} saved to {}'.format(self.variables.cal_calibrateName.get(),saveDirectory))    def getCalFields(self):        self.varObj.resetDict('makeCalTrialsDict')        for key in list(self.varObj.makeCalTrialsDict.keys()):            if (key != 'varsToUse') and (key!='calibrateName') and (key != 'offset') and\            (key not in self.varObj.makeCalTrialsDict['varsToUse']):                if len(eval('self.variables.cal_{}.get().strip()'.format(key)))>0:                    curParam=[]                    curParam=eval('self.variables.cal_{}.get().strip()'.format(key))                    curParam=curParam.strip('][')                    try:                        float(curParam)                        self.varObj.makeCalTrialsDict[key]=self.varObj.inferType(curParam)                    except:                        self.varObj.makeCalTrialsDict[key]=[]                        print('{} Requires a number, please edit'.format(key))                else:                    self.varObj.makeCalTrialsDict[key]=[]                    for getVar in self.varObj.makeCalTrialsDict['varsToUse']:            if getVar not in list(self.varObj.makeCalTrialsDict.keys()):                self.varObj.makeCalTrialsDict[getVar]=[]            varParams = [[],[],[],[]]            curParam = []            paramCount =0            for suffix in ['_min','_max','_steps']: # ,'_probs']: not used                try:                    curParam=[]                    curParam = eval('self.variables.cal_{}{}.get().strip()'.format(getVar,suffix))                    curParam=curParam.strip('][')                    if (suffix == '_steps') and len(curParam)>0:                        try:                            if (curParam[0] == ':') and (curParam[1] != ','):                                curParam =  curParam[0]+','+ curParam[1:]                            curParam = self.varObj.splitStepsVar(curParam)                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                    elif ((suffix == '_min') or (suffix == '_max')) and len(curParam)>0:                        try:                            curParam=self.varObj.inferType(curParam)                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                                           else:                        varParams[paramCount]=[]                except:                    varParams[paramCount]=[]                paramCount+=1            #This line accounts for 'probs'            varParams[paramCount]=','.split(',')                        self.varObj.makeCalTrialsDict[getVar]=[varParams]        self.varObj.makeCalTrialsDict['calibrateName']=self.variables.cal_calibrateName.get()    def makeCalProtocol(self):        self.getCalFields()        #Get user input for wave spects        #reqFields = ['moveIncSize','waveform','sampleCount','moveDistance','baseline','postTime','chanToUse','pulseCount']        #Error check that requred values are not missing        reqFields = [s for s in self.varObj.makeCalTrialsDict.keys() if s!='varsToUse' and s \        not in self.varObj.makeCalTrialsDict['varsToUse'] and s!='calibrateName']        for reqfld in reqFields:            if type(self.varObj.makeCalTrialsDict[reqfld])==list and len(self.varObj.makeCalTrialsDict[reqfld])==0:                print('Please enter a {} value'.format(reqfld))                return        #reqDists = ['amp','pulseDur','interPulseDur']        reqDists = self.varObj.makeCalTrialsDict['varsToUse'][:]        reqSuffs=['_min','_max']        if self.varObj.makeCalTrialsDict['waveform']==0:            reqDists.pop(reqDists.index('pulseUpDur'));        for reqfld in reqDists:            for subDex in range(2):                if type(self.varObj.makeCalTrialsDict[reqfld][0][subDex])== list and len(self.varObj.makeCalTrialsDict[reqfld][0][subDex])==0:                    print('Please enter a {} {} value').format(reqfld,reqSuffs[subDex][1:])                    return        if self.varObj.makeCalTrialsDict['moveDistance']<self.varObj.makeCalTrialsDict['moveIncSize']:            print('Please edit, move distance must not be less than move increment size')            return        # get entered fields and verify that all necessry parameters were entered        #save the file        self.saveCalibrationParameters()        #Get the number of different permutations and the number of sample positions - used to calculate reps in protocol        pCount,numMoves= self.calcPermutations()        if pCount == []:            print('Parameter is invalid, please edit')            return        else:            print('Generating {} unique waveforms, {} total reps position'.format(pCount,pCount*self.varObj.makeCalTrialsDict['sampleCount']))        # Generate the test protocol for trial engine         tempCalDict=self.varObj.makeCalTrialsDict.copy()        tempCalDict['varsToUse']=self.varObj.makeTrialsDict['varsToUse'][:]        # Add dist spec columns for engine here for convienence of coding        tempCalDict['pulseCount']=[[tempCalDict['pulseCount'], tempCalDict['pulseCount'], [], ["", ""]]]        tempCalDict['offset']=[[tempCalDict['baseline'], tempCalDict['baseline'], [], ["", ""]]]        for vtuKey in tempCalDict['varsToUse']:            if (vtuKey not in tempCalDict.keys()) or len(tempCalDict[vtuKey])==0:                tempCalDict[vtuKey]=[[[],[], [], []]]        for vtuKey in tempCalDict['varsToUse']:            if len(tempCalDict[vtuKey])>0 and type(tempCalDict[vtuKey][0][0])!=list and type(tempCalDict[vtuKey][0][1])!=list:                tempCalDict[vtuKey][0][2].append('_ramp')                # organize each sweep (unmoved move set) into trials,         # where each trial is one per permutation, with offset = baseline and one signal per sample# and one post time dummy signal in between        sweepTimeSecs = self.varObj.calParamsToPandasFrame(tempCalDict, pCount)        self.toggleRunButton()        self.variables.permNumber=pCount        self.variables.moveCount=numMoves        self.variables.movesRemaining=self.variables.moveCount        self.variables.sweepDuration=sweepTimeSecs        self.variables.secsToNextMove=self.variables.sweepDuration        self.variables.estimatedTotalTime=sweepTimeSecs* numMoves        self.variables.estTotalTimeRemaining=self.variables.estimatedTotalTime        self.variables.curPosition=0        self.toggleCalTrialStats()        swpTm = time.strftime("%H Hours, %M Minues, %S Seconds", time.gmtime(sweepTimeSecs))        eTT = time.strftime("%H Hours, %M Minues, %S Seconds", time.gmtime(self.variables.estimatedTotalTime))        print('Trials Ready, {} per sweep, {} estimated total time'.format(swpTm,eTT))    def calcPermutations(self):        totalPermutations = []        totalMoves=  math.ceil(float(self.varObj.makeCalTrialsDict['moveDistance'])/self.varObj.makeCalTrialsDict['moveIncSize'])+1        #Added +1 to this to account for a '0' sweep        allParamCounts=[]        reqPerms = self.varObj.makeCalTrialsDict['varsToUse'][:]        if self.varObj.makeCalTrialsDict['waveform']==0:            reqPerms.pop(reqPerms.index('pulseUpDur'));        for rp in reqPerms:            minVal = self.varObj.makeCalTrialsDict[rp][0][0]            maxVal = self.varObj.makeCalTrialsDict[rp][0][1]                        if type(minVal)==list or minVal=='' or type(maxVal)==list or maxVal=='':                return totalPermutations, totalMoves            stpsMM=[]            if minVal == maxVal:                stpsMM=1            else:                stpsMM=2            stpsLen=0            if type(self.varObj.makeCalTrialsDict[rp][0][2])==list and len(self.varObj.makeCalTrialsDict[rp][0][2])>0:                stpsVal= self.varObj.makeCalTrialsDict[rp][0][2]                if stpsVal[0]==':' and type(stpsVal[1])==int:                    stpsLen=stpsVal[1]                else:                    for idex in range(len(stpsVal)):                        if type(stpsVal[idex])==int or type(stpsVal[idex])==float:                            stpsLen+=1            elif type(self.varObj.makeCalTrialsDict[rp][0][2])==int or type(self.varObj.makeCalTrialsDict[rp][0][2])==float:                stpsLen=1            allParamCounts.append(stpsMM+stpsLen)        totalPermutations=math.prod(allParamCounts)        return totalPermutations, totalMoves    def toggleStartButton(self):        if self.variables.calibrationActive==True:            self.variables.cal_findButtonText.set('Proceed')            if self.varObj.sesVarDict['sessionOn']==1:                self.findButton['state'] = tk.DISABLED            else:                self.findButton['state'] = tk.NORMAL        elif self.varObj.sesVarDict['sessionOn']==1 and self.varObj.sesVarDict['taskType']=='monitorOnly':            self.variables.cal_findButtonText.set('Stop')        else:            self.variables.cal_findButtonText.set('Find Start')    def runFindStart(self):        self.toggleStartButton()         if self.variables.calibrationActive==True:            if self.varObj.sesVarDict['sessionOn']==1:                return # this should do nothing while calibration is running            else:                self.varObj.resetDict('experimentPandas')                self.varObj.experimentPandas=copy.deepcopy(self.variables.calPandaDict)                self.mainGUI.getMainFields()                self.mainGUI.saveDefaultDict()                self.mainGUI.openActivityWindow()                self.mainGUI.activity.mainPlot.calOverride=True                self.mainGUI.activity.reDrawPlot()                threading.Thread(target=self.runCalThread).start()                #self.runCalThread()                              self.toggleStartButton()                 self.toggleRunButton()                self.variables.cal_moveText.set('Running')        elif self.variables.inTaskFlag==0 and self.varObj.sesVarDict['sessionOn']==0:            self.mainGUI.getMainFields()            self.mainGUI.saveDefaultDict()            self.variables.inTaskFlag=1              self.variables.cal_findButtonText.set('Stop')            self.variables.plotType.set(int(6+self.varObj.cal_Input))            self.variables.plotMinMax.set('0,4096')            self.mainGUI.openActivityWindow()            #self.mainGUI.activity.mainPlot.calOverride=True. #No need to cal override for Monitor only task bc it uses the normal data struct,                # instead all that is needed is to set the correct input channel and a reasonable plot range (as above)            self.varObj.sesVarDict['sessionOn']=1 # This is only to deal with the Button behavior in the sensor window            threading.Thread(target=self.findStartThread).start()            self.toggleRunButton()            self.variables.cal_moveText.set('Find Start Location')        elif self.varObj.sesVarDict['sessionOn']==1 and self.varObj.sesVarDict['taskType']=='monitorOnly':            self.varObj.sesVarDict['sessionOn']=0            self.variables.inTaskFlag=0            #self.calOverrideOff()            self.toggleStartButton()            self.toggleRunButton()            if self.variables.cal_trlsReady==True:                self.variables.cal_moveText.set('Run if ready')            else:                self.variables.cal_moveText.set('Make Protocol')    def calOverrideOff(self):        try:            if hasattr(self.mainGUI,'activity') and ('normal'== self.mainGUI.activityWindow.state()):                self.mainGUI.activity.mainPlot.calOverride=False        except:            pass    def startCalibration(self):        self.toggleRunButton()        if self.variables.calibrationActive==False:            if  self.variables.cal_trlsReady==True:                if self.varObj.sesVarDict['sessionOn']==0 and self.variables.inTaskFlag==0:                    self.variables.calibrationActive=True                    self.varObj.calDataFiles=pd.Series(np.empty(self.variables.moveCount, dtype='object'),dtype='object',name='FilePaths')                     self.variables.calPandaDict=copy.deepcopy(self.varObj.experimentPandasBuffer)                    self.varObj.resetDict('experimentPandasBuffer')                    self.variables.cal_trlsReady=False                                        self.variables.inTaskFlag=1                    self.toggleStartButton()                    self.variables.cal_moveText.set('If Ready Click Proceed')                    self.toggleRunButton()            else:                self.toggleRunButton()                print('Parameters missing, please "Make"')        else:            self.variables.cal_trlsReady=False            self.variables.calibrationActive=False            self.variables.inTaskFlag=0            if self.varObj.sesVarDict['sessionOn']==1:                self.varObj.sesVarDict['sessionOn']=0            else:                self.closeCalProtocol()            #self.calOverrideOff()            self.toggleStartButton()            self.variables.cal_moveText.set('Make Protocol')            self.toggleRunButton()    def closeCalProtocol(self):        self.toggleStartButton()        self.toggleRunButton()        if self.variables.curPosition>=self.variables.moveCount-1 or self.variables.calibrationActive==False:            #Test end conditions, either protcol complete, or manually killed and cleanup needed            #Insure that session was killed (should have been)            if self.varObj.sesVarDict['sessionOn']==1:                self.varObj.sesVarDict['sessionOn']=0            self.variables.calibrationActive=False            self.calOverrideOff()            self.variables.inTaskFlag=0            #self.mainGUI.activity.mainPlot.calOverride=False            self.variables.cal_trlsReady=False            self.toggleCalTrialStats(1) # Reset window text defaults            self.toggleStartButton()            self.toggleRunButton()            self.variables.calPandaDict={} # This was saved and do not want errors             self.varObj.resetDict('experimentPandas') # Do not want accidental run in behavior task            tStamp=datetime.datetime.now().strftime("_%Y_%m_%d_%H%M%S")  # Save data file names            self.varObj.savePanda(self.varObj.calDataFiles,self.varObj.sesVarDict['dirPath'] / 'calibrationResults',self.variables.cal_calibrateName.get()+'_DataFiles'+tStamp)            self.variables.cal_moveText.set('Make Protocol')            self.varObj.calDataFiles=[]                     #        else:            self.variables.curPosition+=1            self.variables.movesRemaining=self.variables.moveCount-self.variables.curPosition            self.variables.estTotalTimeRemaining=self.variables.estimatedTotalTime-(self.variables.sweepDuration*self.variables.curPosition)            self.variables.secsToNextMove=self.variables.sweepDuration            self.toggleCalTrialStats()            self.variables.cal_moveText.set('If Ready Click Proceed')            def findStartThread(self):        runMonitorOnly()    def runCalThread(self):        runCalibrateRecording()    def openTestWindow(self):        #        self.testPiezoWindow = tk.Toplevel(self.master)        self.testPiezo = testPiezoGUI(self.testPiezoWindow,self.variables,self.varObj,self)class detectionTaskGUI:    def populateDetectionFields(self):        for key in self.variables.detectionVariablesDict.keys():            for fName in self.variables.detectionVariablesDict[key]:                try:                    exec("self.variables.{}.set(self.varObj.sesVarDict['{}'])".format(fName,fName))                except:                    pass    def __init__(self, master, variables,varObj,mainGUI):        self.master = master        self.master.title("Detection Task Setup")        self.variables = variables        self.mainGUI=mainGUI        self.varObj=varObj        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.top = self.master.winfo_toplevel()        self.top.grid()        self.top.rowconfigure(0, weight=1)         self.top.columnconfigure(0, weight=1)                self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)         self.frame.columnconfigure(0, weight=1)        self.frame.columnconfigure(1, weight=1)        self.frame.columnconfigure(2, weight=1)        self.frame.columnconfigure(3, weight=1)                self.taskParamsFrame = tk.LabelFrame(self.frame, text = 'Enter Task Parameters', labelanchor='nw')        self.taskParamsFrame.grid(row=0, column=0, columnspan=4, padx = 3, pady = 3, sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(0,weight=1)        self.taskParamsFrame.columnconfigure(0,weight=1)        self.taskParamsFrame.columnconfigure(1,weight=1)        self.taskParamsFrame.columnconfigure(2,weight=1)        self.taskParamsFrame.columnconfigure(3,weight=1)        self.noLickTimeLabel = tk.Label(self.taskParamsFrame, text='No Lick Time [s]: ', font=self.smallFont)        self.noLickTimeLabel.grid(row=0,column=0)        self.noLickTimeEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\         textvariable=self.variables.noLickTime)        self.noLickTimeEntry.grid(row=0,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.noRunTimeLabel = tk.Label(self.taskParamsFrame, text='No Run Time [s]: ', font=self.smallFont)        self.noRunTimeLabel.grid(row=0,column=2)        self.noRunTimeEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.noRunTime)        self.noRunTimeEntry.grid(row=0,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(1,weight=1)                self.startCueChannelLabel = tk.Label(self.taskParamsFrame, text='Start Cue Ch# : ', font=self.smallFont)        self.startCueChannelLabel.grid(row=1,column=0)        self.startCueChannelEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.startCueChannel)        self.startCueChannelEntry.grid(row=1,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.startCueDurationLabel = tk.Label(self.taskParamsFrame, text='Start Cue Duration [s]: ', font=self.smallFont)        self.startCueDurationLabel.grid(row=1,column=2)        self.startCueDurationEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.startCueDur)        self.startCueDurationEntry.grid(row=1,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(2,weight=1)        self.endCueChannelLabel = tk.Label(self.taskParamsFrame, text='End Cue Ch# : ', font=self.smallFont)        self.endCueChannelLabel.grid(row=2,column=0)        self.endCueChannelEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.endCueChannel)        self.endCueChannelEntry.grid(row=2,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.endCueDurationLabel = tk.Label(self.taskParamsFrame, text='End Cue Duration [s]: ', font=self.smallFont)        self.endCueDurationLabel.grid(row=2,column=2)        self.endCueDurationEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.endCueDur)        self.endCueDurationEntry.grid(row=2,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(3,weight=1)                self.rewardChannelLabel = tk.Label(self.taskParamsFrame, text='Reward Ch# : ', font=self.smallFont)        self.rewardChannelLabel.grid(row=3,column=0)        self.rewardChannelEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.rewardChannel)        self.rewardChannelEntry.grid(row=3,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.rewardDurationLabel = tk.Label(self.taskParamsFrame, text='Reward Duration [s]: ', font=self.smallFont)        self.rewardDurationLabel.grid(row=3,column=2)        self.rewardDurationEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.rewardDur)        self.rewardDurationEntry.grid(row=3,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(4,weight=1)                self.widthdrawChannelLabel = tk.Label(self.taskParamsFrame, text='Widthdraw Ch# : ', font=self.smallFont)        self.widthdrawChannelLabel.grid(row=4,column=0)        self.widthdrawChannelEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.widthdrawChannel)        self.widthdrawChannelEntry.grid(row=4,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.widthdrawDurationLabel = tk.Label(self.taskParamsFrame, text='Widthdraw Duration [s]: ', font=self.smallFont)        self.widthdrawDurationLabel.grid(row=4,column=2)        self.widthdrawDurationEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.widthdrawDur)        self.widthdrawDurationEntry.grid(row=4,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(5,weight=1)        self.responseWindowMinLabel = tk.Label(self.taskParamsFrame, text='Response Win Cue+n[s] Min: ', font=self.smallFont)        self.responseWindowMinLabel.grid(row=5,column=0)        self.responseWindowMinEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.responseWindowMin)        self.responseWindowMinEntry.grid(row=5,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.responseWindowMaxLabel = tk.Label(self.taskParamsFrame, text='RW Cue+n[s] Max: ', font=self.smallFont)        self.responseWindowMaxLabel.grid(row=5,column=2)        self.responseWindowMaxEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.responseWindowMax)        self.responseWindowMaxEntry.grid(row=5,column=3,sticky=tk.N+tk.S+tk.E+tk.W)                self.taskParamsFrame.rowconfigure(6,weight=1)                self.rewardWindowLabel = tk.Label(self.taskParamsFrame, text='Reward Window [s] : ', font=self.smallFont)        self.rewardWindowLabel.grid(row=6,column=0)        self.rewardWindowEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.rewardWindow)        self.rewardWindowEntry.grid(row=6,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.timeOutDurationLabel = tk.Label(self.taskParamsFrame, text='Time Out Duration [s]: ', font=self.smallFont)        self.timeOutDurationLabel.grid(row=6,column=2)        self.timeOutDurationEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.timeoutDur)        self.timeOutDurationEntry.grid(row=6,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(7,weight=1)                self.timeOutCueChannelLabel = tk.Label(self.taskParamsFrame, text='Time Out Cue Ch#: ', font=self.smallFont)        self.timeOutCueChannelLabel.grid(row=7,column=0)        self.timeOutCueChannelEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.timeoutCueChannel)        self.timeOutCueChannelEntry.grid(row=7,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.timeOutCueDurationLabel = tk.Label(self.taskParamsFrame, text='Time Out Cue Duration [s]: ', font=self.smallFont)        self.timeOutCueDurationLabel.grid(row=7,column=2)        self.timeOutCueDurationEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.timeoutCueDur)        self.timeOutCueDurationEntry.grid(row=7,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(8,weight=1)        self.lickLatchLabel = tk.Label(self.taskParamsFrame, text='Lick Latch [s]: ', font=self.smallFont)        self.lickLatchLabel.grid(row=8,column=0)        self.lickLatchEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.lickLatch)        self.lickLatchEntry.grid(row=8,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.minStimLabel = tk.Label(self.taskParamsFrame, text='Min Stim-to-Rwd Period [s]: ', font=self.smallFont)        self.minStimLabel.grid(row=8,column=2)        self.minStimEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.minStim)        self.minStimEntry.grid(row=8,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(9,weight=1)        self.rwdDelayLabel = tk.Label(self.taskParamsFrame, text='Resp-to-Rwd Delay [s]: ', font=self.smallFont)        self.rwdDelayLabel.grid(row=9,column=0)        self.rwdDelayEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.rwdDelay)        self.rwdDelayEntry.grid(row=9,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.respToCueDelayLabel = tk.Label(self.taskParamsFrame, text='Resp-to-Rsp Cue Delay [s]: ', font=self.smallFont)        self.respToCueDelayLabel.grid(row=9,column=2)        self.respToCueDelayEntry = tk.Entry(self.taskParamsFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.respToCueDelay)        self.respToCueDelayEntry.grid(row=9,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(10,weight=1)        self.respCueFrame = tk.LabelFrame(self.taskParamsFrame, text = 'Rsp Cues', labelanchor='nw')        self.respCueFrame.grid(row=10, column=0, columnspan=4, padx = 3, pady = 3, sticky=tk.N+tk.S+tk.E+tk.W)        self.respCueFrame.rowconfigure(0,weight=1)        self.respCueFrame.columnconfigure(0,weight=1)        self.respCueFrame.columnconfigure(1,weight=1)        self.respCueFrame.columnconfigure(2,weight=1)        self.respCueFrame.columnconfigure(3,weight=1)        self.hitCueChannelLabel = tk.Label(self.respCueFrame, text='Hit Cue Ch#: ', font=self.smallFont)        self.hitCueChannelLabel.grid(row=0,column=0)        self.hitCueChannelEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.hitCueChannel)        self.hitCueChannelEntry.grid(row=0,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.hitCueDurationLabel = tk.Label(self.respCueFrame, text='Hit Cue Duration [s]: ', font=self.smallFont)        self.hitCueDurationLabel.grid(row=0,column=2)        self.hitCueDurationEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.hitCueDur)        self.hitCueDurationEntry.grid(row=0,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.respCueFrame.rowconfigure(1,weight=1)        self.missCueChannelLabel = tk.Label(self.respCueFrame, text='Miss Cue Ch#: ', font=self.smallFont)        self.missCueChannelLabel.grid(row=1,column=0)        self.missCueChannelEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.missCueChannel)        self.missCueChannelEntry.grid(row=1,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.missCueDurationLabel = tk.Label(self.respCueFrame, text='Miss Cue Duration [s]: ', font=self.smallFont)        self.missCueDurationLabel.grid(row=1,column=2)        self.missCueDurationEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.missCueDur)        self.missCueDurationEntry.grid(row=1,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.respCueFrame.rowconfigure(2,weight=1)        self.crCueChannelLabel = tk.Label(self.respCueFrame, text='CR Cue Ch#: ', font=self.smallFont)        self.crCueChannelLabel.grid(row=2,column=0)        self.crCueChannelEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.crCueChannel)        self.crCueChannelEntry.grid(row=2,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.crCueDurationLabel = tk.Label(self.respCueFrame, text='CR Cue Duration [s]: ', font=self.smallFont)        self.crCueDurationLabel.grid(row=2,column=2)        self.crCueDurationEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.crCueDur)        self.crCueDurationEntry.grid(row=2,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.respCueFrame.rowconfigure(3,weight=1)        self.faCueChannelLabel = tk.Label(self.respCueFrame, text='FA Cue Ch#: ', font=self.smallFont)        self.faCueChannelLabel.grid(row=3,column=0)        self.faCueChannelEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.faCueChannel)        self.faCueChannelEntry.grid(row=3,column=1,sticky=tk.N+tk.S+tk.E+tk.W)        self.faCueDurationLabel = tk.Label(self.respCueFrame, text='FA Cue Duration [s]: ', font=self.smallFont)        self.faCueDurationLabel.grid(row=3,column=2)        self.faCueDurationEntry = tk.Entry(self.respCueFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.faCueDur)        self.faCueDurationEntry.grid(row=3,column=3,sticky=tk.N+tk.S+tk.E+tk.W)        self.taskParamsFrame.rowconfigure(11,weight=1)                self.noLickRuleCheckButton = tk.Checkbutton(self.taskParamsFrame, text='Enforce Pre-Trial No-Lick', font=self.smallFont,\            variable=self.variables.enforceNoLick, onvalue='1', offvalue='0')        self.noLickRuleCheckButton.grid(row=11,column=0)        self.noRunRuleCheckButton = tk.Checkbutton(self.taskParamsFrame, text='Enforce Pre-Trial No-Run', font=self.smallFont,\            variable=self.variables.enforceNoRun, onvalue='1', offvalue='0')        self.noRunRuleCheckButton.grid(row=11,column=2)        self.taskParamsFrame.rowconfigure(12,weight=1)                self.rewardHitButton = tk.Checkbutton(self.taskParamsFrame, text='Reward Hit', font=self.smallFont,\            variable=self.variables.rewardHit, onvalue='1', offvalue='0')        self.rewardHitButton.grid(row=12,column=0)        self.rewardMissButton = tk.Checkbutton(self.taskParamsFrame, text='Reward Miss', font=self.smallFont,\            variable=self.variables.rewardMiss, onvalue='1', offvalue='0')        self.rewardMissButton.grid(row=12,column=1)        self.rewardCrButton = tk.Checkbutton(self.taskParamsFrame, text='Reward CR', font=self.smallFont,\            variable=self.variables.rewardCr, onvalue='1', offvalue='0')        self.rewardCrButton.grid(row=12,column=2)        self.rewardFaButton = tk.Checkbutton(self.taskParamsFrame, text='Reward FA', font=self.smallFont,\            variable=self.variables.rewardFa, onvalue='1', offvalue='0')        self.rewardFaButton.grid(row=12,column=3)        self.taskParamsFrame.rowconfigure(13,weight=1)                self.toHitButton = tk.Checkbutton(self.taskParamsFrame, text='TO on Hit', font=self.smallFont,\            variable=self.variables.timeoutHit, onvalue='1', offvalue='0')        self.toHitButton.grid(row=13,column=0)        self.toMissButton = tk.Checkbutton(self.taskParamsFrame, text='TO on Miss', font=self.smallFont,\            variable=self.variables.timeoutMiss, onvalue='1', offvalue='0')        self.toMissButton.grid(row=13,column=1)        self.toCrButton = tk.Checkbutton(self.taskParamsFrame, text='TO on CR', font=self.smallFont,\            variable=self.variables.timeoutCr, onvalue='1', offvalue='0')        self.toCrButton.grid(row=13,column=2)        self.toFaButton = tk.Checkbutton(self.taskParamsFrame, text='TO on FA', font=self.smallFont,\            variable=self.variables.timeoutFa, onvalue='1', offvalue='0')        self.toFaButton.grid(row=13,column=3)                             self.frame.rowconfigure(1, weight=1)        self.plotSelectFrame = tk.LabelFrame(self.frame, text = 'Open Plots', labelanchor='nw')        self.plotSelectFrame.grid(row=1, column=0, columnspan=4, padx = 3, pady = 3, sticky=tk.N+tk.S+tk.E+tk.W)        self.plotSelectFrame.rowconfigure(0,weight=1)        self.plotSelectFrame.columnconfigure(0,weight=1)        self.plotSelectFrame.columnconfigure(1,weight=1)        self.lickPlotCheckButton = tk.Checkbutton(self.plotSelectFrame, text='Lick Raster', font=self.smallFont,\            variable=self.variables.plotLicks, onvalue='1', offvalue='0')        self.lickPlotCheckButton.grid(row=0,column=0, sticky=tk.W)        self.performancePlotCheckButton = tk.Checkbutton(self.plotSelectFrame, text='Performance', font=self.smallFont,\            variable=self.variables.plotPerformance, onvalue='1', offvalue='0')        self.performancePlotCheckButton.grid(row=0,column=1, sticky=tk.W)        self.frame.rowconfigure(2, weight=1)        # self.scaleCheckButton = tk.Button(self.frame, text='Check Weight', font=self.midFont, justify='center')        # self.scaleCheckButton.grid(row=2,column=0, sticky=tk.N+tk.S+tk.E+tk.W)        # self.weightLabel = tk.Label(self.frame, font=self.smallFont, textvariable=self.variables.weight)        # self.weightLabel.grid(row=2,column=1)        # self.weightChangeLabel = tk.Label(self.frame, font=self.smallFont, textvariable=self.variables.weightChange)        # self.weightChangeLabel.grid(row=2,column=2)        self.taskNameFrame = tk.LabelFrame(self.frame, text = 'Name', labelanchor='nw')        self.taskNameFrame.grid(row=2, column=0, columnspan=3, padx = 2, pady = 2, sticky=tk.N+tk.S+tk.E+tk.W)        self.taskNameEntry = tk.Entry(self.taskNameFrame, font=self.smallFont, justify='right',\            textvariable=self.variables.taskName)        self.taskNameEntry.grid(row=0,column=0,sticky=tk.N+tk.S+tk.E+tk.W)                self.frame.rowconfigure(3, weight=1)        self.saveButton = tk.Button(self.frame, text='Save', font=self.midFont, justify='center', command=self.saveTask)        self.saveButton.grid(row=3,column=0, sticky=tk.N+tk.S+tk.E+tk.W)        self.loadButton = tk.Button(self.frame, text='Load', font=self.midFont, justify='center', command=self.loadTask)        self.loadButton.grid(row=3,column=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.updateButton = tk.Button(self.frame, text='Update', font=self.midFont, justify='center', command=self.updateVarsFromDetectionGUI)        self.updateButton.grid(row=3,column=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.updateButton['state']=tk.DISABLED                self.runTaskButton = tk.Button(self.frame, font=self.midFont, justify='center', textvariable=self.variables.det_buttonText,\            command=self.startDetectionTask)        self.runTaskButton.grid(row=3,column=3, sticky=tk.N+tk.S+tk.E+tk.W)        if len(self.varObj.experimentPandas['trialParameters'])==0:            self.variables.det_buttonText.set('Create Trials')        # elif self.variables.tareFlag == 0:        #     self.variables.det_buttonText.set('Please Tare')        elif self.variables.inTaskFlag==1:            self.variables.det_buttonText.set('End Session')        else:            self.variables.det_buttonText.set('Run Task')        self.populateDetectionFields()        self.variables.taskName.set('Add Name')    def startDetectionTask(self):        if len(self.varObj.experimentPandas['trialParameters'])==0:            self.variables.det_buttonText.set('Create Trials')            print('Create Trials')            self.mainGUI.openStimDesign()        elif self.variables.inTaskFlag==1:            self.varObj.sesVarDict['sessionOn']=0            self.variables.inTaskFlag=0            self.variables.det_buttonText.set('Create Trials')        elif self.variables.tareFlag == 0:            #self.variables.det_buttonText.set('Please Tare')            print('Please Tare')        else:            #self.getDetectionFields()            if self.variables.lastSubject!=self.variables.subjID.get():                self.variables.tareFlag=0                self.variables.lastSubject=self.variables.subjID.get()                print('Please Tare Scale')            else:                self.varObj.experimentDesignFiles['taskFile']=self.saveTask(1)                #self.mainGUI.getMainFields()                #self.mainGUI.saveDefaultDict()                            self.variables.inTaskFlag=1                self.varObj.sesVarDict['taskType']='detection'                self.variables.det_buttonText.set('End Session')                self.mainGUI.openActivityWindow()                                threading.Thread(target=self.runDetectionThread).start()    def updateVarsFromDetectionGUI(self):        self.getDetectionFields()        #estimateStimWaitTime()        #print('Here we update the task vars and the dict and from the gui')    def getDetectionFields(self,rtrnDict=False):        tempSaveDict={}        for key in self.variables.detectionVariablesDict['floatFields']:            tempVal=eval('self.variables.{}.get()'.format(key))            if len(tempVal)>0:                try:                    self.varObj.sesVarDict[key]=float(tempVal)                    tempSaveDict[key]=float(tempVal)                    #print('{} set to {}'.format(key,tempVal))                except:                    self.varObj.sesVarDict[key]=[]                    tempSaveDict[key]=[]                    #print('{} set to empty'.format(key))            else:                self.varObj.sesVarDict[key]=[]                tempSaveDict[key]=[]                #print('{} set to empty'.format(key))        for key in self.variables.detectionVariablesDict['intFields']:            tempVal=eval('self.variables.{}.get()'.format(key))            if len(tempVal)>0:                try:                    self.varObj.sesVarDict[key]=int(tempVal)                    tempSaveDict[key]=int(tempVal)                    #print('{} set to {}'.format(key,tempVal))                except:                    self.varObj.sesVarDict[key]=[]                    tempSaveDict[key]=[]                    #print('{} set to empty'.format(key))            else:                self.varObj.sesVarDict[key]=[]                tempSaveDict[key]=[]                #print('{} set to empty'.format(key))        if rtrnDict:            return tempSaveDict    def saveTask(self,rtrn=0):        tStamp=datetime.datetime.now().strftime("_%Y_%m_%d_%H%M%S")        if self.variables.taskName.get()=='Add Name':            self.variables.taskName.set(self.variables.subjID.get())            taskSaveName=self.variables.taskName.get()        else:            taskSaveName=self.variables.taskName.get()        self.mainGUI.getMainFields()        self.mainGUI.saveDefaultDict()          saveName=taskSaveName+tStamp        saveDirectory= self.varObj.sesVarDict['dirPath'] / 'taskSettings'        tempTaskParams= self.getDetectionFields(True)        self.varObj.saveJSONDict(tempTaskParams,saveDirectory,saveName)        print('{} saved to {}'.format(taskSaveName,saveDirectory))        if rtrn == 1:            return str(saveDirectory / saveName)+'.json'    def loadTask(self):        try:            tPth = fd.askopenfilename(title ="Select Task Setting File", filetypes = [("Task Settings", "*.json")])            filePath = Path(tPth)            with open(filePath) as json_file:                tempTaskParams = json.load(json_file)                json_file.close()            for key in self.variables.detectionVariablesDict.keys():                for fName in self.variables.detectionVariablesDict[key]:                    try:                        if (not type(tempTaskParams[fName])==float) and (not type(tempTaskParams[fName])==int) and (len(tempTaskParams[fName])<1):                            exec("self.variables.{}.set('')".format(fName))                        else:                            exec("self.variables.{}.set(str(tempTaskParams['{}']))".format(fName,fName))                    except:                        pass            self.getDetectionFields()                 except:            pass    def close_windows(self):        self.master.destroy()    def runDetectionThread(self):        runDetectionTask()class teensyComGUI:    def defaultCom(self):        self.variables.comPath.set(self.varObj.sesVarDict['comPath'])        self.variables.sampRate.set(self.varObj.sesVarDict['sampRate'])    def __init__(self, master, variables,varObj,serObj,mainGUI):        self.master = master        self.variables=variables        self.varObj=varObj        self.serObj=serObj        self.mainGUI=mainGUI        self.defaultCom()        self.master.title("Interact With Teensy")        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.top = self.master.winfo_toplevel()        self.top.grid()        self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)         self.frame.columnconfigure(0, weight=1)        self.frame.columnconfigure(1, weight=1)        self.top.rowconfigure(0, weight=1)         self.top.columnconfigure(0, weight=1)         self.comLabel = tk.Label(self.frame, text='Com Port: ', font=self.midFont)        self.comLabel.grid(row=0,column=0)        self.comEntry=tk.Entry(self.frame, font=self.smallFont, justify='right',\            textvariable=self.variables.comPath)        self.comEntry.grid(row=0, column=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(1, weight=1)         self.triggerButton=tk.Button(self.frame, text='Send Trigger', font=self.midFont, command=self.sendTrigger)        self.triggerButton.grid(row=1, column=0, sticky=tk.N+tk.S+tk.E+tk.W)        self.commandButton=tk.Button(self.frame, text='Send Command', font=self.midFont, command=self.sendCommand)        self.commandButton.grid(row=1, column=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(2, weight=1)         self.commandEntry=tk.Entry(self.frame,font=self.smallFont,justify='right',\            textvariable=self.variables.tsy_command)        self.commandEntry.grid(row=2, column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(3, weight=1)        self.sampleRateLabel = tk.Label(self.frame, text='Sample Rate (Hz): ', font=self.midFont)        self.sampleRateLabel.grid(row=3,column=0)        self.sampleRateEntry=tk.Entry(self.frame, font=self.smallFont, justify='right',\            textvariable=self.variables.sampRate)        self.sampleRateEntry.grid(row=3, column=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(4, weight=1)        self.giveRewardButton=tk.Button(self.frame, text='Give Reward', font=self.midFont, command=self.giveReward)        self.giveRewardButton.grid(row=4, column=0, columnspan=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.giveWidthdrawButton=tk.Button(self.frame, text='Give Widthdraw', font=self.midFont, command=self.giveWidthdraw)        self.giveWidthdrawButton.grid(row=4, column=1, columnspan=1, sticky=tk.N+tk.S+tk.E+tk.W)                self.frame.rowconfigure(5, weight=1)        self.updateAndCloseButton=tk.Button(self.frame, text='Update and Close', font=self.midFont, command=self.updateDictAndClose)        self.updateAndCloseButton.grid(row=5, column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)            def updateDictAndClose(self):        self.varObj.sesVarDict['comPath']=self.variables.comPath.get()        self.varObj.sesVarDict['sampRate']=int(self.variables.sampRate.get())        self.mainGUI.saveDefaultDict()        self.master.destroy()    def close_windows(self):        self.master.destroy()            def sendTrigger(self):        tmpDt=1.0/self.varObj.sesVarDict['sampRate']        if self.variables.inTaskFlag==0:            if (not hasattr(self,'sendTriggerFlag')) or (self.sendTriggerFlag ==0):                try:                    tempComPath=self.variables.comPath.get()                    if len(tempComPath)>0:                        self.varObj.sesVarDict['comPath']=tempComPath                    cmPath=self.varObj.sesVarDict['comPath']                    baudRt= self.varObj.sesVarDict['baudRate_teensy']                    self.serObj.teensy=self.serObj.connectComObj(cmPath,baudRt)                    self.serObj.flushBuffer(self.serObj.teensy)                    self.serObj.teensy.write('a1>'.encode('utf-8'))                    self.sendTriggerFlag = 1                    self.triggerButton['state']= 'disabled'                    for flushB in range(0,math.ceil(0.01/(tmpDt))):                        #time.sleep(0.001)                        time.sleep(tmpDt)                        self.serObj.flushBuffer(self.serObj.teensy)                    self.sendTrigger()                except:                    print('Could Not Connect')            else:                self.sendTriggerFlag = 0                self.serObj.teensy.write('a0>'.encode('utf-8'))                print('Trigger sent')                 time.sleep(2.0/self.varObj.sesVarDict['sampRate'])                self.serObj.flushBuffer(self.serObj.teensy)                self.serObj.teensy.close()                self.triggerButton['state']= 'normal'        else:            print('Trigger already sent, either stop recording first or program triggers in Design Window')    def sendCommand(self):        if self.variables.inTaskFlag==0:            tempComPath=self.variables.comPath.get()            if len(tempComPath)>0:                self.varObj.sesVarDict['comPath']=tempComPath            cmPath=self.varObj.sesVarDict['comPath']            baudRt= self.varObj.sesVarDict['baudRate_teensy']                 self.serObj.commandTeensy(cmPath,baudRt,self.variables.tsy_command.get())        else:            print('Please stop recording/task before sending messages')    def giveReward(self):        tmpDt=1.0/self.varObj.sesVarDict['sampRate']        setRwdChan=False        setRwdDur=False        try:            tmpRwd = int(self.variables.rewardChannel.get())            if type(tmpRwd)==int and tmpRwd>0:                setRwdChan=tmpRwd                self.varObj.sesVarDict['rewardChannel']=tmpRwd            else:                print('Please enter valid reward channel in Detection Task window')        except:            print('Please enter valid reward channel in Detection Task window')        try:            tmpDur = float(self.variables.rewardDur.get())            if type(tmpDur)==float and tmpDur>=(tmpDt):                setRwdDur=tmpDur                self.varObj.sesVarDict['rewardDur']=tmpDur            else:                print('Please enter valid reward duration in Detection Task window')                    except:            print('Please enter valid reward duration in Detection Task window')        if (not (type(setRwdChan)==bool)) and (not (type(setRwdDur)==bool)):            # We check both because this may have not been verified depending on task routine            self.giveRewardButton['state']= 'disabled'            if self.variables.inTaskFlag==1:                if self.varObj.sesVarDict['taskType']=='detection':                    taskVar.pauseSending=True                    while taskVar.sendingNow:                        pass # Last two lines prevent overwrite with scheduledMessages variable shared with run-string                    #Now just add the message, add duration and start message because may not have been active before                    addSerialMessage(np.nan,(setRwdChan,1),'pulseDur',setRwdDur,1)                    addSerialMessage(np.nan,(setRwdChan,1),'startTime',-1,1)                    taskVar.pauseSending=False                    taskVar.manualRewards.append(taskVar.curTime+tmpDt+tmpDt) # two Dt's for two messages                else:                    #just send it here                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['pulseDur'][1],str(int(round(setRwdDur*100000)))+str(setRwdChan)).encode('utf-8'))                    time.sleep(tmpDt)                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['startTime'][1],'-1'+str(setRwdChan)).encode('utf-8'))                    taskVar.manualRewards.append(taskVar.curTime+tmpDt)             else:                #here we need to also connect to the teensy - can't above or it crashes the task                try:                    tempComPath=self.variables.comPath.get()                    if len(tempComPath)>0:                        self.varObj.sesVarDict['comPath']=tempComPath                    cmPath=self.varObj.sesVarDict['comPath']                    baudRt= self.varObj.sesVarDict['baudRate_teensy']                    self.serObj.teensy=self.serObj.connectComObj(cmPath,baudRt)                    self.serObj.flushBuffer(self.serObj.teensy)                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['pulseDur'][1],str(int(round(setRwdDur*100000)))+str(setRwdChan)).encode('utf-8'))                    time.sleep(tmpDt)                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['startTime'][1],'0'+str(setRwdChan)).encode('utf-8'))                    time.sleep(tmpDt)                    self.serObj.teensy.write('a1>'.encode('utf-8'))                                        for flushB in range(0,math.ceil(setRwdDur/(tmpDt))):                        #time.sleep(0.001)                        time.sleep(tmpDt)                        self.serObj.flushBuffer(self.serObj.teensy)                                 self.serObj.teensy.write('a0>'.encode('utf-8'))                    print('Reward sent')                    self.serObj.flushBuffer(self.serObj.teensy)                    time.sleep(2.0/self.varObj.sesVarDict['sampRate'])                    self.serObj.flushBuffer(self.serObj.teensy)                    self.serObj.teensy.close()                except:                    print('Could not connect')            self.giveRewardButton['state']= 'normal'    def giveWidthdraw(self):        tmpDt=1.0/self.varObj.sesVarDict['sampRate']        setWdrChan=False        setWdrDur=False        try:            tmpWdr = int(self.variables.widthdrawChannel.get())            if type(tmpWdr)==int and tmpWdr>0:                setWdrChan=tmpWdr                self.varObj.sesVarDict['widthdrawChannel']=tmpWdr            else:                print('Please enter valid widthdraw channel in Detection Task window')        except:            print('Please enter valid widthdraw channel in Detection Task window')        try:            tmpDur = float(self.variables.widthdrawDur.get())            if type(tmpDur)==float and tmpDur>=(tmpDt):                setWdrDur=tmpDur                self.varObj.sesVarDict['widthdrawDur']=tmpDur            else:                print('Please enter valid widthdraw duration in Detection Task window')                    except:            print('Please enter valid widthdraw duration in Detection Task window')        if (not (type(setWdrChan)==bool)) and (not (type(setWdrDur)==bool)):            # We check both because this may have not been verified depending on task routine            self.giveWidthdrawButton['state']= 'disabled'            if self.variables.inTaskFlag==1:                if self.varObj.sesVarDict['taskType']=='detection':                    taskVar.pauseSending=True                    while taskVar.sendingNow:                        pass # Last two lines prevent overwrite with scheduledMessages variable shared with run-string                    #Now just add the message, add duration and start message because may not have been active before                    addSerialMessage(np.nan,(setWdrChan,1),'pulseDur',setWdrDur,1)                    addSerialMessage(np.nan,(setWdrChan,1),'startTime',-1,1)                    taskVar.pauseSending=False                    taskVar.manualWidthdraws.append(taskVar.curTime+tmpDt+tmpDt) # two Dt's for two messages                else:                    #just send it here                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['pulseDur'][1],str(int(round(setWdrDur*100000)))+str(setWdrChan)).encode('utf-8'))                    time.sleep(tmpDt)                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['startTime'][1],'-1'+str(setWdrChan)).encode('utf-8'))                    taskVar.manualWidthdraws.append(taskVar.curTime+tmpDt) # two Dt's for two messages            else:                #here we need to also connect to the teensy - can't above or it crashes the task                try:                    tempComPath=self.variables.comPath.get()                    if len(tempComPath)>0:                        self.varObj.sesVarDict['comPath']=tempComPath                    cmPath=self.varObj.sesVarDict['comPath']                    baudRt= self.varObj.sesVarDict['baudRate_teensy']                    self.serObj.teensy=self.serObj.connectComObj(cmPath,baudRt)                    self.serObj.flushBuffer(self.serObj.teensy)                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['pulseDur'][1],str(int(round(setWdrDur*100000)))+str(setWdrChan)).encode('utf-8'))                    time.sleep(tmpDt)                    self.serObj.teensy.write('{}{}>'.format(self.varObj.sendParametersDict['startTime'][1],'0'+str(setWdrChan)).encode('utf-8'))                    time.sleep(tmpDt)                    self.serObj.teensy.write('a1>'.encode('utf-8'))                                        for flushB in range(0,math.ceil(setWdrDur/(tmpDt))):                        #time.sleep(0.001)                        time.sleep(tmpDt)                        self.serObj.flushBuffer(self.serObj.teensy)                                 self.serObj.teensy.write('a0>'.encode('utf-8'))                    print('Widthdraw sent')                    self.serObj.flushBuffer(self.serObj.teensy)                    time.sleep(2.0/self.varObj.sesVarDict['sampRate'])                    self.serObj.flushBuffer(self.serObj.teensy)                    self.serObj.teensy.close()                except:                    print('Could not connect')            self.giveWidthdrawButton['state']= 'normal'        class stimDesignGUI:    def __init__(self, master,variables,varObj,mainGUI):        self.master = master        self.master.title("Output Signal Design")        self.variables=variables        self.varObj=varObj        self.mainGUI=mainGUI        self.varObj.resetDict('makeTrialsDict')        self.varObj.resetDict('makeBlockDict',['varsToUse','getVars'])        self.varObj.resetDict('makeBlockDesignDict')        self.designFieldsReset(self.variables.designVariablesDict['channelFields'])        self.designFieldsReset(self.variables.designVariablesDict['offsetFields'])        self.designFieldsReset(self.variables.designVariablesDict['blockFields'])        self.lineCount=0        self.updateFlag=0        self.updateLine =[]        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.blockDesignWindow = tk.Toplevel(self.master)        self.blockDesign = blockDesignGUI(self.blockDesignWindow, self.variables, self.varObj,self)        self.top = self.master.winfo_toplevel()        self.top.grid()        #self.master.grid()        self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)         self.frame.columnconfigure(0, weight=1)        self.top.rowconfigure(0, weight=1)         self.top.columnconfigure(0, weight=1)         self.frame.rowconfigure(1, weight=1)        self.frame.columnconfigure(1, weight=1)        self.frame.rowconfigure(2, weight=1)         self.frame.columnconfigure(2, weight=1)        self.frame.columnconfigure(3, weight=1)        self.frame.columnconfigure(4, weight=1)        self.frame.columnconfigure(5, weight=1)        self.frame.columnconfigure(6, weight=1)        self.frame.columnconfigure(7, weight=1)        #self.master.rowconfigure(0, weight=1)         #self.master.columnconfigure(0, weight=1)        #self.quitButton = tk.Button(self.frame, text = 'Quit', width = 25, command = self.close_windows)        #self.quitButton.grid(row=0,column=0,sticky=tk.N+tk.S+tk.E+tk.W)        self.instructionLabel = tk.Label(self.frame, text='Enter Your Output Signal Deign for This Block', justify='left', font = self.midFont)        self.instructionLabel.grid(row=0,column=0,sticky=tk.NW, columnspan=8)        self.timeInfoLabel = tk.Label(self.frame, text='Time increments in Seconds to 5 decimal Precision (0.00001s)', justify='left', font = self.smallFont)        self.timeInfoLabel.grid(row=1,column=0,sticky=tk.W, columnspan=5)        self.trialCountLabel = tk.Label(self.frame, text=' Trial Count:', font=self.smallFont, justify='right')        self.trialCountLabel.grid(row=1,column=5,sticky=tk.E, columnspan=1)        self.trialCountEntry = tk.Entry(self.frame, width = 4, font = self.smallFont, justify='right',\            textvariable=self.variables.trialCount)        self.trialCountEntry.grid(row=1,column=6,sticky=tk.W)        self.trialTimeLabel = tk.Label(self.frame, text='Baseline (ITI) Time. Min:',\            font=self.smallFont, justify='right')        self.trialTimeEntryMin  = tk.Entry(self.frame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.trialTime_min)        self.trialTimeMaxLabel = tk.Label(self.frame, text='Max:',font=self.smallFont, justify='right')        self.trialTimeEntryMax = tk.Entry(self.frame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.trialTime_max)        self.trialTimeStepsLabel = tk.Label(self.frame, text='Steps:',font=self.smallFont, justify='right')        self.trialTimeEntrySteps = tk.Entry(self.frame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.trialTime_steps)        self.trialTimeProbsLabel = tk.Label(self.frame, text='Probs:',font=self.smallFont, justify='right')        self.trialTimeEntryProbs = tk.Entry(self.frame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.trialTime_probs)        self.trialTimeLabel.grid(row=2,column=0,sticky=tk.E)        self.trialTimeEntryMin.grid(row=2,column=1,sticky=tk.W)        self.trialTimeMaxLabel.grid(row=2,column=2,sticky=tk.E)        self.trialTimeEntryMax.grid(row=2,column=3,sticky=tk.W)        self.trialTimeStepsLabel.grid(row=2,column=4,sticky=tk.E)        self.trialTimeEntrySteps.grid(row=2,column=5,sticky=tk.W)        self.trialTimeProbsLabel.grid(row=2,column=6,sticky=tk.E)        self.trialTimeEntryProbs.grid(row=2,column=7,sticky=tk.W)        self.frame.rowconfigure(3, weight=1)        self.frame.rowconfigure(4, weight=1)          self.channelLabelFrame = tk.LabelFrame(self.frame, text='Individual Channel Behaviors:', labelanchor='nw')        self.channelLabelFrame.grid(row=3,column=0, columnspan=8, padx = 5, pady = 5, sticky=tk.W)        self.channelLabelFrame.rowconfigure(0,weight=1)        self.channelLabelFrame.rowconfigure(1,weight=1)        self.channelLabelFrame.rowconfigure(2,weight=1)        self.channelLabelFrame.rowconfigure(3,weight=1)        self.channelLabelFrame.columnconfigure(0,weight=1)        self.channelLabelFrame.columnconfigure(1,weight=1)        self.channelLabelFrame.columnconfigure(2,weight=1)        self.channelLabelFrame.columnconfigure(3,weight=1)        self.channelLabelFrame.columnconfigure(4,weight=1)        self.channelLabelFrame.columnconfigure(5,weight=1)        self.channelLabelFrame.columnconfigure(6,weight=1)        self.channelLabelFrame.columnconfigure(7,weight=1)        self.chanToUseLabel = tk.Label(self.channelLabelFrame, text="Channel #: ", font=self.smallFont, justify='right')        self.chanToUseLabel.grid(row=0,column=0, rowspan=2, sticky=tk.E)        self.chanToUseEntry = tk.Entry(self.channelLabelFrame, width = 1, font = self.smallFont, justify='right',\            textvariable=self.variables.chanToUse)        self.chanToUseEntry.grid(row=0,column=1, rowspan=2, sticky=tk.W)        self.chanToUseTypeA= tk.Radiobutton(self.channelLabelFrame, text = 'DAC', font = self.smallFont,\            variable = self.variables.chanToUseType, value= '0')        self.chanToUseTypeD= tk.Radiobutton(self.channelLabelFrame, text = 'D_Out', font = self.smallFont,\            variable = self.variables.chanToUseType, value= '1')        self.chanToUseTypeA.grid(row=0,column=2, rowspan=1, sticky=tk.W)        self.chanToUseTypeD.grid(row=1,column=2, rowspan=1, sticky=tk.W)        self.chanToUseTypeA.select()        self.syncGroupLabel = tk.Label(self.channelLabelFrame, text='Sync Group #:\n (Optnl, >1)', font=self.smallFont, justify='right')        self.syncGroupEntry = tk.Entry(self.channelLabelFrame, width = 2, font = self.smallFont, justify='right',\            textvariable=self.variables.syncGroup)        self.syncGroupLabel.grid(row=0,column=3, sticky=tk.E)        self.syncGroupEntry.grid(row=0,column=4, sticky=tk.W)        self.waveformLabel = tk.Label(self.channelLabelFrame, text='Waveform:\n (0=sqr,2=AsymCos)', font=self.smallFont, justify='right')        self.waveformEntry = tk.Entry(self.channelLabelFrame, width = 1, font = self.smallFont, justify='right',\            textvariable=self.variables.waveform)        self.waveformLabel.grid(row=0,column=5, sticky=tk.E)        self.waveformEntry.grid(row=0,column=6, sticky=tk.W)        self.rewardCheckButton = tk.Checkbutton(self.channelLabelFrame, text='Reward This?', font=self.smallFont,\            variable=self.variables.rewardStimulus, onvalue='1', offvalue='0', command=lambda: self.toggleReward(1))        self.rewardCheckButton.grid(row=0,column=7, sticky=tk.W)        self.catchCheckButton = tk.Checkbutton(self.channelLabelFrame, text='Catch Stim?', font=self.smallFont,\            variable=self.variables.catchStimulus, onvalue='1', offvalue='0', command=lambda: self.toggleReward(2))        self.catchCheckButton.grid(row=1,column=7, sticky=tk.W)                self.offsetLabel = tk.Label(self.channelLabelFrame, text='Offset from Baseline [s]. Min:', font=self.smallFont, justify='right')        self.offsetEntryMin = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.offset_min)        self.offsetMaxLabel = tk.Label(self.channelLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.offsetEntryMax = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.offset_max)        self.offsetStepsLabel = tk.Label(self.channelLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.offsetEntrySteps = tk.Entry(self.channelLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.offset_steps)        self.offsetProbsLabel = tk.Label(self.channelLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.offsetEntryProbs = tk.Entry(self.channelLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.offset_probs)        self.offsetLabel.grid(row=2,column=0,sticky=tk.E)        self.offsetEntryMin.grid(row=2,column=1,sticky=tk.W)        self.offsetMaxLabel.grid(row=2,column=2,sticky=tk.E)        self.offsetEntryMax.grid(row=2,column=3,sticky=tk.W)        self.offsetStepsLabel.grid(row=2,column=4,sticky=tk.E)        self.offsetEntrySteps.grid(row=2,column=5,sticky=tk.W)        self.offsetProbsLabel.grid(row=2,column=6,sticky=tk.E)        self.offsetEntryProbs.grid(row=2,column=7,sticky=tk.W)        self.ampLabel = tk.Label(self.channelLabelFrame, text='Pulse Amp [0:4095]. Min:', font=self.smallFont, justify='right')        self.ampEntryMin = tk.Entry(self.channelLabelFrame, width = 4, font = self.smallFont, justify='right',\            textvariable=self.variables.amp_min)        self.ampMaxLabel = tk.Label(self.channelLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.ampEntryMax = tk.Entry(self.channelLabelFrame, width = 4, font = self.smallFont, justify='right',\            textvariable=self.variables.amp_max)        self.ampStepsLabel = tk.Label(self.channelLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.ampEntrySteps = tk.Entry(self.channelLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.amp_steps)        self.ampProbsLabel = tk.Label(self.channelLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.ampEntryProbs = tk.Entry(self.channelLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.amp_probs)        self.ampLabel.grid(row=3,column=0,sticky=tk.E)        self.ampEntryMin.grid(row=3,column=1,sticky=tk.W)        self.ampMaxLabel.grid(row=3,column=2,sticky=tk.E)        self.ampEntryMax.grid(row=3,column=3,sticky=tk.W)        self.ampStepsLabel.grid(row=3,column=4,sticky=tk.E)        self.ampEntrySteps.grid(row=3,column=5,sticky=tk.W)        self.ampProbsLabel.grid(row=3,column=6,sticky=tk.E)        self.ampEntryProbs.grid(row=3,column=7,sticky=tk.W)        self.channelLabelFrame.rowconfigure(4,weight=1)        self.pulseDurLabel = tk.Label(self.channelLabelFrame, text='Pulse Width [s]. Min:', font=self.smallFont, justify='right')        self.pulseDurEntryMin = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseDur_min)        self.pulseDurMaxLabel = tk.Label(self.channelLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.pulseDurEntryMax = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseDur_max)        self.pulseDurStepsLabel = tk.Label(self.channelLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.pulseDurEntrySteps = tk.Entry(self.channelLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseDur_steps)        self.pulseDurProbsLabel = tk.Label(self.channelLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.pulseDurEntryProbs = tk.Entry(self.channelLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseDur_probs)        self.pulseDurLabel.grid(row=4,column=0,sticky=tk.E)        self.pulseDurEntryMin.grid(row=4,column=1,sticky=tk.W)        self.pulseDurMaxLabel.grid(row=4,column=2,sticky=tk.E)        self.pulseDurEntryMax.grid(row=4,column=3,sticky=tk.W)        self.pulseDurStepsLabel.grid(row=4,column=4,sticky=tk.E)        self.pulseDurEntrySteps.grid(row=4,column=5,sticky=tk.W)        self.pulseDurProbsLabel.grid(row=4,column=6,sticky=tk.E)        self.pulseDurEntryProbs.grid(row=4,column=7,sticky=tk.W)        self.channelLabelFrame.rowconfigure(5,weight=1)        self.pulseUpLabel = tk.Label(self.channelLabelFrame, text='Pulse Up Phase [s, Asym Only]. Min:', font=self.smallFont, justify='right')        self.pulseUpEntryMin = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseUpDur_min)        self.pulseUpMaxLabel = tk.Label(self.channelLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.pulseUpEntryMax = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseUpDur_max)        self.pulseUpStepsLabel = tk.Label(self.channelLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.pulseUpEntrySteps = tk.Entry(self.channelLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseUpDur_steps)        self.pulseUpProbsLabel = tk.Label(self.channelLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.pulseUpEntryProbs = tk.Entry(self.channelLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseUpDur_probs)        self.pulseUpLabel.grid(row=5,column=0,sticky=tk.E)        self.pulseUpEntryMin.grid(row=5,column=1,sticky=tk.W)        self.pulseUpMaxLabel.grid(row=5,column=2,sticky=tk.E)        self.pulseUpEntryMax.grid(row=5,column=3,sticky=tk.W)        self.pulseUpStepsLabel.grid(row=5,column=4,sticky=tk.E)        self.pulseUpEntrySteps.grid(row=5,column=5,sticky=tk.W)        self.pulseUpProbsLabel.grid(row=5,column=6,sticky=tk.E)        self.pulseUpEntryProbs.grid(row=5,column=7,sticky=tk.W)        self.channelLabelFrame.rowconfigure(6,weight=1)        self.interPulseDurLabel = tk.Label(self.channelLabelFrame, text='Interpulse Width [s]. Min:', font=self.smallFont, justify='right')        self.interPulseDurEntryMin = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.interPulseDur_min)        self.interPulseDurMaxLabel = tk.Label(self.channelLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.interPulseDurEntryMax = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.interPulseDur_max)        self.interPulseDurStepsLabel = tk.Label(self.channelLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.interPulseDurEntrySteps = tk.Entry(self.channelLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.interPulseDur_steps)        self.interPulseDurProbsLabel = tk.Label(self.channelLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.interPulseDurEntryProbs = tk.Entry(self.channelLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.interPulseDur_probs)        self.interPulseDurLabel.grid(row=6,column=0,sticky=tk.E)        self.interPulseDurEntryMin.grid(row=6,column=1,sticky=tk.W)        self.interPulseDurMaxLabel.grid(row=6,column=2,sticky=tk.E)        self.interPulseDurEntryMax.grid(row=6,column=3,sticky=tk.W)        self.interPulseDurStepsLabel.grid(row=6,column=4,sticky=tk.E)        self.interPulseDurEntrySteps.grid(row=6,column=5,sticky=tk.W)        self.interPulseDurProbsLabel.grid(row=6,column=6,sticky=tk.E)        self.interPulseDurEntryProbs.grid(row=6,column=7,sticky=tk.W)        self.channelLabelFrame.rowconfigure(7,weight=1)        self.pulseTrainDurLabel = tk.Label(self.channelLabelFrame, text='Pulse Train Width [s]. Min:', font=self.smallFont, justify='right')        self.pulseTrainDurEntryMin = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseTrainDur_min)        self.pulseTrainDurMaxLabel = tk.Label(self.channelLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.pulseTrainDurEntryMax = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseTrainDur_max)        self.pulseTrainDurStepsLabel = tk.Label(self.channelLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.pulseTrainDurEntrySteps = tk.Entry(self.channelLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseTrainDur_steps)        self.pulseTrainDurProbsLabel = tk.Label(self.channelLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.pulseTrainDurEntryProbs = tk.Entry(self.channelLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseTrainDur_probs)        self.pulseTrainDurLabel.grid(row=7,column=0,sticky=tk.E)        self.pulseTrainDurEntryMin.grid(row=7,column=1,sticky=tk.W)        self.pulseTrainDurMaxLabel.grid(row=7,column=2,sticky=tk.E)        self.pulseTrainDurEntryMax.grid(row=7,column=3,sticky=tk.W)        self.pulseTrainDurStepsLabel.grid(row=7,column=4,sticky=tk.E)        self.pulseTrainDurEntrySteps.grid(row=7,column=5,sticky=tk.W)        self.pulseTrainDurProbsLabel.grid(row=7,column=6,sticky=tk.E)        self.pulseTrainDurEntryProbs.grid(row=7,column=7,sticky=tk.W)        self.channelLabelFrame.rowconfigure(8,weight=1)        self.pulseCountLabel = tk.Label(self.channelLabelFrame, text='Pulse Count Limit [n]. Min:', font=self.smallFont, justify='right')        self.pulseCountEntryMin = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseCount_min)        self.pulseCountMaxLabel = tk.Label(self.channelLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.pulseCountEntryMax = tk.Entry(self.channelLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseCount_max)        self.pulseCountStepsLabel = tk.Label(self.channelLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.pulseCountEntrySteps = tk.Entry(self.channelLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseCount_steps)        self.pulseCountProbsLabel = tk.Label(self.channelLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.pulseCountEntryProbs = tk.Entry(self.channelLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.pulseCount_probs)        self.pulseCountLabel.grid(row=8,column=0,sticky=tk.E)        self.pulseCountEntryMin.grid(row=8,column=1,sticky=tk.W)        self.pulseCountMaxLabel.grid(row=8,column=2,sticky=tk.E)        self.pulseCountEntryMax.grid(row=8,column=3,sticky=tk.W)        self.pulseCountStepsLabel.grid(row=8,column=4,sticky=tk.E)        self.pulseCountEntrySteps.grid(row=8,column=5,sticky=tk.W)        self.pulseCountProbsLabel.grid(row=8,column=6,sticky=tk.E)        self.pulseCountEntryProbs.grid(row=8,column=7,sticky=tk.W)        self.frame.rowconfigure(5,weight=1)        self.frame.rowconfigure(6,weight=1)        self.frame.rowconfigure(7,weight=1)        self.outputSignalList = tk.Listbox(self.frame, width = 65, height = 10,selectmode = "multiple", listvariable=self.variables.designList)        self.outputSignalList.grid(row = 4, column = 0, rowspan = 4, columnspan = 7, padx=5, pady=5, sticky = tk.NW)        self.addLineButton = tk.Button(self.frame,text = 'Add Line', anchor = 'center', font =self.midFont, command=self.add_Line)        self.deleteLineButton = tk.Button(self.frame, text = 'Delete Line', anchor = 'center', font = self.midFont, command=self.delete_Line)        self.duplicateLineButton = tk.Button(self.frame, text = 'Duplicate', anchor = 'center', font = self.midFont, command=self.duplicateLine)        self.editLineButton = tk.Button(self.frame, text = 'Edit', anchor = 'center', font = self.midFont, command = self.editLine)        self.addLineButton.grid(row = 4, column = 7, sticky = tk.W)        self.deleteLineButton.grid(row = 5, column = 7, sticky = tk.W)        self.duplicateLineButton.grid(row = 6, column = 7, sticky = tk.W)        self.editLineButton.grid(row = 7, column = 7, sticky = tk.W)        self.frame.rowconfigure(8,weight=1)        self.offsetLabelFrame = tk.LabelFrame(self.frame, text='Add Offset (select line, multiple lines adds identical offset):', labelanchor='nw')        self.offsetLabelFrame.grid(row=8,column=0, columnspan=8, padx = 5, pady = 5, sticky=tk.W)        self.offsetLabelFrame.rowconfigure(0,weight=1)        self.offsetLabelFrame.columnconfigure(1,weight=1)        self.offsetLabelFrame.columnconfigure(2,weight=1)        self.offsetLabelFrame.columnconfigure(3,weight=1)        self.offsetLabelFrame.columnconfigure(4,weight=1)        self.offsetLabelFrame.columnconfigure(5,weight=1)        self.offsetLabelFrame.columnconfigure(6,weight=1)        self.offsetLabelFrame.columnconfigure(7,weight=1)        self.offsetLabelFrame.columnconfigure(8,weight=1)        self.offsetLabelFrame.columnconfigure(9,weight=1)        self.addOffsetLabel = tk.Label(self.offsetLabelFrame, text='Add Offset [s]. Min:', font=self.smallFont, justify='right')        self.addOffsetEntryMin = tk.Entry(self.offsetLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.addOffset_min)        self.addOffsetMaxLabel = tk.Label(self.offsetLabelFrame, text='Max:', font=self.smallFont, justify='right')        self.addOffsetEntryMax = tk.Entry(self.offsetLabelFrame, width = 7, font = self.smallFont, justify='right',\            textvariable=self.variables.addOffset_max)        self.addOffsetStepsLabel = tk.Label(self.offsetLabelFrame, text='Steps:', font=self.smallFont, justify='right')        self.addOffsetEntrySteps = tk.Entry(self.offsetLabelFrame, width = 12, font = self.smallFont, justify='right',\            textvariable=self.variables.addOffset_steps)        self.addOffsetProbsLabel = tk.Label(self.offsetLabelFrame, text='Probs:', font=self.smallFont, justify='right')        self.addOffsetEntryProbs = tk.Entry(self.offsetLabelFrame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.addOffset_probs)        self.addOffsetLabel.grid(row=0,column=0,sticky=tk.E)        self.addOffsetEntryMin.grid(row=0,column=1,sticky=tk.E)        self.addOffsetMaxLabel.grid(row=0,column=2,sticky=tk.E)        self.addOffsetEntryMax.grid(row=0,column=3,sticky=tk.E)        self.addOffsetStepsLabel.grid(row=0,column=4,sticky=tk.E)        self.addOffsetEntrySteps.grid(row=0,column=5,sticky=tk.E)        self.addOffsetProbsLabel.grid(row=0,column=6,sticky=tk.E)        self.addOffsetEntryProbs.grid(row=0,column=7,sticky=tk.E)        self.offsetAddButton = tk.Button(self.offsetLabelFrame,text = 'Add', anchor = 'center', font =self.midFont, command=self.addOffsetToLines)        self.offsetClearButton = tk.Button(self.offsetLabelFrame, text = 'Clear Last', anchor = 'center', font = self.midFont, command=self.clearLastOffset)        self.offsetAddButton.grid(row = 0, column = 8, sticky = tk.W)        self.offsetClearButton.grid(row = 0, column = 9, sticky = tk.W)        self.frame.rowconfigure(9,weight=1)        self.blockNameLabel = tk.Label(self.frame, text='Block Name (optnl):', font=self.smallFont, justify='right')        self.blockNameEntryMin = tk.Entry(self.frame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.blockName)        self.saveAndAddButton = tk.Button(self.frame,text = 'Save + Add', anchor = 'center', font =self.midFont, command=self.saveAndAddBlock)        self.saveButton = tk.Button(self.frame,text = 'Save (only)', anchor = 'center', font =self.midFont, command=self.saveBlock)        self.loadButton = tk.Button(self.frame,text = 'Load', anchor = 'center', font =self.midFont, command=self.loadBlock)        self.clearButton = tk.Button(self.frame,text = 'Clear', anchor = 'center', font =self.midFont, command=self.clearBlock)        self.blockNameLabel.grid(row = 9, column = 0, sticky = tk.E)        self.blockNameEntryMin.grid(row = 9, column = 1, sticky = tk.W)        self.saveAndAddButton.grid(row = 9, column = 2, sticky = tk.W)        self.saveButton.grid(row = 9, column = 3, sticky = tk.W)        self.loadButton.grid(row = 9, column = 4, sticky = tk.W)        self.clearButton.grid(row = 9, column = 5, sticky = tk.W)    def toggleReward(self,buttonCode):        if buttonCode==1:            self.catchCheckButton.deselect()        if buttonCode==2:            self.rewardCheckButton.deselect()    def close_windows(self):        self.master.destroy()    def add_Line(self):        # TODO All this code can potentially roll into self.getAllChannelFields         printDict={}        printList = [['chanToUse','chanToUseType','syncGroup','waveform','amp_max',\        'offset_max','pulseTrainDur_max','rewardStimulus','catchStimulus'],['Ch ',' Type ',' Sync ',' Wave ',' aMax ',' offstMax ',' ptMax ']]        for printVal in printList[0]:            printDict[printVal]=[]                for key in list(self.varObj.makeTrialsDict.keys()):            if (key != 'varsToUse') and (key not in self.varObj.makeTrialsDict['varsToUse']):                if len(eval('self.variables.{}.get().strip()'.format(key)))>0:                    curParam=[]                    curParam=eval('self.variables.{}.get().strip()'.format(key))                    curParam=curParam.strip('][')                    try:                        self.varObj.makeTrialsDict[key].append(int(curParam))                    except:                        self.varObj.makeTrialsDict[key].append([])                        print('{} Requires an integar, please edit'.format(key))                else:                    self.varObj.makeTrialsDict[key].append([])                if key in printList[0]:                    try:                        printDict[key]=str(self.varObj.makeTrialsDict[key][-1])                    except:                        printDict[key]=''            # TODO I can Roll the following code into one execution of getMinMaxProbsFields        for getVar in self.varObj.makeTrialsDict['varsToUse']:            if getVar not in list(self.varObj.makeTrialsDict.keys()):                self.varObj.makeTrialsDict[getVar]=[]            varParams = [[],[],[],[]]            curParam = []            paramCount =0            for suffix in ['_min','_max','_steps','_probs']:                try:                    curParam=[]                    curParam = eval('self.variables.{}{}.get().strip()'.format(getVar,suffix))                    curParam=curParam.strip('][')                    if (suffix == '_probs') and len(curParam)>0:                        try:                            curParam=curParam.split(',')                            for ind in range(len(curParam)):                                try:                                    curParam[ind]=curParam[ind].strip('"')                                    curParam[ind]=curParam[ind].strip("'")                                    curParam[ind]=self.varObj.inferType(curParam[ind])                                except:                                    pass                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                    elif (suffix == '_steps') and len(curParam)>0:                        try:                            if (curParam[0] == ':') and (curParam[1] != ','):                                curParam =  curParam[0]+','+ curParam[1:]                            curParam = self.varObj.splitStepsVar(curParam)                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                    elif ((suffix == '_min') or (suffix == '_max')) and len(curParam)>0:                        try:                            curParam=self.varObj.inferType(curParam)                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                                           else:                        varParams[paramCount]=[]                except:                    varParams[paramCount]=[]                                if (getVar+suffix) in printList[0]:                    printDict[getVar+suffix]=str(varParams[paramCount])                paramCount+=1                        self.varObj.makeTrialsDict[getVar].append(varParams)        feedbackString = ''        for x in range(len(printList[1])):            feedbackString=feedbackString+printList[1][x]+printDict[printList[0][x]]        if printDict['rewardStimulus']=='1':            feedbackString=feedbackString+' _R '        elif printDict['catchStimulus']=='1':            feedbackString=feedbackString+' _C '        self.outputSignalList.insert(self.lineCount,feedbackString)        self.lineCount+=1        self.designFieldsReset(self.variables.designVariablesDict['channelFields'])    def saveAndAddBlock(self):        blockFileAddress = self.saveBlock(1)        blockNum = len(self.varObj.blockDesignDict['blockNumList'].values())        blockName = self.varObj.tempBlockDict['makeBlockDict']['blockName']        blockName =self.varObj.blockNameIncrement(blockName,\            list(self.varObj.blockDesignDict['blockNumList'].values()),1)        self.varObj.makeBlockDesignDict['blockName']=blockName        self.varObj.makeBlockDesignDict['makeBlockDict']=self.varObj.tempBlockDict['makeBlockDict']        self.varObj.makeBlockDesignDict['makeTrialsDict']=self.varObj.tempBlockDict['makeTrialsDict']        self.varObj.makeBlockDesignDict['blockFileAddress']=str(blockFileAddress)+'.json'        feedbackString=''        for x in range(len(self.varObj.tempBlockDict['makeTrialsDict']['chanToUse'])):            chan = str(self.varObj.tempBlockDict['makeTrialsDict']['chanToUse'][x])            typ = str(self.varObj.tempBlockDict['makeTrialsDict']['chanToUseType'][x])            rwd = ''            if self.varObj.tempBlockDict['makeTrialsDict']['rewardStimulus'][x]==1:                rwd = '_r'            elif self.varObj.tempBlockDict['makeTrialsDict']['catchStimulus'][x]==1:                rwd = '_c'            feedbackString = feedbackString + 'Ch:'+chan +','+'Typ:'+typ+','+rwd+';'        feedbackString = feedbackString+' Name= '+ blockName + ' ShuffleGrp '        self.blockDesign.blockList.insert(tk.END,feedbackString)        self.varObj.blockDesignDict['blockList']=self.blockDesign.blockList.get(0,tk.END)        self.varObj.blockDesignDict['blockNumList'][str(blockNum)]=blockName        self.varObj.blockDesignDict['shuffleGroup'][blockName]=[]        if len(self.varObj.blockDesignDict['experimentName'])==0:            self.varObj.blockDesignDict['experimentName']='exp_1'            self.variables.experimentName.set('exp_1')        self.varObj.blockDesignDict['blocks'][blockName]=copy.deepcopy(self.varObj.makeBlockDesignDict)        del self.varObj.tempBlockDict        self.varObj.resetDict('makeTrialsDict')        self.varObj.resetDict('makeBlockDict',['varsToUse','getVars'])        self.varObj.resetDict('makeBlockDesignDict')        self.clearBlock()        #reset dicts    def saveBlock(self,rtrn=0):        tStamp=datetime.datetime.now().strftime("_%Y_%m_%d_%H%M%S")        if len(self.variables.blockName.get()) <1:            nameNum =  len(self.varObj.blockDesignDict['blockNumList'].values())+1            blockName = "Block_"+str(nameNum)            self.variables.blockName.set(blockName)        else:            blockName=self.variables.blockName.get()        saveName=blockName+tStamp        saveDirectory= self.varObj.sesVarDict['dirPath'] / 'blockDict'         self.varObj.makeBlockDict['outputSignalList']=self.outputSignalList.get(0,tk.END)                for key in self.varObj.makeBlockDict['getVars']:            val=eval('self.variables.{}.get()'.format(key))            self.varObj.makeBlockDict[key] = self.varObj.inferType(val)        self.getMinMaxProbsFields('self.varObj.makeBlockDict',[[],[]],'y')        self.varObj.tempBlockDict = {'makeTrialsDict':self.varObj.makeTrialsDict,'makeBlockDict':self.varObj.makeBlockDict}        self.varObj.saveJSONDict(self.varObj.tempBlockDict,saveDirectory,saveName)        self.toggleEditButton()        print('{} saved to {}'.format(blockName,saveDirectory))        if rtrn == 1:            return saveDirectory / saveName    def getMinMaxProbsFields(self,varsDict='',printLst=[[],[]],overWrite='n', specificKeys=[]):        if len(printLst[0])>0:            printDct={}            for printVal in printLst[0]:                printDct[printVal]=[]        else:            printDct={}        if len(specificKeys)>0:            varsToUseFromDict=specificKeys        else:            varsToUseFromDict = eval("{}['varsToUse']".format(varsDict))               keysToUseFromDict = eval("list({}.keys())".format(varsDict))        #self.varObj.makeTrialsDict        for getVar in varsToUseFromDict:            if getVar not in keysToUseFromDict:                exec("{}[getVar]=[]".format(varsDict))            varParams = [[],[],[],[]]            curParam = []            paramCount =0            for suffix in ['_min','_max','_steps','_probs']:                try:                    curParam=[]                    curParam = eval('self.variables.{}{}.get().strip()'.format(getVar,suffix))                    curParam=curParam.strip('][')                    if (suffix == '_probs') and len(curParam)>0:                        try:                            curParam=curParam.split(',')                            for ind in range(len(curParam)):                                try:                                    curParam[ind]=curParam[ind].strip('"')                                    curParam[ind]=curParam[ind].strip("'")                                    curParam[ind]=self.varObj.inferType(curParam[ind])                                except:                                    pass                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                    elif (suffix == '_steps') and len(curParam)>0:                        try:                            if (curParam[0] == ':') and (curParam[1] != ','):                                curParam =  curParam[0]+','+ curParam[1:]                            curParam = self.varObj.splitStepsVar(curParam)                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                    elif ((suffix == '_min') or (suffix == '_max')) and len(curParam)>0:                        try:                            curParam=self.varObj.inferType(curParam)                            varParams[paramCount]=curParam                        except:                            varParams[paramCount]=[]                                           else:                        varParams[paramCount]=[]                except:                    varParams[paramCount]=[]                                if len(printLst[0])>0:                    if (getVar+suffix) in printLst[0]:                        printDct[getVar+suffix]=str(varParams[paramCount])                paramCount+=1                        if overWrite == 'n':                exec("{}[getVar].append(varParams)".format(varsDict))            elif type(overWrite) == int:                exec("{}[getVar][{}]=varParams".format(varsDict,overWrite))            else:                exec("{}[getVar]=[]".format(varsDict))                exec("{}[getVar].append(varParams)".format(varsDict))        if len(printLst[0])>0:            return printDct    def delete_Line(self):        linesToDelete = self.outputSignalList.curselection()        lineCount = self.outputSignalList.size()        keyFilt = lambda dictKey: dictKey != 'varsToUse'        indexFilt = lambda ind: ind not in linesToDelete        deleteLineKeys = list(filter(keyFilt,self.varObj.makeTrialsDict.keys()))        keepIndex = list(filter(indexFilt,range(lineCount)))        # Debug, must reorganize Offset lists for all deleted        for lineTD in linesToDelete:            offsetFlag=0             maxCount=0            for addOffNumInd in range(len(self.varObj.makeBlockDict['addOffsetNum'])):                if lineTD in self.varObj.makeBlockDict['addOffsetNum'][addOffNumInd]:                    offsetFlag=1            while offsetFlag:                self.clearLastOffset([lineTD])                offsetFlag=0                for addOffNumInd in range(len(self.varObj.makeBlockDict['addOffsetNum'])):                    if lineTD in self.varObj.makeBlockDict['addOffsetNum'][addOffNumInd]:                        offsetFlag=1                maxCount+=1                if maxCount>49:                    print("can't remove all offset ERROR")                    break            # Offset clear does not aniticipate deteled lines so must subtract the appropriate number of             # points from each remaining offset indices             # For each offset index list            for addOffNumInd in range(len(self.varObj.makeBlockDict['addOffsetNum'])):                # for each line index                #also tuples are immutable so may need to over write this                newList=[]                for ind in range(len(self.varObj.makeBlockDict['addOffsetNum'][addOffNumInd])):                    dexVal = self.varObj.makeBlockDict['addOffsetNum'][addOffNumInd][ind]                    # find the lines of lower index being deleted and subtract the number of ticks                    dexVal= dexVal - len([s for s in linesToDelete if s <dexVal])                    newList.append(dexVal)                self.varObj.makeBlockDict['addOffsetNum'][addOffNumInd]=newList        for key in deleteLineKeys:            tempList =[]            for dex in keepIndex:                tempList.append(self.varObj.makeTrialsDict[key][dex])            self.varObj.makeTrialsDict[key]=tempList        tempTuple = self.outputSignalList.get(0,tk.END)        self.outputSignalList.delete(0,tk.END)        self.lineCount = 0        if len(keepIndex)>0:            for dex in keepIndex:                self.outputSignalList.insert(self.lineCount,tempTuple[dex])                self.lineCount +=1        else:            print('All lines deleted')        self.toggleEditButton()    def designFieldsReset(self,resetList=[]):        for varName in resetList:            varType = str(type(eval('self.variables.{}'.format(varName))))            if varType == "<class 'tkinter.StringVar'>":                exec("self.variables.{}.set('')".format(varName))            if varType == "<class 'tkinter.IntVar'>":                exec('self.variables.{}.set(0)'.format(varName))            if varType == "<class 'tkinter.DoubleVar'>":                exec('self.variables.{}.set([])'.format(varName))    def clearBlock(self):        self.varObj.resetDict('makeTrialsDict')        self.varObj.resetDict('makeBlockDict',['varsToUse','getVars'])        for key in list(self.variables.designVariablesDict.keys()):            self.designFieldsReset(self.variables.designVariablesDict[key])        self.lineCount=0        self.toggleEditButton()    def loadBlock(self):        # Open file path        # set self.varObj.tempBlockDict         # set make dicts         # set list and line count and other block fields        try:            tPth = fd.askopenfilename(title ="Select Block File", filetypes = [("Block file", "*.json")])            filePath = Path(tPth)            with open(filePath) as json_file:                self.varObj.tempBlockDict = json.load(json_file)            self.varObj.makeBlockDict=copy.deepcopy(self.varObj.tempBlockDict['makeBlockDict'])            self.varObj.makeTrialsDict=copy.deepcopy(self.varObj.tempBlockDict['makeTrialsDict'])            self.lineCount = 0            self.outputSignalList.delete(0,tk.END)            for listLine in self.varObj.makeBlockDict['outputSignalList']:                self.outputSignalList.insert(self.lineCount,listLine)                self.lineCount +=1            self.setFields(self.varObj.makeBlockDict['getVars'],'self.varObj.makeBlockDict')            self.setFields(self.varObj.makeBlockDict['varsToUse'],'self.varObj.makeBlockDict',0)            self.toggleEditButton()        except:            pass    def setFields(self, fieldsList =[], sourceDict='', mnMxStpsPrbs='n',fieldLine=-1):        if mnMxStpsPrbs=='n':            for varName in fieldsList:                try:                    if fieldLine >=0:                        valToSet = eval("{}['{}'][{}]".format(sourceDict,varName,fieldLine))                    else:                        valToSet = eval("{}['{}']".format(sourceDict,varName))                    valToSet = self.valToString(valToSet)                    exec("self.variables.{}.set(valToSet)".format(varName))                except:                    pass        else:            for varName in fieldsList:                mmspCol = 0                for suffix in ['_min','_max','_steps','_probs']:                    #try:                    valToSet = eval("{}['{}'][{}][{}]".format(sourceDict,varName,mnMxStpsPrbs,mmspCol))                    valToSet = self.valToString(valToSet)                    exec("self.variables.{}{}.set(valToSet)".format(varName,suffix))                    #except:                        #pass                    mmspCol+=1    def valToString(self,valToChange):        if (type(valToChange)==list) or (type(valToChange)==tuple):            if len(valToChange)>1:                codedString =''                strInd = 0                for x in range(len(valToChange)-1):                    codedString=codedString+str(valToChange[x])+','                    strInd+=1                codedString=codedString+str(valToChange[strInd])            elif len(valToChange)==0:                codedString=''            else:                codedString=str(valToChange[0])        else:            codedString = str(valToChange)        return codedString    def editLine(self):        if self.updateFlag==0:            #Toggle button            self.updateFlag=1            self.editLineButton['text']='Update'            self.addLineButton['state']='disabled'            lineToEdit = self.outputSignalList.curselection()            lineToEdit = lineToEdit[0]            self.updateLine = lineToEdit            # set min max steps probs fields to dic values from selected line            self.setFields(self.varObj.makeTrialsDict['varsToUse'],'self.varObj.makeTrialsDict',lineToEdit)            # set channel fields            keyFilt = lambda dictKey: (dictKey != 'varsToUse') and (dictKey not in self.varObj.makeTrialsDict['varsToUse'])            setKeys = list(filter(keyFilt,self.varObj.makeTrialsDict.keys()))            self.setFields(setKeys,'self.varObj.makeTrialsDict','n',lineToEdit)        else:            # Initialize new line text            printDict={}            printList = [['chanToUse','chanToUseType','syncGroup','waveform','amp_max',\            'offset_max','pulseTrainDur_max','rewardStimulus','catchStimulus'],['Ch ',' Type ',' Sync ',' Wave ',' aMax ',' offstMax ',' ptMax ']]            # set single channel values            keyFilt = lambda dictKey: (dictKey != 'varsToUse') and (dictKey not in self.varObj.makeTrialsDict['varsToUse'])            setKeys = list(filter(keyFilt,self.varObj.makeTrialsDict.keys()))            singleFieldsDict = self.getChannelFields('self.varObj.makeTrialsDict',printList,self.updateLine,setKeys)            #Set mnmxprbsstps            mmpsFieldsDict = self.getMinMaxProbsFields('self.varObj.makeTrialsDict',printList,self.updateLine)            for key in setKeys:                if key in printList[0]:                    printDict[key]=singleFieldsDict[key]            for key in list(mmpsFieldsDict.keys()):                if len(mmpsFieldsDict[key])>0:                    printDict[key]=mmpsFieldsDict[key]            feedbackString = ''            for x in range(len(printList[1])):                feedbackString=feedbackString+printList[1][x]+printDict[printList[0][x]]            if printDict['rewardStimulus']=='1':                feedbackString=feedbackString+' _R '            elif printDict['catchStimulus']=='1':                feedbackString=feedbackString+' _C '            searchText =' +Offset'            tempLineString = self.outputSignalList.get(self.updateLine)            textLoc = tempLineString.find(searchText)            if textLoc > -1:                feedbackString = feedbackString + tempLineString[textLoc:]                            self.outputSignalList.delete(self.updateLine)            self.outputSignalList.insert(self.updateLine,feedbackString)            #Clear the fields, reset the flags, reset the add and edit buttons and clear the list selection            self.toggleEditButton()    def toggleEditButton(self):        self.updateFlag=0        self.editLineButton['text']='Edit'        self.addLineButton['state']='normal'        self.outputSignalList.selection_clear(0,tk.END)        self.updateLine = []        self.designFieldsReset(self.variables.designVariablesDict['channelFields'])    def getChannelFields(self,varsDict='',printLst=[[],[]],overWrite='n', specificKeys=[]):        if len(printLst[0])>0:            printDct={}            for printVal in printLst[0]:                printDct[printVal]=[]        else:            printDct={}        for key in specificKeys:            if len(eval('self.variables.{}.get().strip()'.format(key)))>0:                curParam=[]                curParam=eval('self.variables.{}.get().strip()'.format(key))                curParam=curParam.strip('][')                try:                    curParam = int(curParam)                except:                    curParam = []                    print('{} Requires an integar, please edit'.format(key))            else:                curParam = []            if overWrite == 'n':                exec("{}[key].append(curParam)".format(varsDict))            elif type(overWrite) == int:                exec("{}[key][{}]=curParam".format(varsDict,overWrite))            else:                exec("{}[key]=[]".format(varsDict))                exec("{}[key].append(curParam)".format(varsDict))            if len(printLst[0])>0:                if key in printLst[0]:                    try:                        printDct[key]=str(curParam)                    except:                        printDct[key]=''        if len(printLst[0])>0:            return printDct    def addOffsetToLines(self):        linesToOffset = self.outputSignalList.curselection()        offsetNum = len(self.varObj.makeBlockDict['addOffset'])        lineCount = self.outputSignalList.size()        self.getMinMaxProbsFields('self.varObj.makeBlockDict',[[],[]],'n',['addOffset'])        self.designFieldsReset(self.variables.designVariablesDict['offsetFields'])        self.varObj.makeBlockDict['addOffsetNum'].append(linesToOffset)        currentText = self.outputSignalList.get(0,tk.END)        for x in range(lineCount):            if x in linesToOffset:                self.outputSignalList.delete(x)                updateText = currentText[x] + ' +Offset {}'.format(offsetNum)                self.outputSignalList.insert(x,updateText)    def clearLastOffset(self,clearLines =[]):        if not clearLines:            clearOffsetLines = self.outputSignalList.curselection()        else:            clearOffsetLines = clearLines                offsetNum = len(self.varObj.makeBlockDict['addOffset'])        if offsetNum==0:            if not clearLines:                 print('No Offset to Remove')            self.varObj.makeBlockDict['addOffsetNum']=[]            return        lineCount = self.outputSignalList.size()        lineIndex = list(range(offsetNum-1,-1,-1))        lastOffsetInd =[]        # find the last offset with all the addresses        for dex in lineIndex:            lastOffsetInd =dex            for ind in clearOffsetLines:                if ind not in self.varObj.makeBlockDict['addOffsetNum'][dex]:                    lastOffsetInd=[]                    break            if type(lastOffsetInd)==int:                break        if type(lastOffsetInd)!=int or lastOffsetInd<0:            if not clearLines:                print('Selection does not match any one offset')            return        if len(clearOffsetLines) == len(self.varObj.makeBlockDict['addOffsetNum'][lastOffsetInd]):            #selection accounts for entire offset program            tempOffset =[]            tempOffsetNum = []            for dex in range(offsetNum):                if dex != lastOffsetInd:                    tempOffset.append(self.varObj.makeBlockDict['addOffset'][dex])                    tempOffsetNum.append(self.varObj.makeBlockDict['addOffsetNum'][dex])            self.varObj.makeBlockDict['addOffsetNum']=tempOffsetNum            self.varObj.makeBlockDict['addOffset']=tempOffset            # remove text of this offset            lineText =' +Offset {}'.format(lastOffsetInd)            lineTextLen = len(lineText)            for dex in clearOffsetLines:                tempLineString = self.outputSignalList.get(dex)                textLoc = tempLineString.find(lineText)                if textLoc > -1:                    endLoc = textLoc + lineTextLen                    resultString = tempLineString[:textLoc]+tempLineString[endLoc:]                    self.outputSignalList.delete(dex)                    self.outputSignalList.insert(dex,resultString)            # subtract number from lables of higher offsets in other text            if lastOffsetInd < offsetNum -1:                for dex in range(lineCount):                    for ind in range(lastOffsetInd+1,offsetNum,1):                        tempLineString = self.outputSignalList.get(dex)                        lineText =' +Offset {}'.format(ind)                        lineTextLen = len(lineText)                        textLoc = tempLineString.find(lineText)                        if textLoc > -1:                            endLoc = textLoc + lineTextLen                            replacementText =' +Offset {}'.format(ind-1)                            resultString = tempLineString[:textLoc]+replacementText+tempLineString[endLoc:]                            self.outputSignalList.delete(dex)                            self.outputSignalList.insert(dex,resultString)        elif len(clearOffsetLines) <len(self.varObj.makeBlockDict['addOffsetNum'][lastOffsetInd]):            #Otherwise if there are other channels on that offset            tempOffsetNum = []            for dex in self.varObj.makeBlockDict['addOffsetNum'][lastOffsetInd]:                if dex not in clearOffsetLines:                    tempOffsetNum.append(dex)            self.varObj.makeBlockDict['addOffsetNum'][lastOffsetInd]=tempOffsetNum            lineText =' +Offset {}'.format(lastOffsetInd)            lineTextLen = len(lineText)            for dex in clearOffsetLines:                tempLineString = self.outputSignalList.get(dex)                textLoc = tempLineString.find(lineText)                if textLoc > -1:                    endLoc = textLoc + lineTextLen                    resultString = tempLineString[:textLoc]+tempLineString[endLoc:]                    self.outputSignalList.delete(dex)                    self.outputSignalList.insert(dex,resultString)    def duplicateLine(self):        lineToDuplicate = self.outputSignalList.curselection()        lineToDuplicate = lineToDuplicate[0]        lineCount = self.outputSignalList.size()        if self.lineCount != lineCount:            print("Possible Parameter Tracking Issue (line count inconsistent")        self.outputSignalList.insert(tk.END,self.outputSignalList.get(lineToDuplicate))        # duplicate make trial dict lines        keyFilt = lambda dictKey: dictKey != 'varsToUse'        appendKeys = list(filter(keyFilt,self.varObj.makeTrialsDict.keys()))                for key in appendKeys:            self.varObj.makeTrialsDict[key].append(self.varObj.makeTrialsDict[key][lineToDuplicate])        # duplicate offset line in makeBlock by adding new line index to the appropriate offset        #for x in range(len(self.varObj.makeBlockDict['addOffsetNum'])):            #if lineToDuplicate in self.varObj.makeBlockDict['addOffsetNum'][x]:                #self.varObj.makeBlockDict['addOffsetNum'][x].append(lineCount)                  # duplicate offset line in makeBlock by adding new line index to the appropriate offset                       # making a list for 'set equal to' because addoffset num may be tuple        tempSet=list(self.varObj.makeBlockDict['addOffsetNum'])        for x in range(len(tempSet)):            if lineToDuplicate in tempSet[x]:                if type(tempSet[x])==tuple:                    tempSet[x]=list(tempSet[x])                tempSet[x].append(lineCount)        self.varObj.makeBlockDict['addOffsetNum']=tempSet        self.lineCount+=1        self.outputSignalList.selection_clear(0,tk.END)        self.toggleEditButton()class blockDesignGUI:    def __init__(self, master, variables, varObj,parentObj):        self.master = master        self.variables = variables        self.varObj = varObj        self.parentObj = parentObj        self.master.title("Block Design")        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.top = self.master.winfo_toplevel()        self.top.grid()        self.top.rowconfigure(0, weight=1)        self.top.columnconfigure(0, weight=1)        self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)        self.frame.columnconfigure(0, weight=1)        self.frame.columnconfigure(1, weight=1)        self.frame.columnconfigure(2, weight=1)        self.frame.columnconfigure(3, weight=1)        self.blocksLabel = tk.Label(self.frame, text='Blocks ', justify='left', font = self.midFont)        self.blocksLabel.grid(row=0,column=0,sticky=tk.NW)        self.experimentNameLabel = tk.Label(self.frame, text='Experiment Name (optnl):', font=self.smallFont, justify='right')        self.experimentNameEntry = tk.Entry(self.frame, width = 10, font = self.smallFont, justify='right',\            textvariable=self.variables.experimentName)        self.experimentNameLabel.grid(row=0,column=1,sticky=tk.E)        self.experimentNameEntry.grid(row=0,column=2,sticky=tk.W)        self.frame.rowconfigure(1, weight=1)        self.frame.rowconfigure(2, weight=1)        self.frame.rowconfigure(3, weight=1)        self.frame.rowconfigure(4, weight=1)        self.frame.rowconfigure(5, weight=1)        self.frame.rowconfigure(6, weight=1)        self.frame.rowconfigure(7, weight=1)        self.frame.rowconfigure(8, weight=1)        self.frame.rowconfigure(9, weight=1)        self.frame.rowconfigure(10, weight=1)        self.frame.rowconfigure(11, weight=1)        self.blockList = tk.Listbox(self.frame, width = 60, height = 25, listvariable=self.variables.blockList)        self.blockList.grid(row = 1, column = 0, rowspan = 11, columnspan = 3, padx=5, pady=5, sticky = tk.NW)        self.shuffleGroupLabel = tk.Label(self.frame, text='Shuffle Group #:', font=self.smallFont, justify='right')        self.shuffleGroupEntry = tk.Entry(self.frame, width = 2, font = self.smallFont, justify='right',\            textvariable=self.variables.shuffleGroup)        self.shuffleGroupLabel.grid(row = 1, column = 3, sticky = tk.W)        self.shuffleGroupEntry.grid(row = 2, column = 3, sticky = tk.W)        self.shuffleGroupAddButton = tk.Button(self.frame,text = 'Add', anchor = 'center', font =self.smallFont, command=self.setShuffleGroup)        self.shuffleGroupAddButton.grid(row = 3, column = 3, sticky = tk.W)        self.moveUpButton = tk.Button(self.frame,text = 'Move Up', anchor = 'center', font =self.midFont, command = self.moveUpBlock)        self.moveUpButton.grid(row = 4, column = 3, sticky = tk.W)        self.moveDownButton = tk.Button(self.frame,text = 'Move Down', anchor = 'center', font =self.midFont, command = self.moveDownBlock)        self.moveDownButton.grid(row = 5, column = 3, sticky = tk.W)        self.duplicateButton = tk.Button(self.frame,text = 'Duplicate', anchor = 'center', font =self.midFont, command = self.duplicateBlock)        self.duplicateButton.grid(row = 6, column = 3, sticky = tk.W)        self.editButton = tk.Button(self.frame,text = 'Edit', anchor = 'center', font =self.midFont, command=self.editBlock)        self.editButton.grid(row = 7, column = 3, sticky = tk.W)        self.loadAllButton = tk.Button(self.frame,text = 'Load All', anchor = 'center', font =self.midFont, command=self.loadBlockDesign)        self.loadAllButton.grid(row = 8, column = 3, sticky = tk.W)        self.deleteButton = tk.Button(self.frame,text = 'Delete', anchor = 'center', font =self.midFont, command=self.deleteBlock)        self.deleteButton.grid(row = 9, column = 3, sticky = tk.W)        self.saveButton = tk.Button(self.frame,text = 'Save (only)', anchor = 'center', font =self.midFont, command=self.saveBlockDesign)        self.saveButton.grid(row = 10, column = 3, sticky = tk.W)        self.saveAndGenButton = tk.Button(self.frame,text = 'Save and\nGenerate', anchor = 'center', font =self.midFont, command=self.saveAndGen)        self.saveAndGenButton.grid(row = 11, column = 3, sticky = tk.W)    def setShuffleGroup(self):        shuffleNum = self.variables.shuffleGroup.get()        try:            shuffleNum=int(shuffleNum)        except:            print('Enter An Integar')            return        if self.blockList.size()==0:            print("There's Nothing Here to Shuffle, Silly!")            return        else:            blockNumber = self.blockList.curselection()            blockNumber=blockNumber[0]            blkName= self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]            self.varObj.blockDesignDict['shuffleGroup'][blkName]=shuffleNum            tempString = self.blockList.get(blockNumber)            shufIND= tempString.find(' ShuffleGrp ')            tempString= tempString[:shufIND]            tempString=tempString+' ShuffleGrp '+str(shuffleNum)            self.blockList.delete(blockNumber)            self.blockList.insert(blockNumber,tempString)            self.varObj.blockDesignDict['blockList']=self.blockList.get(0,tk.END)    def moveUpBlock(self):        if self.blockList.size()<2:            print("There's No Order to Change, Silly!")        else:            blockNumber = self.blockList.curselection()            blockNumber=blockNumber[0]            if blockNumber < 1:                print('This Block is Already First, Silly!')                return            previousString = self.blockList.get(blockNumber-1)            moveString=self.blockList.get(blockNumber)            self.blockList.delete(blockNumber-1)            self.blockList.insert(blockNumber-1,moveString)            self.blockList.delete(blockNumber)            self.blockList.insert(blockNumber,previousString)            self.varObj.blockDesignDict['blockList']=self.blockList.get(0,tk.END)            previousName = self.varObj.blockDesignDict['blockNumList'][str(blockNumber-1)]            moveName = self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]            self.varObj.blockDesignDict['blockNumList'][str(blockNumber-1)]=moveName            self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]=previousName    def moveDownBlock(self):        if self.blockList.size()<2:            print("There's No Order to Change, Silly!")        else:            blockNumber = self.blockList.curselection()            blockNumber=blockNumber[0]            if blockNumber == (self.blockList.size()-1):                print('This Block is Already Last, Silly!')                return            previousString = self.blockList.get(blockNumber+1)            moveString=self.blockList.get(blockNumber)            self.blockList.delete(blockNumber+1)            self.blockList.insert(blockNumber+1,moveString)            self.blockList.delete(blockNumber)            self.blockList.insert(blockNumber,previousString)            self.varObj.blockDesignDict['blockList']=self.blockList.get(0,tk.END)            previousName = self.varObj.blockDesignDict['blockNumList'][str(blockNumber+1)]            moveName = self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]            self.varObj.blockDesignDict['blockNumList'][str(blockNumber+1)]=moveName            self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]=previousName    def duplicateBlock(self):        if self.blockList.size()>0:            blockNumber = self.blockList.curselection()            blockNumber=blockNumber[0]            listSize = self.blockList.size()            dictSize = len(self.varObj.blockDesignDict['blockNumList'].values())            if listSize != dictSize:                print('Dict may be corrupt: Save, Check and Restart')                return            oldName = self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]            oldString = self.blockList.get(blockNumber)            blockName =self.varObj.blockNameIncrement(oldName,\            list(self.varObj.blockDesignDict['blockNumList'].values()),1)            nameIndex = oldString.find(oldName)            nameEndIndex = len(oldName) + nameIndex            feedbackString =oldString[:nameIndex] + blockName + oldString[nameEndIndex:]            self.blockList.insert(tk.END,feedbackString)            self.varObj.blockDesignDict['blockList']=self.blockList.get(0,tk.END)            self.varObj.blockDesignDict['blockNumList'][str(dictSize)]=blockName            self.varObj.blockDesignDict['shuffleGroup'][blockName]=\            copy.copy(self.varObj.blockDesignDict['shuffleGroup'][oldName])            self.varObj.blockDesignDict['blocks'][blockName]=\            copy.deepcopy(self.varObj.blockDesignDict['blocks'][oldName])    def deleteBlock(self):        if self.blockList.size()<1:            print("Seriously? There's nothing here!")            return        else:            blockNumber = self.blockList.curselection()            blockNumber=blockNumber[0]                        blockName = self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]            if blockNumber == len(self.varObj.blockDesignDict['blockNumList'].values())-1:                del self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]            else:                keyNum = len(self.varObj.blockDesignDict['blockNumList'].values())                del self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]                for key in range(blockNumber+1,keyNum,1):                     self.varObj.blockDesignDict['blockNumList'][str(key-1)]=self.varObj.blockDesignDict['blockNumList'].pop(str(key))            self.blockList.delete(blockNumber)            self.varObj.blockDesignDict['blockList']=self.blockList.get(0,tk.END)            del self.varObj.blockDesignDict['shuffleGroup'][blockName]            del self.varObj.blockDesignDict['blocks'][blockName]    def editBlock(self):        if self.blockList.size()<1:            print("There is nothing here to edit")            return        else:            blockNumber = self.blockList.curselection()            blockNumber=blockNumber[0]            blockName = self.varObj.blockDesignDict['blockNumList'][str(blockNumber)]            self.parentObj.clearBlock()            self.varObj.makeBlockDict=copy.deepcopy(\                self.varObj.blockDesignDict['blocks'][blockName]['makeBlockDict'])            self.varObj.makeTrialsDict=copy.deepcopy(\                self.varObj.blockDesignDict['blocks'][blockName]['makeTrialsDict'])            self.parentObj.lineCount = 0            self.parentObj.outputSignalList.delete(0,tk.END)            for listLine in self.varObj.makeBlockDict['outputSignalList']:                self.parentObj.outputSignalList.insert(self.parentObj.lineCount,listLine)                self.parentObj.lineCount +=1            self.parentObj.setFields(self.varObj.makeBlockDict['getVars'],'self.varObj.makeBlockDict')            self.parentObj.setFields(self.varObj.makeBlockDict['varsToUse'],'self.varObj.makeBlockDict',0)            self.parentObj.toggleEditButton()            self.deleteBlock()    def saveBlockDesign(self):        experiment = self.variables.experimentName.get()        self.varObj.blockDesignDict['experimentName']=experiment        tStamp=datetime.datetime.now().strftime("_%Y_%m_%d_%H%M%S")        saveName=experiment+tStamp        saveDirectory= self.varObj.sesVarDict['dirPath'] / 'experimentParams'         self.varObj.blockDesignDict['blockList']=self.blockList.get(0,tk.END)        self.varObj.saveJSONDict(self.varObj.blockDesignDict,saveDirectory,saveName)        if taskVar.sesVarDict['sessionOn']==0:            fnList=[]            fnList.append(str(saveDirectory / saveName ) + '.json')            self.varObj.experimentDesignFiles['filenames'] = []            self.varObj.experimentDesignFiles['filenames'] = fnList        else:            fnList= str(saveDirectory / saveName ) + '.json'            self.varObj.experimentDesignFiles['filenames'].append(fnList)        print('{} saved to {}'.format(experiment,saveDirectory))    def loadBlockDesign(self):        try:            tPth = fd.askopenfilename(title ="Select Experiment File", filetypes = [("Experiment file", "*.json")])            filePath = Path(tPth)            with open(filePath) as json_file:                self.varObj.tempBlockDesignDict = json.load(json_file)            self.varObj.blockDesignDict=copy.deepcopy(self.varObj.tempBlockDesignDict)                        self.blockList.delete(0,tk.END)            for listLine in range(len(self.varObj.blockDesignDict['blockList'])):                self.blockList.insert(listLine,self.varObj.blockDesignDict['blockList'][listLine])            self.variables.experimentName.set(self.varObj.blockDesignDict['experimentName'])        except:            pass    def saveAndGen(self):        self.saveBlockDesign()        self.varObj.compileAllTrialVaribles()        self.variables.det_buttonText.set('Run Task')    def close_windows(self):        self.master.destroy()        class mainFigure():    #    def __init__(self,varObj,mainGUI,parent,updateDtMs=40):        #        self.varObj=varObj        self.mainGUI=mainGUI        self.variables=mainGUI.variables        self.master=parent        self.calOverride=False                self.plotYMin=[]        self.plotYMax=[]        self.plotDataLen=0        self.plotTimeAxis=[]        self.plotDataChan=None        self.outChan=None        if self.varObj.sesVarDict['sessionOn']==1:            self.curIntNow=self.varObj.curInt        else:            self.curIntNow=0 # Sample current time from seprate string to prevent roll while in-use locally        self.getPlotYRange() # sets self.plotYMin, self.plotYMax        if self.calOverride:            self.plotDataChan=2 #This is the address channel data is alwasy written to in the smaller data struct during calibration            self.dataToPlot,_,self.dataIndsTuple,self.plotTimeAxis,self.plotDataLen =self.getPlotData(dataChan=self.plotDataChan)        else:            self.dataToPlot,self.plotDataChan,self.dataIndsTuple,self.plotTimeAxis,self.plotDataLen =self.getPlotData()        #Testing / debugging functions        #self.someDataL, self.someTimeL=self.genFunnyData(10001)        #self.someDataR, self.someTimeR=self.getFunnyRotation(600*2000)                self.updateDt=updateDtMs        self.updateIncs=int(self.updateDt*(1/1000)*varObj.sesVarDict['sampRate'])        self.turnOff=True        self.blockOnDraw=False        self.fig=plt.figure()        self.canvas = FigureCanvasTkAgg(self.fig, master = self.master)        self.cid = self.canvas.mpl_connect("draw_event", self.on_draw)        if (self.plotDataChan==None) or (self.plotDataChan in [3,4,7,8,9,10]) or (self.calOverride):            self.iniPlot()        else:            self.iniPolarPlot()        #self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)        # we are going to grid this from the calling window        #Button commands:        # self.startSpinGraph        # self.stopGraph        # lambda: self.switchPlot('line')        # lambda: self.switchPlot('polar')    def iniPolarPlot(self):        self.rVals=np.arange(0,1,0.2)        self.theta=np.zeros(5)        #self.dataMapIn=np.arange(4096)        self.dataMapOut=np.linspace(0,2*np.pi,num=4096, endpoint=False)        #self.dataTick=0                    #Variables for self-running debug helper funcs        #self.moveTick=self.updateIncs        #self.someTime=self.someTimeR        #self.someData=self.someDataR        #self.timeLen=len(self.someTime)        self.plotType='polar'        #self.fig = plt.figure()        self.fig.clear()        self.ax = self.fig.add_subplot(111,projection='polar')        self.ax.set_title("Rotation Angle")        self.ax.set_rmax(1)        self.ax.set_yticklabels([])        self.ax.yaxis.grid(visible=False)        self.ax.set_theta_zero_location('N')        self.dLine, =self.ax.plot(self.theta,self.rVals,lw=1.5,color='red', animated=True)        #Set up canvas        #self.canvas = FigureCanvasTkAgg(self.fig, master = self.master)        #self.cid = canvas.mpl_connect("draw_event", self.on_draw)        self.blockOnDraw=True        self.canvas.draw()        self.canvas.flush_events()        self.blockOnDraw=False        self.ax.add_line(self.dLine)        self.background = self.canvas.copy_from_bbox(self.ax.bbox)          def switchPlot(self):#,pltType=None):        #if pltType !=None:        if self.varObj.sesVarDict['sessionOn']==1:            self.curIntNow=self.varObj.curInt        else:            self.curIntNow=0                self.getPlotYRange()        if self.calOverride:            self.plotDataChan=2 #This is the address channel data is alwasy written to in the smaller data struct during calibration            self.dataToPlot,_,self.dataIndsTuple,self.plotTimeAxis,self.plotDataLen =self.getPlotData(dataChan=self.plotDataChan,checkNow=1)        else:            self.dataToPlot,self.plotDataChan,_,self.plotTimeAxis,self.plotDataLen =self.getPlotData(checkNow=1)        #        wasRunning=False        if not self.turnOff:            self.turnOff=True            self.master.after_cancel(self.afterId)            self.canvas.flush_events()            wasRunning=True            #        if (self.plotDataChan==None) or (self.plotDataChan in [3,4,7,8,9,10]) or (self.calOverride):# or (self.varObj.sesVarDict['sessionOn']==1 and :            self.iniPlot()        else:            self.iniPolarPlot()                    # if pltType=='line':        #     self.iniPlot()        # else:        #     self.iniPolarPlot()        if wasRunning:            #self.startSpinGraph()            self.afterId=self.master.after(self.updateDt,self.startSpinGraph)    def iniPlot(self):        #        #self.fig = plt.figure()        #self.someTime=self.someTimeL # Vars for self-running debugging functions        #self.someData=self.someDataL        #self.timeLen=len(self.someTime)        #self.timeAccum=self.someTime[:]        self.plotType='line'        self.fig.clear()        self.ax = self.fig.add_subplot(111)        self.ax.set_title("Live Data")        self.ax.set_xlabel("Time [s]")        #self.ax.set_ylabel("Stuff")        #self.ax.set_xlim([min(self.someTime),max(self.someTime)])        #self.ax.set_ylim([-40,40])        self.ax.set_xlim([self.plotTimeAxis[0],self.plotTimeAxis[-1]])        self.ax.set_ylim([self.plotYMin,self.plotYMax])        self.ax.yaxis.grid(which="major", color='gray', linestyle='--', linewidth=.75)        self.ax.xaxis.grid(which="major", color='gray', linestyle=':', linewidth=.75)        self.dLine, = self.ax.plot(self.plotTimeAxis, self.dataToPlot,ls='-',lw=1.5,color='#01307d', animated=True)        #Set up canvas        #self.canvas = FigureCanvasTkAgg(self.fig, master = self.master)        #self.cid = canvas.mpl_connect("draw_event", self.on_draw)        self.blockOnDraw=True        self.canvas.draw()        self.canvas.flush_events()        self.blockOnDraw=False                self.ax.add_line(self.dLine)        self.background = self.canvas.copy_from_bbox(self.ax.bbox)    def on_draw(self,event):        cv = self.canvas        if (self.blockOnDraw==False) and event is not None:            if event.canvas != cv:                return        self.background = self.canvas.copy_from_bbox(self.ax.bbox)        #self.background=self.canvas.copy_from_bbox(self.ax.bbox)        #print('Just Drew')    def getNextData(self):        #Debugging helper function        #self.someData, self.timeAccum = pts.genFunnyData(self.timeLen,self.timeAccum[-1]+self.axTimeDt)        self.someData, self.timeAccum = self.genFunnyData(self.timeLen,self.timeAccum[-1]+.1)    def updateArtist(self,axA,axB):        self.dLine.set_data(axA,axB)        self.canvas.restore_region(self.background)        self.ax.draw_artist(self.dLine)        self.canvas.blit(self.ax.bbox)        self.canvas.flush_events()    def startSpinGraph(self):        if self.turnOff:            self.turnOff=False            self.spinGraph()        else:            self.stopGraph()            self.afterId=self.master.after(self.updateDt,self.startSpinGraph)    def tickPolar(self):        #Debugging helper function        self.theta[:]=self.dataMapOut[self.someData[self.dataTick]]        if self.dataTick <=self.timeLen-1-self.moveTick:            self.dataTick+=self.moveTick        else:            self.dataTick=np.mod(self.dataTick+self.moveTick,self.timeLen-1)    def spinGraph(self):        if not self.turnOff:            self.curIntNow=self.varObj.curInt            if self.curIntNow<self.varObj.sesData.shape[0]:                if self.plotType=='line':                    #self.getNextData()  #Debugging helper function                    self.dataToPlot,_,self.dataIndsTuple,_,_ =self.getPlotData(dataChan=self.plotDataChan)                    self.updateArtist(self.plotTimeAxis,self.dataToPlot) #(self.someTime,self.someData)                else:                    #self.tickPolar()   #Debugging helper function                    self.dataToPlot,_,self.dataIndsTuple,_,_ =self.getPlotData(dataChan=self.plotDataChan)                    self.theta[:]=self.dataMapOut[self.dataToPlot]                    self.updateArtist(self.theta,self.rVals)                self.afterId=self.master.after(self.updateDt,self.spinGraph)            else:                self.stopGraph()        #if not self.turnOff:        #   self.afterId=self.master.after(self.updateDt,self.spinGraph)    def stopGraph(self):        self.turnOff=True        self.master.after_cancel(self.afterId)        self.canvas.flush_events()        try:            self.master.after_cancel(self.afterId)        except:            pass        #self.varObj.sesData        #self.varObj.sesVarDict['maxDur']        #taskVar.sampleDt = 1.0/float(taskVar.sesVarDict['sampRate'])        #self.plotSeconds = tk.StringVar()        #self.plotMinMax = tk.StringVar()     def translateChannelValues(self,chnlCode=None,aryLnth=None,aryLocation=None):        # This is fully dependent of Teensy coding and the way that the final three data streams encode information        #         if chnlCode==None:            return None        if aryLnth==None:            if aryLocation!=None and type(aryLocation)==tuple:                aryLnth=aryLocation[1]-aryLocation[0]            else:                aryLnth=self.varObj.sesData.shape[0]        if aryLocation==None:            if aryLnth<self.varObj.sesData.shape[0]:                #aryLocation=(self.varObj.curInt-aryLnth+1,self.varObj.curInt+1)                aryLocation=(self.curIntNow-aryLnth+1,self.curIntNow+1)                #self.varObj.sesData[taskVar.curInt-plotArryLen+1:taskVar.curInt+1,1].shape            else:                aryLocation=(0,aryLnth+1)        chanDType=chnlCode[0]        chanDataCol=chnlCode[1]        dataMultiple=chnlCode[2]        muxMessage=self.varObj.sesData[aryLocation[0]:aryLocation[1],chanDataCol]        muxMessage=np.int32(np.floor(muxMessage/dataMultiple))        if chanDType==0:            transLatedMessage=np.mod(muxMessage,10000)        else:            transLatedMessage=np.mod(muxMessage,10)        return transLatedMessage,aryLocation    def getChannelData(self,chnlCode=None,aryLnth=None,aryLocation=None):        # This is fully dependent of Teensy coding and the way that the final three data streams encode information        #         if chnlCode==None:            return None        if aryLnth==None:            if aryLocation!=None and type(aryLocation)==tuple:                aryLnth=aryLocation[1]-aryLocation[0]            else:                aryLnth=self.varObj.sesData.shape[0]        if aryLocation==None:            if aryLnth<self.varObj.sesData.shape[0]:                #aryLocation=(self.varObj.curInt-aryLnth+1,self.varObj.curInt+1)                aryLocation=(self.curIntNow-aryLnth+1,self.curIntNow+1)                #self.varObj.sesData[taskVar.curInt-plotArryLen+1:taskVar.curInt+1,1].shape            else:                aryLocation=(0,aryLnth+1)        chanDataSeg=np.int32(self.varObj.sesData[aryLocation[0]:aryLocation[1],chnlCode])        return chanDataSeg,aryLocation    def getOutChannel(self,reqChan=None):        if reqChan==None:            cps= self.variables.plotType.get()            if cps!=9 and cps!=10:                return None,[]            else:                cps=cps-9        else:            cps=reqChan        cpsNum=self.varObj.inferType(self.variables.plotOutputNumber.get())        if type(cpsNum)==str or type(cpsNum)==list:            return None,[]        return cpsNum, cps        #    def getPlotData(self,dataChan=None, checkNow=None):        #make an x axis, grab data        #return pltData,pltDChan,dataInds,pltTimeVector,plotArryLen         pltData=[]        pltDChan=[]        dataInds=[]        if checkNow!=None or self.plotDataLen==0: #len(self.plotTimeAxis)==0: #Changed for speed            #            pltTimeSpan=self.varObj.inferType(self.variables.plotSeconds.get())            if (type(pltTimeSpan)!=int and type(pltTimeSpan)!=float) or pltTimeSpan<=0:                pltTimeSpan=5.0            plotArryLen=round(np.ceil(self.varObj.sesVarDict['sampRate']*pltTimeSpan))+1                #pltTimeVector = np.arange(plotArryLen)/self.varObj.sesVarDict['sampRate']            pltTimeVector=np.linspace(-1*pltTimeSpan,0,num=plotArryLen)            #self.plotDataLen=plotArryLen            #self.plotTimeAxis=pltTimeVector        else:            plotArryLen=self.plotDataLen            pltTimeVector=self.plotTimeAxis        if dataChan==None:            curPltSelection= self.variables.plotType.get() #This is the 'rare' IntVar object, no coversion            pltDChan=curPltSelection        else:            curPltSelection=dataChan            pltDChan=curPltSelection        if curPltSelection==0:            pltDChan=None            dataInds=None            pltData=np.zeros(plotArryLen)            return pltData,pltDChan,dataInds,pltTimeVector,plotArryLen             #print('returned')        if self.varObj.sesVarDict['sessionOn']==1:            #            # if curPltSelection==0:            #     pltDChan=None            #     dataInds=None            #     pltData=np.zeros(plotArryLen)            #     return pltData,pltDChan,dataInds,pltTimeVector,plotArryLen             if curPltSelection==9 or curPltSelection==10:                chnTyp=curPltSelection-9                if checkNow!=None or self.outChan==None:                    outChn,_=self.getOutChannel(chnTyp)                    self.outChan=outChn                else:                    outChn=self.outChan                if outChn==None:                    pltDChan=None                    dataInds=None                    pltData=np.zeros(plotArryLen)                    #return pltData,pltDChan,dataInds,pltTimeVector,plotArryLen                    print('returned')                try:                    sesD1,sesD2=self.variables.outValsDict[chnTyp][outChn-1]                except:                    pltDChan=None                    dataInds=None                    pltData=np.zeros(plotArryLen)                    #return pltData,pltDChan,dataInds,pltTimeVector,plotArryLen                    print('returned')                                if plotArryLen>self.curIntNow: #self.varObj.curInt:                    pltData=np.zeros(plotArryLen)                    #tmpPltD,dataInds=self.translateChannelValues((chnTyp,sesD1,sesD2),aryLocation=(0,self.varObj.curInt+1))                    tmpPltD,dataInds=self.translateChannelValues((chnTyp,sesD1,sesD2),aryLocation=(0,self.curIntNow+1))                    pltData[(-1*len(tmpPltD)):]=tmpPltD                else:                    pltData,dataInds=self.translateChannelValues((chnTyp,sesD1,sesD2),aryLnth=plotArryLen)            elif curPltSelection==3:                if plotArryLen>self.curIntNow: #self.varObj.curInt:                    pltData=np.zeros(plotArryLen)                    #tmpPltD,dataInds=self.getChannelData(curPltSelection,aryLocation=(0,self.varObj.curInt+1))                    tmpPltD,dataInds=self.getChannelData(curPltSelection,aryLocation=(0,self.curIntNow+1))                    pltData[(-1*len(tmpPltD)):]=tmpPltD                    pltData=pltData/100.0  # Do this to decode the calibrate scale value                else:                    pltData,dataInds=self.getChannelData(curPltSelection,aryLnth=plotArryLen)            elif curPltSelection==5:                #pltData=int(self.varObj.sesData[self.varObj.curInt,5])                pltData=int(self.varObj.sesData[self.curIntNow,5])                #dataInds=(self.varObj.curInt,self.varObj.curInt)                dataInds=(self.curIntNow,self.curIntNow)            else:                # All other cases just grab data                if plotArryLen>self.curIntNow: #self.varObj.curInt:                    pltData=np.zeros(plotArryLen)                    #tmpPltD,dataInds=self.getChannelData(curPltSelection,aryLocation=(0,self.varObj.curInt+1))                    tmpPltD,dataInds=self.getChannelData(curPltSelection,aryLocation=(0,self.curIntNow+1))                    pltData[(-1*len(tmpPltD)):]=tmpPltD                else:                    pltData,dataInds=self.getChannelData(curPltSelection,aryLnth=plotArryLen)        else:            dataInds=None            pltData=np.zeros(plotArryLen)        return pltData,pltDChan,dataInds,pltTimeVector,plotArryLen     def genFunnyData(self,pltAryLn=None,pltStrt=None):        funnySin=[]        pltTimeVector=[]        if pltAryLn!=None:            funnySin=np.zeros(pltAryLn)            pltTimeVector=np.arange(pltAryLn)/self.varObj.sesVarDict['sampRate']            if pltStrt!=None:                pltTimeVector+=(pltStrt-pltTimeVector[-1])            funnySin=(np.sin(pltTimeVector*2*math.pi*8)*8)+(np.sin((pltTimeVector+11)*2*math.pi*2.1)*30)            # Do the data thing        return funnySin, pltTimeVector                def getPlotYRange(self):        #        q=self.variables.plotMinMax.get()        q=q.split(',')        for s in ' []':            for sq in range(len(q)):                q[sq]=q[sq].replace(s,'')        pltYMin=[]        pltYMax=[]        for s in range(len(q)):            q[s]=self.varObj.inferType(q[s])        q = [ s for s in q if type(s)!=str]        q.sort()        if len(q)!=2:            if max(q)!=0:                pltYMax=max(q)            else:                pltYMax=4096            if min(q)!=pltYMax:                pltYMin=min(q)            else:                pltYMin=0        else:            pltYMax=q[1]            pltYMin=q[0]        self.plotYMin=pltYMin        self.plotYMax=pltYMax    def getFunnyRotation(self,pltAryLn=None,):        rateLims=[-2,5]        cmPerRotation=39        outThet=[]        pltTimeVector=[]        rateSmth=int(.5*self.varObj.sesVarDict['sampRate'])        if np.mod(rateSmth,2)==0:            rateSmth+=1        rateChangePerSec=.25        #rateSet=np.linspace(rateLims[0],rateLims[1],rateRes)        tMinus1Seed=0        noiseVals=[-5,-4,-3,-2,-1,0,1,2,3,4,5]        ns=norm.pdf(list(range(-5,6,1)),scale=1)        if pltAryLn!=None:            pltTimeVector=np.arange(pltAryLn)/self.varObj.sesVarDict['sampRate']                stripSize=int(round(self.varObj.sesVarDict['sampRate']*rateChangePerSec))        zeroPad=np.mod(pltAryLn,stripSize)        roughAccelVals=np.zeros(pltAryLn)        roughAccelVals[:zeroPad]=tMinus1Seed        for sAc in [s+zeroPad for s in range(0,stripSize*int(np.floor(pltAryLn/stripSize)),stripSize)]:            tM1=tMinus1Seed+(np.random.choice([0,1],p=[.85,.15])* gumbel_r.rvs(size=1))            if tM1>rateLims[1]:                tM1=rateLims[1]            elif tM1<rateLims[0]:                tM1=rateLims[0]            roughAccelVals[sAc:sAc+stripSize]=tM1        #z=signal.savgol_filter(roughAccelVals, window_length=rateSmth, polyorder=3, mode="nearest")        #zv = z.cumsum()/1000        zv = roughAccelVals.cumsum()/1000        #posW=zv.cumsum()/1000        #posW=posW+(0-posW[0])        posW=signal.savgol_filter(zv, window_length=rateSmth, polyorder=3, mode="nearest")        outThet=np.zeros(pltAryLn,dtype=int)        for s in range(pltAryLn):            revs=posW[s]/39.9 #Numper of cm in wheel            outThet[s]=int(round((np.mod(revs,1))*4095))        noizzE=np.random.choice(noiseVals,size=pltAryLn,p=ns)        #testme=outThet[:]+noizzE        outThet=outThet+noizzE        for s in range(pltAryLn):            if outThet[s]>4095 or outThet[s]<0:            #if testme[s]>4095 or testme[s]<0:                outThet[s]=np.mod(outThet[s],4095)                #testme[s]=np.mod(testme[s],4095)        return outThet, pltTimeVectorclass testPiezoGUI():    #    def __init__(self, master, variables,varObj,calWin):        self.master = master        self.master.title("Test Sensor")        self.variables = variables        self.varObj=varObj        self.calibratePiezo=calWin        self.frame = tk.Frame(self.master)        self.midFont = tkFont.Font(family='Helvetica', size=14, weight = 'bold')        self.smallFont = tkFont.Font(family='Helvetica', size=10, weight = 'normal')        self.top = self.master.winfo_toplevel()        self.top.grid()        self.top.rowconfigure(0, weight=1)         self.top.columnconfigure(0, weight=1)        self.frame.grid(sticky=tk.N+tk.S+tk.E+tk.W)        self.frame.rowconfigure(0, weight=1)         self.frame.columnconfigure(0, weight=1)        self.frame.columnconfigure(1, weight=1)        self.positionUmLabel = tk.Label(self.frame, text='Position [um]', \            justify='right', font=self.smallFont)        self.positionUmLabel.grid(row=0,column=0)        self.positionUmEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4, \            textvariable=self.variables.cal_curPositionUm)        self.positionUmEntry.grid(row=0,column=1, sticky=tk.W)        self.frame.rowconfigure(1, weight=1)         self.pointsNumLabel = tk.Label(self.frame, justify='center', font=self.smallFont, textvariable=self.variables.cal_numPointsSet)        self.pointsNumLabel.grid(row=1,column=0,columnspan=2)        self.frame.rowconfigure(2, weight=1)        self.clearButton = tk.Button(self.frame, text='Clear Last', font=self.midFont, justify='center', command=self.clearLastPosition)        self.clearButton.grid(row=2,column=0, columnspan=1, sticky=tk.N+tk.S+tk.E+tk.W)          self.clearAllButton = tk.Button(self.frame, text='Clear All', font=self.midFont, justify='center', command=self.clearAllPositions)        self.clearAllButton.grid(row=2,column=1, columnspan=1, sticky=tk.N+tk.S+tk.E+tk.W)                 self.frame.rowconfigure(3, weight=1)        self.setButton = tk.Button(self.frame, text='Set', font=self.midFont, justify='center', command=self.setPosition)        self.setButton.grid(row=3,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)            self.frame.rowconfigure(4, weight=1)        self.startStopButton = tk.Button(self.frame, font=self.midFont, justify='center', command=self.startStop, textvariable=self.variables.cal_testStartStop)        self.startStopButton.grid(row=4,column=0, columnspan=2, sticky=tk.N+tk.S+tk.E+tk.W)        self.toggleStartStop()        self.frame.rowconfigure(5, weight=1)        self.testWaveLabel = tk.Label(self.frame, justify='center', text='Test Wave', font=self.midFont)        self.testWaveLabel.grid(row=5,column=0,columnspan=2)        self.frame.rowconfigure(6, weight=1)        self.testWaveChannelLabel = tk.Label(self.frame, justify='right', font=self.smallFont, text='Channel')        self.testWaveChannelLabel.grid(row=6,column=0)                self.testWaveChannelEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_testChannel)        self.testWaveChannelEntry.grid(row=6,column=1, sticky=tk.W)        self.frame.rowconfigure(7, weight=1)        self.testWaveAmpLabel = tk.Label(self.frame, justify='right', font=self.smallFont, text='Amplitude')        self.testWaveAmpLabel.grid(row=7,column=0)                self.testWaveAmpEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_testAmp)        self.testWaveAmpEntry.grid(row=7,column=1, sticky=tk.W)                self.frame.rowconfigure(8, weight=1)        self.testWavePulseDurLabel = tk.Label(self.frame, justify='right', font=self.smallFont, text='Pulse Width')        self.testWavePulseDurLabel.grid(row=8,column=0)                self.testWavePulseDurEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_testPulseDur)        self.testWavePulseDurEntry.grid(row=8,column=1, sticky=tk.W)           self.frame.rowconfigure(9, weight=1)        self.testWavePulseUpDurLabel = tk.Label(self.frame, justify='right', font=self.smallFont, text='Pulse Up Width')        self.testWavePulseUpDurLabel.grid(row=9,column=0)                self.testWavePulseUpDurEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_testPulseUpDur)        self.testWavePulseUpDurEntry.grid(row=9,column=1, sticky=tk.W)                           self.frame.rowconfigure(10, weight=1)        self.testWaveInterPulseLabel = tk.Label(self.frame, justify='right', font=self.smallFont, text='Interpulse Width')        self.testWaveInterPulseLabel.grid(row=10,column=0)                self.testWaveInterPulseEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_testInterPulseDur)        self.testWaveInterPulseEntry.grid(row=10,column=1, sticky=tk.W)             self.frame.rowconfigure(11, weight=1)        self.testWaveShapeLabel = tk.Label(self.frame, justify='right', font=self.smallFont, text='Wave Shape: \n(0=sqr, 2=AsymCos)')        self.testWaveShapeLabel.grid(row=11,column=0)                self.testWaveShapeEntry = tk.Entry(self.frame, font=self.smallFont, justify='right', width=4,\            textvariable=self.variables.cal_testWaveShape)        self.testWaveShapeEntry.grid(row=11,column=1, sticky=tk.W)        self.frame.rowconfigure(12, weight=1)           self.testWaveEndPulseButton = tk.Button(self.frame, text='End Pulse', font=self.midFont, justify='center', state=tk.DISABLED, command=self.endPulse)        self.testWaveEndPulseButton.grid(row=12,column=0, columnspan=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.testWavePulseButton = tk.Button(self.frame, text='Pulse', font=self.midFont, justify='center', command=self.startPulse)        self.testWavePulseButton.grid(row=12,column=1, columnspan=1, sticky=tk.N+tk.S+tk.E+tk.W)        self.togglePulseButtons()        self.togglePointsList()    def clearAllPositions(self):        if len(self.variables.cal_sensorValuesList)>0:            self.variables.cal_sensorValuesList=[]            self.togglePointsList()        else:            self.togglePointsList()            return            def clearLastPosition(self):        if len(self.variables.cal_sensorValuesList)>0:            self.variables.cal_sensorValuesList=self.variables.cal_sensorValuesList[:-1]            self.togglePointsList()        else:            self.togglePointsList()            return    def setPosition(self):        if self.varObj.sesVarDict['sessionOn']==1 and self.varObj.sesVarDict['taskType']=='monitorOnly':            try:                sampInput=int(6+self.varObj.cal_Input)                curSampInt=taskVar.curInt                sampLen=int(self.varObj.sesVarDict['sampRate']*.5) # Arbitrary Half second sample length                if curSampInt<sampLen:                    print('Wait a moment for samples and try again')                    return                sampleArray= self.varObj.sesData[curSampInt-sampLen+1:curSampInt+1,sampInput]                enteredPosition= self.varObj.inferType(self.variables.cal_curPositionUm.get())                sampledMean=np.mean(sampleArray)                self.variables.cal_sensorValuesList.append((enteredPosition,sampledMean))                self.togglePointsList()                print('{} Point Set To {}'.format(str(enteredPosition),str(sampledMean)))            except:                self.togglePointsList()                print('Not set')        else:            print('Nothing to sample')            self.togglePointsList()               def togglePointsList(self):        if len(self.variables.cal_sensorValuesList)>0:            self.variables.cal_numPointsSet.set('{} Points Set'.format(str(len(self.variables.cal_sensorValuesList))))        else:            self.variables.cal_numPointsSet.set('… Points Set')    def startStop(self):        if self.variables.calibrationActive==True:            self.toggleStartStop()            return        else:            self.calibratePiezo.runFindStart()            self.toggleStartStop() # the Delay seems to be fouling this when called immediately        self.togglePulseButtons()    def toggleStartStop(self):        #print(self.varObj.sesVarDict['sessionOn'])        #print(self.varObj.sesVarDict['taskType'])                if self.varObj.sesVarDict['sessionOn']==1 and self.varObj.sesVarDict['taskType']=='monitorOnly':            self.variables.cal_testStartStop.set('Stop')            #self.variables.cal_testStartStop.set('Start')        else:            self.variables.cal_testStartStop.set('Start')            #self.variables.cal_testStartStop.set('Stop')    def startPulse(self):        if self.variables.cal_pulseRunning:            if self.varObj.sesVarDict['sessionOn']==1:                self.togglePulseButtons()            else:                self.variables.cal_pulseRunning=False                self.togglePulseButtons()        else:            if self.varObj.sesVarDict['sessionOn']==1 and self.varObj.sesVarDict['taskType']=='monitorOnly':                testCheckList=[]                                tChanTst= self.varObj.inferType(self.variables.cal_testChannel.get())                testCheckList.append(tChanTst)                tAmpTst= self.varObj.inferType(self.variables.cal_testAmp.get())                testCheckList.append(tAmpTst)                tPulseDurTst=self.varObj.inferType(self.variables.cal_testPulseDur.get())                testCheckList.append(tPulseDurTst)                tPulseInterTst=self.varObj.inferType(self.variables.cal_testInterPulseDur.get())                testCheckList.append(tPulseInterTst)                tWaveTst=self.varObj.inferType(self.variables.cal_testWaveShape.get())                testCheckList.append(tWaveTst)                #try:                for chkMe in testCheckList:                    if type(chkMe)!=int and type(chkMe)!=float:                        print('Parameter Missing, Please Add')                        return                    else:                        pass                tChanTst=str(int(round(tChanTst)))                if tWaveTst ==2:                    tPulseUpTst=self.varObj.inferType(self.variables.cal_testPulseUpDur.get())                    if (type(tPulseUpTst)!=int and type(tPulseUpTst)!=float) or (tPulseUpTst>tPulseDurTst):                        print('Pulse Up Invalid, Please Fix')                        return                    else:                        tPulseUpTst=str(int(round(tPulseUpTst*100000)))                        taskSer.teensy.write('y{}{}>'.format(tPulseUpTst,tChanTst).encode('utf-8'))                tAmpTst=str(int(round(tAmpTst)))                tPulseDurTst=str(int(round(tPulseDurTst*100000)))                tPulseInterTst=str(int(round(tPulseInterTst*100000)))                tWaveTst=str(int(round(tWaveTst)))                tTrainDurTst=str(int(round(3600*100000))) # If you can't get this done in an hour.... common...                taskSer.teensy.write('v{}{}>'.format(tAmpTst,tChanTst).encode('utf-8'))                time.sleep(taskVar.sampleDt)                taskSer.teensy.write('p{}{}>'.format(tPulseDurTst,tChanTst).encode('utf-8'))                time.sleep(taskVar.sampleDt)                taskSer.teensy.write('d{}{}>'.format(tPulseInterTst,tChanTst).encode('utf-8'))                time.sleep(taskVar.sampleDt)                taskSer.teensy.write('t{}{}>'.format(tWaveTst,tChanTst).encode('utf-8'))                time.sleep(taskVar.sampleDt)                taskSer.teensy.write('u{}{}>'.format(tTrainDurTst,tChanTst).encode('utf-8'))                time.sleep(taskVar.sampleDt)                taskSer.teensy.write('u{}{}>'.format(tTrainDurTst,tChanTst).encode('utf-8'))                time.sleep(taskVar.sampleDt)                timeNext=str(int(round((taskVar.curTime+taskVar.sampleDt)*100000)))                taskSer.teensy.write('s{}{}>'.format(timeNext,tChanTst).encode('utf-8'))                self.variables.cal_pulseRunning=True                self.variables.cal_pulsingChannel=int(tChanTst)                self.togglePulseButtons()                #except:                    #pass            else:                self.togglePulseButtons()    def endPulse(self):        if self.variables.cal_pulseRunning:            if self.varObj.sesVarDict['sessionOn']==1 and self.varObj.sesVarDict['taskType']=='monitorOnly':                try:                    taskSer.teensy.write('s{}{}>'.format('-2',str(self.variables.cal_pulsingChannel)).encode('utf-8'))                    self.variables.cal_pulseRunning=False                except:                    pass                self.togglePulseButtons()                            else:                self.variables.cal_pulseRunning=False                self.togglePulseButtons()        else:            self.togglePulseButtons()    def togglePulseButtons(self):        if self.varObj.sesVarDict['sessionOn']==1 and self.varObj.sesVarDict['taskType']=='monitorOnly':            if self.variables.cal_pulseRunning:                self.testWavePulseButton['state'] = tk.DISABLED                self.testWaveEndPulseButton['state'] = tk.NORMAL            else:                self.testWavePulseButton['state'] = tk.NORMAL                self.testWaveEndPulseButton['state'] = tk.DISABLED        else:            if self.variables.cal_pulseRunning:                self.variables.cal_pulseRunning=False                self.testWavePulseButton['state'] = tk.NORMAL                self.testWaveEndPulseButton['state'] = tk.DISABLED            else:                self.testWavePulseButton['state'] = tk.NORMAL                self.testWaveEndPulseButton['state'] = tk.DISABLED                root = tk.Tk()# Create Data Structure ObjecttaskVar=genVariables()#Make a serial object for teensy connectiontaskSer=teensySerial()# Create a Tkinter Interface Object (Unused RN)taskGUI = genGUI(root,taskVar,taskSer)#update the data struct with the likely correct serial port#taskVar.sesVarDict=taskSer.checkCOMPort(taskVar.sesVarDict)def initializeTeensy():    #Creates a serial object with the teensy port and baud rate    teensy=taskSer.connectComObj(taskVar.sesVarDict['comPath'],taskVar.sesVarDict['baudRate_teensy'])    # D) Flush the teensy serial buffer. Send it to the init state (#0).    teensy.write('a0>'.encode('utf-8'))    time.sleep(0.001)    taskSer.flushBuffer(teensy)    # experimental /    teensy.write('a1>'.encode('utf-8'))    time.sleep(0.00001)    teensy.write('a0>'.encode('utf-8'))    time.sleep(0.0001)            taskSer.flushBuffer(teensy)    # end experimental /        sChecked=0    tmOtCnt=0    while sChecked==0:        #On Teensy, Check "state" (header 'a'), with 2ms delay, return (state val, responded bool)        [tTeensyState,sChecked]=taskSer.checkVariable(teensy,'a',0.002)        if sChecked==0:            tmOtCnt+=1            if tmOtCnt>9:                print("Check failed")                return    while tTeensyState != 0:        print("not in 0, will force")        teensy.write('a0>'.encode('utf-8'))        time.sleep(0.002)        taskSer.flushBuffer(teensy)        cReturn=taskSer.checkVariable(teensy,'a',0.002)        if cReturn(1)==1:            tTeensyState=cReturn(0)    taskSer.flushBuffer(teensy)    return teensy,tTeensyState# Starts Trial, pulls parameters from config and dict, creates trial params, connects to Teensy, memory mapdef initializeLoadCell():    try:        taskSer.flushBuffer(taskSer.teensy)        wVals=[]        lIt=0        while lIt<30:            [rV,vN]=taskSer.checkVariable(taskSer.teensy,'l',0.100)            if vN:                wVals.append(float(rV)/100.0)                lIt=lIt+1        iMass=np.mean(wVals)-taskVar.sesVarDict['loadBaseline']        # if iMass<0:        #     iMass=taskVar.sesVarDict['loadBaseline']        taskSer.flushBuffer(taskSer.teensy)    except:        iMass=taskVar.sesVarDict['loadBaseline']        try:            taskSer.flushBuffer(taskSer.teensy)        except:            pass    return iMassdef initializeTasks():    #These deal with human interactivity     taskVar.sendingNow=False    taskVar.pauseSending=False    taskVar.endedOnSchedule=False    taskVar.curTime = 0.0    taskVar.curTrialTime = 0.0    taskVar.startTime=0.0    taskVar.curInt = 0    taskVar.curTrialInt = 0    taskVar.startInt = 0    taskVar.waitTime = np.NaN    taskVar.waitInt = np.NaN    taskVar.pyState=0    taskVar.manualRewards=[]    taskVar.manualWidthdraws=[]    taskVar.sampleDt = 1.0/float(taskVar.sesVarDict['sampRate'])     taskVar.sesVarDict['trialNum']=0    if len(taskVar.experimentPandas['trialBaselines']) >0:        taskVar.sesVarDict['totalTrials']=taskVar.experimentPandas['trialBaselines'].index.size    else:        taskVar.sesVarDict['totalTrials']=1    # connect to the teensy    [taskSer.teensy,taskSer.tState] = initializeTeensy()    taskVar.sendError=0 # used to resend variables if not-recieved becomes and issue    taskVar.initialMass = [] # used for data visualization, not recorded in HDF as weight delta easily analyzed post hoc    taskVar.initialMass = initializeLoadCell()    if taskVar.sesVarDict['taskType']!='calibrate':        #be aware that the maximum duration is hardcoded to be two hours TODO        taskVar.sesVarDict['maxDur']=3600*2*taskVar.sesVarDict['sampRate']        taskVar.sesData = np.memmap(taskVar.sesVarDict['dirPath'] / 'sesDataMemMap.npy',\            mode='w+',dtype=np.int32,shape=(taskVar.sesVarDict['maxDur'],taskVar.sesVarDict['dStreams']))        taskVar.makeHDF(taskVar.sesVarDict['dirPath'],taskVar.sesVarDict['subjID'] + '_ses{}'.\            format(taskVar.sesVarDict['curSession']),datetime.datetime.now().strftime("%m_%d_%Y"))    else:        taskVar.sesVarDict['maxDur'] = int(np.ceil(taskGUI.variables.sweepDuration *taskVar.sesVarDict['sampRate']))        #        taskVar.sesData = np.memmap(taskVar.sesVarDict['dirPath'] / 'sesDataMemMap.npy',\            mode='w+',dtype=np.int32,shape=(taskVar.sesVarDict['maxDur'],6))        _,tempCdfFileName=taskVar.makeHDF(taskVar.sesVarDict['dirPath'] / 'calibrationResults',\            [],[],taskVar.makeCalTrialsDict['calibrateName'],str(taskGUI.variables.curPosition))        taskVar.calDataFiles.at[taskGUI.variables.curPosition]=tempCdfFileName    taskVar.sesVarDict['sessionOn']=1        #used for read serial buffer    taskSer.serialBuf=bytearray()    #used for trailmaintenance     taskVar.trialSamps=[0,0] # TODO reassess counting here [0] is loopCnt-1 (time/loop of last data recieved) trial start (0:n), [1] is trial end loopCnt (est Teensy loop when trial ended )    #Indexes session data    taskVar.loopCnt=0        #Keeps track of "state" - basically on/off and maybe one day flyback (but    taskVar.sHeaders=np.zeros(2)    #if csGui.useGUI==1:    #Keep track of incomplete serial messages, [count,[list of putative loop counts]]    taskVar.incompleteSamples=[0,[]]    # TODO, if task is record only, set waittime, else, Put get variables fuction here, may overwrite pystate    if taskVar.sesVarDict['taskType']=='detection':        #Keep track of reward data        taskVar.rewardTrackingColumns=['indexTuple','startTime','startInt','rsWindowStart','rsWindowEnd','rsReported',        'reportTime','respCueTime','respCueEnd','reward','catch','hit','miss','cr','fa','deliverReward','deliverRespCue','addTimeOut','rewardStart',        'rewardEnd','widthdrawRwd','evaluated','rwdDelivered','consumed','completed']        taskVar.rewardTracker=pd.DataFrame(columns=taskVar.rewardTrackingColumns) #wiped every new trial footer                #Append this for Trial Annotation from above list at trial end        taskVar.trialDataColumns=['indexTuple','startTime','startInt','rsWindowStart','rsWindowEnd','rsReported',        'reportTime','respCueTime','respCueEnd','reward','catch','hit','miss','cr','fa','rewardStart','rewardEnd','rwdDelivered','consumed']        taskVar.trialData=pd.DataFrame(columns=taskVar.trialDataColumns)        #Triggers for running reward evaluation functions - updated dynamically        #Triggers evaluateRewardTimeOut        taskVar.nextRspnsWinTimeStrt=np.nan #Used to run evaluation on licks gt() this time         taskVar.nextRspnsWinTimeEnd=np.nan # Used to run evlauation when at time to evaluate misses / CR        #Triggers deliverRewardResponse        taskVar.runDeliver=False        taskVar.nextRewardTime=np.nan # Triggers function ahead of next reward delivery        taskVar.nextRwdWinTimeStrt=np.nan # Runs function on licks gt() this time to evaluate  water consumption        taskVar.nextRwdWinTimeEnd=np.nan # Runs function ahead of reward widthdrawal         taskVar.nextCueTime=np.nan # Runs function ahead of response cue        taskVar.flagTimeOut=False # Keeps track of adding wait time         taskVar.nextTimeOutCue = np.nan # Runs function ahead of the TO cue        #taskVar.runSchedule=False  # Shouldn't need this while addTime() triggers scheduleevents() by restting schedule check        #Keep Track of Trial Timing Events to Annotate Data        taskVar.timingDataColumns=['baseLineStart','trialStart','toEnforced','noLickDelays','noRunDelays','startCues','endCues','timeOutCues']        taskVar.timingData=pd.DataFrame(np.tile(np.array([np.nan,np.nan,False,[],[],np.nan,np.nan,np.nan],dtype=object).reshape(1,-1),\            (taskVar.sesVarDict['totalTrials'],1)),columns=taskVar.timingDataColumns)        taskVar.noLickDelays=[]        taskVar.noRunDelays=[]        taskVar.noLickDelaysCount=0        taskVar.noRunDelaysCount=0        #Lick detection block        taskVar.lickLatch=0.0        taskVar.timeLastLick=np.nan        taskVar.newLick=False        # Run Block        taskVar.runLatch=0.0        taskVar.runningNow=False        #trial timing variables        taskVar.timeLatch = 0 #integar used to evaluate possibility of a behavior - caused time-bump        taskVar.curTimeBump=0.0        taskVar.noNextWait = 0        taskVar.tTrial = 0        # Trafficking Messages dataFrames        #These organize signals to send, and track data needed to determine when to send them relative to the task        taskVar.sendListColumns=['paramSent','startSent','indexTuple','channelInfo','startTime','startInt','endTime','endInt','buffering','rewardStimulus','catchStimulus']        taskVar.sendList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.waitList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.nextSendList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.nextWaitList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.bufferDict={}        # The above temporarily replaces the buffering tracking in the more complex structs commented out below        # #This is a list containing the last sent parameters for each channel.        # taskVar.sentParamColumns=['indexTuple','channelInfo','startTime','endTime','amp','pulseDur',\        # 'pulseUpDur','interPulseDur','pulseCount','pulseTrainDur','waveform','buffering']        # taskVar.sentParametersCurrent=pd.DataFrame(columns=taskVar.sentParamColumns)        # #This is a list containing the sent buffered parameters for each channel.        # taskVar.sentParamBuffColumns=['indexTuple','channelInfo','startTime','endTime','amp','pulseDur',\        # 'pulseUpDur','interPulseDur','pulseCount','pulseTrainDur','waveform','pendingBuffOpen','pendingBuffClose']        # taskVar.sentParametersBuffered=pd.DataFrame(columns=taskVar.sentParamBuffColumns)        #This is a list where the messages for each signal are compiled, in order, to be sent via serial pre-translation.        taskVar.scheduledMessageColumns=['indexTuple','channelInfo','paramName','paramValue']        taskVar.scheduledMessages=pd.DataFrame(columns=taskVar.scheduledMessageColumns)        taskVar.lastSentMessage=pd.DataFrame(columns=taskVar.scheduledMessageColumns+['sndTxt'])        #taskVar.scheduleCheck = scheduleEvents(taskVar.noNextWait)        cleanupEmptyParams()        setTrainingOptions()        estimateStimWaitTime()    #estimates minimum wait times for pyState 1        removeEmptyDummies() # get rid of dummy variables used only for synchronization or trial length, keep training related         taskVar.noNextWait=populateTrialVariableLists() # interpret the first trial structure and start condition        trialEnter()        calculateTimeLatch() # always after populate, pystate change ot TO time add        taskVar.sHeaders[taskVar.pyState]=1        #This is here to bypass first loop header        taskVar.sHeaders[np.setdiff1d([0,1],taskVar.pyState)]=0        taskVar.checkInt = scheduleEvents(taskVar.noNextWait)        if taskVar.checkInt==0:            taskVar.checkInt=taskVar.sesVarDict['sampRate']        taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt        #send all the first-trial messages generated before starting the clock        while len(taskVar.scheduledMessages)>0:            sendNextCommnd()            time.sleep(0.001)    elif taskVar.sesVarDict['taskType']=='calibrate':        taskVar.flagTimeOut=False # Keeps track of adding wait time         #trial timing variables        taskVar.timeLatch = 0 #integar used to evaluate possibility of a behavior - caused time-bump        taskVar.noNextWait = 0        taskVar.tTrial = 0        # Trafficking Messages dataFrames        #These organize signals to send, and track data needed to determine when to send them relative to the task        taskVar.sendListColumns=['paramSent','startSent','indexTuple','channelInfo','startTime','startInt','endTime','endInt','buffering','rewardStimulus','catchStimulus']        taskVar.sendList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.waitList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.nextSendList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.nextWaitList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.bufferDict={}        #This is a list where the messages for each signal are compiled, in order, to be sent via serial pre-translation.        taskVar.scheduledMessageColumns=['indexTuple','channelInfo','paramName','paramValue']        taskVar.scheduledMessages=pd.DataFrame(columns=taskVar.scheduledMessageColumns)        taskVar.lastSentMessage=pd.DataFrame(columns=taskVar.scheduledMessageColumns+['sndTxt'])        #taskVar.scheduleCheck = scheduleEvents(taskVar.noNextWait)        cleanupEmptyParams()                estimateStimWaitTime()    #estimates minimum wait times for pyState 1        removeEmptyDummies() # get rid of (in this case all) dummy variables as not useful anymore        taskVar.noNextWait=populateTrialVariableLists() # interpret the first trial structure and start condition        calculateTimeLatch() # always after populate, pystate change ot TO time add        taskVar.sHeaders[taskVar.pyState]=1        #This is here to bypass first loop header        taskVar.sHeaders[np.setdiff1d([0,1],taskVar.pyState)]=0        taskVar.checkInt = scheduleEvents(taskVar.noNextWait)        if taskVar.checkInt==0:            taskVar.checkInt=taskVar.sesVarDict['sampRate']        taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt        #send all the first-trial messages generated before starting the clock        while len(taskVar.scheduledMessages)>0:            sendNextCommnd()            time.sleep(0.001)            elif taskVar.sesVarDict['taskType']=='simpleRecording':        print("Recording Started")    taskGUI.activity.startActivityMonitor()    taskSer.teensy.write('a1>'.encode('utf-8'))     taskSer.cntrlTState=1# Moves serial reads to Py buffer, reads one line of it, Returns new data when valid message rcvddef waitTimeToInt():    taskVar.waitInt = round(taskVar.waitTime*taskVar.sesVarDict['sampRate'])def varTimeFromInt(convertVar):    resultVar = float(convertVar)/float(taskVar.sesVarDict['sampRate'])    return resultVardef varTimeToInt(convertVar): #general utility version of wTTT    resultVar = round(convertVar*taskVar.sesVarDict['sampRate'])    return resultVardef checkTeensyData():    newData=0    try:        # This fuction also sets the outputs to taskVar attributes (including the omitted error messages)        [taskSer.serialBuf,eR,tString,erString,killString]=taskSer.readSerialBuffer(taskSer.teensy,taskSer.serialBuf,taskVar.sesVarDict['serBufSize'])        if len(tString)==taskVar.sesVarDict['dStreams']-1:            newData =1                    #If data list is correct len flip received flag            # handle timing stuff            intNum = int(tString[1])    #Loop Count            tTime = int(tString[2])        #Trial Time            tTime = float(tTime)/ 100000.0 # Teensy thinks in um X10 increments, new GUI interfaces in seconds            #tStateTime=int(tString[3])    # Removed as it doesn't really matter now            # if time did not go backward (out of order packet)             # then increment python time, int, and state time.            if (tTime >= taskVar.curTime):                taskVar.curTime  = tTime                taskVar.curInt = intNum                #taskVar.curStateTime = tStateTime                taskVar.curTrialTime=taskVar.curTime-taskVar.startTime                taskVar.curTrialInt = taskVar.curInt-taskVar.startInt                        # check the teensy state            taskSer.tState=int(tString[3]) # changed from previous ind of '4'            # even if the the data came out of order, we need to assign it to the right part of the array.            if intNum < taskVar.sesData.shape[0]:                for x in range(0,taskVar.sesVarDict['dStreams']-2): # This needs to change if the session data needs more fields                    taskVar.sesData[intNum,x]=int(tString[x+1])                taskVar.sesData[intNum,taskVar.sesVarDict['dStreams']-2]=taskVar.pyState # The state python (was at last teensy loop)                taskVar.sesData[intNum,taskVar.sesVarDict['dStreams']-1]=0 # Thresholded licks                taskVar.loopCnt=taskVar.loopCnt+1            else:                taskVar.sesVarDict['sessionOn']=0                print('Session Ended Maximum Data Size Reached')        elif len(tString)>0:            #if dropped or incomplete read, log it and report            taskVar.incompleteSamples[0] = taskVar.incompleteSamples[0]+1;taskVar.incompleteSamples[1].append(taskVar.curInt+1)        elif len(erString)>0:            #len should = 2            taskVar.sendError=1            print('Command Error')        elif len(killString)>0:            taskVar.sesVarDict['sessionOn']=0            print('Teensy Clock Over Run - Restart')    except:        newData = 0    return newDatadef checkTeensyDataCal():    newData=0    try:        # This fuction also sets the outputs to taskVar attributes (including the omitted error messages)        [taskSer.serialBuf,eR,tString,erString,killString]=taskSer.readSerialBuffer(taskSer.teensy,taskSer.serialBuf,taskVar.sesVarDict['serBufSize'])        if len(tString)==taskVar.sesVarDict['dStreams']-1:            #taskVar.curString=tString  # Used for debugging            newData =1                    #If data list is correct len flip received flag            # handle timing stuff            intNum = int(tString[1])    #Loop Count            tTime = int(tString[2])        #Trial Time            tTime = float(tTime)/ 100000.0 # Teensy thinks in um X10 increments, new GUI interfaces in seconds            #tStateTime=int(tString[3])    # Removed as it doesn't really matter now            # if time did not go backward (out of order packet)             # then increment python time, int, and state time.            if (tTime >= taskVar.curTime):                taskVar.curTime  = tTime                taskVar.curInt = intNum                #taskVar.curStateTime = tStateTime                taskVar.curTrialTime=taskVar.curTime-taskVar.startTime                taskVar.curTrialInt = taskVar.curInt-taskVar.startInt                        # check the teensy state            taskSer.tState=int(tString[3]) # changed from previous ind of '4'            # even if the the data came out of order, we need to assign it to the right part of the array.            #for x in range(0,taskVar.sesVarDict['dStreams']-2): # This needs to change if the session data needs more fields            #    taskVar.sesData[intNum,x]=int(tString[x+1])            if intNum < taskVar.sesData.shape[0]:                taskVar.sesData[intNum,0]=int(tString[1]) #loops                taskVar.sesData[intNum,1]=int(tString[2]) #tTime                 taskVar.sesData[intNum,2]=int(tString[7+taskVar.cal_Input]) # Analog input (cal_in 1 = Ain pin 0, cal_in 2 = Ain 1) maintaining 1=0 comp to teensy convention                taskVar.sesData[intNum,3]=int(tString[10]) # Outputs  [bils:mils[dac4],hundThous:hunds[dac1],tens:units[dout2,dout0]                taskVar.sesData[intNum,4]=int(tString[11]) # Outputs  [bils:mils[potential dac5],hundThous:hunds[dac2],tens:units[dout3,dout1]                taskVar.sesData[intNum,5]=int(tString[12]) # Outputs  [n/a (extra 2),TenMils:TenThous[dac3],thous:units[dac0]                taskVar.loopCnt=taskVar.loopCnt+1        elif len(tString)>0:            #if dropped or incomplete read, log it and report            taskVar.incompleteSamples[0] = taskVar.incompleteSamples[0]+1;taskVar.incompleteSamples[1].append(taskVar.curInt+1)        elif len(erString)>0:            #len should = 2            taskVar.sendError=1            print('Command Error')        elif len(killString)>0:            taskVar.sesVarDict['sessionOn']=0            print('Teensy Clock Over Run - Restart')    except:        newData = 0    return newDatadef advanceTime(addSecs=0,addInt=0):    addInc=0    addFloat=0.0    if addSecs>0:        addInc = varTimeToInt(addSecs)        addFloat=addSecs    elif addInt>0:        addFloat= varTimeFromInt(addInt)        addInc=addInt    taskVar.curTime+=addFloat    taskVar.curInt+=addInc    taskVar.curTrialTime=taskVar.curTime-taskVar.startTime    taskVar.curTrialInt = taskVar.curInt-taskVar.startInt# Resets counters and updates pyStatedef genericHeader():    # reset counters that track state stuff.    # taskVar.lickCounter=0     # taskVar.lastLickCount = 0    # taskVar.trialTimeLastLick=np.NaN     # taskVar.reported =0                      # taskVar.outSyncCount=0    #taskVar.serialVarTracker = [0,0,0,0,0,0,0,0]    taskVar.sHeaders[taskVar.pyState]=1    taskVar.sHeaders[np.setdiff1d([0,1],taskVar.pyState)]=0    taskVar.startTime=taskVar.curTime    taskVar.curTrialTime=0.0    taskVar.startInt=taskVar.curInt    taskVar.curTrialInt = 0    # taskVar.lickRunLockout=0    # taskVar.flagTimeOut=[]    # taskVar.flagRewardWindow=[] #TODO function to populate thesedef genericFooter():    # reset counters that track state stuff.    # taskVar.lickCounter=0     # taskVar.lastLickCount = 0    # taskVar.trialTimeLastLick=np.NaN     # taskVar.reported =0                      # taskVar.outSyncCount=0    #taskVar.serialVarTracker = [0,0,0,0,0,0,0,0]    taskVar.sHeaders[taskVar.pyState]=1    taskVar.sHeaders[np.setdiff1d([0,1],taskVar.pyState)]=0    taskVar.startTime=taskVar.curTime    taskVar.curTrialTime=0.0    taskVar.startInt=taskVar.curInt    taskVar.curTrialInt = 0    calculateTimeLatch()    taskVar.flagTimeOut=False    # taskVar.lickRunLockout=0    # taskVar.flagTimeOut=[]    # taskVar.flagRewardWindow=[] #TODO function to populate thesedef genericBody():    #Basically deals with test-subject interactivity: annotates behaviors, evaluates experiment design interactivity,    # schedules and delivers behavior contigent cues (all single TTL pulses) [#TODO Could be eventually    # expanded in conjunction with new arduino code to have teensy send digital bits/bytes], adjust trial length and    # if needed resets schedule for upcomming signals for schedule function to recompute and send needed serial messages    taskVar.newLick=lickDetection()    #    # if taskVar.newLick:    #     print('Lick')    # if taskVar.runningNow:    #     print('Run')    if (taskVar.waitInt-taskVar.timeLatch>=taskVar.curTrialInt):        #Baseline nolick/no run block         if taskVar.pyState==0:            #taskVar.runningNow=runDetection() # changed bc only used by enforceNoRun            if (taskVar.newLick and taskVar.sesVarDict['enforceNoLick']):                #print('triggered')                taskVar.curTimeBump=taskVar.curTrialTime-(taskVar.waitTime-taskVar.sesVarDict['noLickTime'])                if taskVar.curTimeBump>0:                    addTime(timeToAdd=taskVar.curTimeBump)                    #print('Added {} Secs lick'.format(str(taskVar.curTimeBump))                    taskVar.noLickDelays.append(taskVar.curTime)                                #if (taskVar.runningNow and taskVar.sesVarDict['enforceNoRun']): # changed bc only used by enforceNoRun            if taskVar.sesVarDict['enforceNoRun']:                taskVar.runningNow=runDetection()                if taskVar.runningNow:                    #print('triggered')                    taskVar.curTimeBump=taskVar.curTrialTime-(taskVar.waitTime-taskVar.sesVarDict['noRunTime'])                    if taskVar.curTimeBump>0:                        addTime(timeToAdd=taskVar.curTimeBump)                        #print('Added {} Secs Run'.format(str(taskVar.curTimeBump)))                        taskVar.noRunDelays.append(taskVar.curTime)                                if taskVar.pyState ==1:            #evaluateRewardTimeOut()            # if taskVar.sHeaders[taskVar.pyState]!=1:            #     print('hi')            #     genericHeader()            if (taskVar.newLick and (taskVar.nextRspnsWinTimeStrt<=taskVar.curTime)) or (taskVar.nextRspnsWinTimeEnd<=taskVar.curTime):                taskVar.runDeliver=evaluateRewardTimeOut()            if taskVar.runDeliver or (taskVar.curTime>=taskVar.nextRewardTime-taskVar.sampleDt) or (taskVar.newLick and\            (taskVar.nextRwdWinTimeStrt<=taskVar.curTime)) or (taskVar.curTime>=taskVar.nextRwdWinTimeEnd-taskVar.sampleDt) or\            (taskVar.curTime>=taskVar.nextCueTime-taskVar.sampleDt) or(taskVar.curTime>=taskVar.nextTimeOutCue-taskVar.sampleDt) or\            (taskVar.curTrialInt>=taskVar.waitInt):                deliverRewardResponse()    taskVar.newLick=False    taskVar.runningNow=False    taskVar.curTimeBump=0.0    #taskVar.runSchedule=False    taskVar.runDeliver=Falsedef sessionCleanup(exceptionBool):    if exceptionBool == 1:        taskVar.sesData.flush()        print(taskVar.loopCnt)        print('Stopped on error')        sesNum = taskVar.sesVarDict['curSession']-1        taskVar.sesVarDict['sessionOn']=0    if exceptionBool == 0:        sesNum = taskVar.sesVarDict['curSession']        # # To make sure all cues, reward control etc. are sent, Send all the remaining control messages with a limit of 50.         # # If session was closed early, and signals were scheduled, those should be cut off by teensy-off message below        # checkTimeOut = 0        # while (len(taskVar.scheduledMessages)>0) and (checkTimeOut<50):        #     checkTimeOut+=1        #     sendNextCommnd(0,True)        #     time.sleep(taskVar.sampleDt)        if taskVar.endedOnSchedule:            #This means that trials ran their length, possible that an end cue still should be sent, so send it manually here:            try:                #                if taskVar.endCueSet:                    #Just easier adding the cue this way rather than building the message directly here - However could be errored if cue channel buffering                    addSerialMessage(np.nan,(taskVar.sesVarDict['endCueChannel'],1),'startTime',-1,1)                    taskVar.timingData.at[taskVar.tTrial,'endCues']=taskVar.curTime+taskVar.sampleDt                    sendNextCommnd()                    time.sleep(taskVar.sesVarDict['endCueDur']) #Then just wait out the signal duration before dissabling the teensy            except:                pass    # writeData(taskVar.sesHDF,taskVar.sesVarDict['curSession'],\    #     taskVar.sesData[0:taskVar.loopCnt,:],taskVar.attributeLabels,taskVar.attributeData,\    #     'taskVar','timing')    if taskSer.teensy.is_open:        taskSer.teensy.write('a0>'.encode('utf-8'))        time.sleep(taskVar.sampleDt*2)        taskSer.teensy.write('a0>'.encode('utf-8'))        time.sleep(taskVar.sampleDt*2)    taskSer.flushBuffer(taskSer.teensy)    taskSer.cntrlTState=0    taskSer.teensy.close()    if taskVar.sesVarDict['taskType']!='monitorOnly':        if taskVar.sesVarDict['taskType']!='calibrate':                            print('finished {} trials'.format(taskVar.sesVarDict['trialNum']))            print('Session over, Recording Lasted {:.5f} Seconds'.format(taskVar.curTime))                writeData()            taskVar.sesVarDict['curSession']=taskVar.sesVarDict['curSession']+1        elif taskVar.sesVarDict['taskType']=='calibrate':            print('finished {} trials'.format(taskVar.sesVarDict['trialNum'])) #For debugging            writeData()        taskVar.sesVarDict['trialNum']=0        #if csGui.useGUI==1:    #    csGui.curSession_TV.set(taskVar.sesVarDict['curSession'])    #csGui.refreshPandas()    taskVar.sesVarDict['canQuit']=1        #GUI Stuff    try:        if hasattr(taskGUI,'activity') and ('normal'== taskGUI.activityWindow.state()):            taskGUI.activity.stopActivityMonitor()    except:        pass    if taskGUI.variables.inTaskFlag==1 and taskVar.sesVarDict['taskType']!='calibrate':        taskGUI.variables.inTaskFlag=0    if taskVar.sesVarDict['taskType']!='calibrate' and taskVar.sesVarDict['taskType']!='monitorOnly':        taskGUI.variables.curSession.set(str(int(taskGUI.variables.curSession.get())+1))        taskGUI.variables.det_buttonText.set('Create Trials')    if taskVar.sesVarDict['taskType']=='calibrate':        print('running close Cal prot') # For debugging        taskGUI.calibratePiezo.closeCalProtocol()    taskGUI.recordOnlyButton['text']='Record Sensors Only'    taskGUI.getMainFields()    taskGUI.saveDefaultDict()          try:        del taskVar.sesData        gc.collect()        os.remove(taskVar.sesVarDict['dirPath'] / 'sesDataMemMap.npy')    except:        passdef writeData():        # Save out recorded data    taskVar.sesHDF.create_group('sessionData')    taskVar.sesHDF['sessionData'].create_dataset('dataStreams',data=taskVar.sesData[0:taskVar.loopCnt,:],compression="gzip", compression_opts=5)    # Save the broken serial message read number and location    taskVar.sesHDF.create_group('incompleteSerial')    #skipped putative addresses    taskVar.sesHDF['incompleteSerial'].create_dataset('incompleteSamples',dtype=np.int64,data=np.array(taskVar.incompleteSamples[1],dtype='int64'),compression="gzip", compression_opts=5)    # count of skips    taskVar.sesHDF['incompleteSerial']['incompleteSamples'].attrs['incompleteSamplesCount']=taskVar.incompleteSamples[0]    # save the var dictionary    taskVar.sesHDF['sessionData'].create_dataset('taskSettings', dtype=np.float64, data=h5py.Empty(np.float64))    for varToSave in taskVar.sesVarDict.keys():        if varToSave == 'dirPath':            taskVar.sesHDF['sessionData']['taskSettings'].attrs[varToSave]=str(taskVar.sesVarDict[varToSave])        else:            taskVar.sesHDF['sessionData']['taskSettings'].attrs[varToSave]=taskVar.sesVarDict[varToSave]    taskVar.sesHDF['sessionData']['taskSettings'].attrs['initialMass']=taskVar.initialMass    taskVar.sesHDF['sessionData'].create_group('manualSignals')    if len(taskVar.manualRewards)==0:        taskVar.manualRewards.append(np.nan)    if len(taskVar.manualWidthdraws)==0:        taskVar.manualWidthdraws.append(np.nan)    taskVar.sesHDF['sessionData']['manualSignals'].create_dataset('manualRewards', dtype=np.float64, data=np.float64(taskVar.manualRewards))    taskVar.sesHDF['sessionData']['manualSignals'].create_dataset('manualWidthdraws', dtype=np.float64, data=np.float64(taskVar.manualWidthdraws))        if taskVar.sesVarDict['taskType']=='detection':        # Create Group and save out timing realted data        taskVar.sesHDF['sessionData'].create_group('designFile')        taskVar.sesHDF['sessionData']['designFile'].create_dataset('filenames', dtype=np.float64, data=h5py.Empty(np.float64))        taskVar.sesHDF['sessionData']['designFile'].create_dataset('trialNumbers', dtype=np.float64, data=h5py.Empty(np.float64))        taskVar.sesHDF['sessionData']['designFile'].create_dataset('taskFile', dtype=np.float64, data=h5py.Empty(np.float64))        taskVar.sesHDF['sessionData']['designFile']['taskFile'].attrs[str(0)]=taskVar.experimentDesignFiles['taskFile']        for flInd in range(len(taskVar.experimentDesignFiles['filenames'])):            taskVar.sesHDF['sessionData']['designFile']['filenames'].attrs[str(flInd)]=taskVar.experimentDesignFiles['filenames'][flInd]            if flInd < len(taskVar.experimentDesignFiles['trials'])-1:                taskVar.sesHDF['sessionData']['designFile']['trialNumbers'].attrs[str(flInd)]=taskVar.experimentDesignFiles['trials'][flInd]            elif flInd == len(taskVar.experimentDesignFiles['trials'])-1:                taskVar.sesHDF['sessionData']['designFile']['trialNumbers'].attrs[str(flInd)]=taskVar.sesVarDict['trialNum']# This is the number of executed trials        taskVar.sesHDF['sessionData'].create_group('timingData')        taskVar.sesHDF['sessionData']['timingData'].create_dataset('baselineDurations', data=taskVar.experimentPandas['trialBaselines']['trialTime'].to_numpy(dtype=np.float64))        taskVar.sesHDF['sessionData']['timingData'].create_dataset('trialDurations', data=taskVar.experimentPandas['trialBaselines']['waitTime'].to_numpy(dtype=np.float64))        taskVar.sesHDF['sessionData']['timingData'].create_dataset('noLickDelays', dtype=np.float64, data=h5py.Empty(np.float64))        taskVar.sesHDF['sessionData']['timingData'].create_dataset('noRunDelays', dtype=np.float64, data=h5py.Empty(np.float64))        #save lists of varying shape as attributes        for groupName in ['noLickDelays','noRunDelays']:            #            for triNum in range(0,taskVar.sesVarDict['trialNum']):                taskVar.sesHDF['sessionData']['timingData'][groupName].attrs[str(triNum)]=taskVar.timingData.loc[triNum,groupName]        # Save float timing data        for groupName in ['baseLineStart','trialStart','startCues','endCues','timeOutCues']:            taskVar.sesHDF['sessionData']['timingData'].create_dataset(groupName, data=taskVar.timingData[groupName].to_numpy(dtype=np.float64))        # save bool timing data        taskVar.sesHDF['sessionData']['timingData'].create_dataset('toEnforced', data=taskVar.timingData['toEnforced'].to_numpy(dtype=np.bool_))        # Save Behavior Data        taskVar.sesHDF['sessionData'].create_group('trialData')        dexNum =0        for indexVal in taskVar.trialData['indexTuple']:            taskVar.sesHDF['sessionData']['trialData'].attrs[str(dexNum)]=indexVal            dexNum+=1        for groupName in ['rwdDelivered','startInt']:            taskVar.sesHDF['sessionData']['trialData'].create_dataset(groupName,shape=taskVar.trialData[groupName].shape,dtype=np.int64,\            data=taskVar.trialData[groupName].to_numpy(dtype=np.int64))          for groupName in ['rsReported','reward','catch','hit','miss','cr','fa','consumed']:            taskVar.sesHDF['sessionData']['trialData'].create_dataset(groupName,shape=taskVar.trialData[groupName].shape,dtype=np.bool_,\            data=taskVar.trialData[groupName].to_numpy(dtype=np.bool_))        for groupName in ['startTime','rsWindowStart','rsWindowEnd','reportTime','respCueTime','respCueEnd','rewardStart','rewardEnd']:            taskVar.sesHDF['sessionData']['trialData'].create_dataset(groupName,shape=taskVar.trialData[groupName].shape,dtype=np.float64,\            data=taskVar.trialData[groupName].to_numpy(dtype=np.float64))                #Save signal parameters    if taskVar.sesVarDict['taskType']=='calibrate':        #        taskVar.sesHDF['sessionData'].create_group('designFile')        taskVar.sesHDF['sessionData']['designFile'].create_dataset('filenames', dtype=np.float64, data=h5py.Empty(np.float64))        taskVar.sesHDF['sessionData']['designFile']['filenames'].attrs[str(0)]=taskVar.calDesignFile        if len(taskGUI.variables.cal_sensorValuesList)>0:            taskVar.sesHDF['sessionData'].create_group('sensorCal')            taskVar.sesHDF['sessionData']['sensorCal'].create_dataset('sensorValues', dtype=np.float64, data=h5py.Empty(np.float64))                        #tmpSensDict={}            snsInd=0            for sensTup in taskGUI.variables.cal_sensorValuesList:                #tmpSensDict[sensTup[0]]=sensTup[1]                taskVar.sesHDF['sessionData']['sensorCal']['sensorValues'].attrs[str(snsInd)]=str(sensTup)                snsInd+=1    if taskVar.sesVarDict['taskType']=='detection' or taskVar.sesVarDict['taskType']=='calibrate':        taskVar.sesHDF['sessionData'].create_group('signalParameters')        dexNum =0        for indexVal in taskVar.experimentPandas['trialParameters'].index:            taskVar.sesHDF['sessionData']['signalParameters'].attrs[str(dexNum)]=indexVal            dexNum+=1        for groupName in ['rewardStimulus', 'catchStimulus']:            taskVar.sesHDF['sessionData']['signalParameters'].create_dataset(groupName,shape=taskVar.experimentPandas['trialParameters'][groupName].shape,dtype=np.bool_,\            data=taskVar.experimentPandas['trialParameters'][groupName].to_numpy(dtype=np.bool_))        for groupName in ['pulseCount','chanToUse','chanToUseType','waveform']:            taskVar.sesHDF['sessionData']['signalParameters'].create_dataset(groupName,shape=taskVar.experimentPandas['trialParameters'][groupName].shape,dtype=np.float64,\            data=taskVar.experimentPandas['trialParameters'][groupName].to_numpy(dtype=np.float64))                for groupName in ['offset', 'amp', 'pulseDur','pulseUpDur', 'interPulseDur','pulseTrainDur', 'tFired']:            taskVar.sesHDF['sessionData']['signalParameters'].create_dataset(groupName,shape=taskVar.experimentPandas['trialParameters'][groupName].shape,dtype=np.float64,\            data=taskVar.experimentPandas['trialParameters'][groupName].to_numpy(dtype=np.float64))    taskVar.sesHDF.close()def lickDetection(sensorChan=4):    # e) Lick detection. This can be done in hardware, but I like software because thresholds can be dynamic.    # New Version note, using binary cap sensor, thresholds are redundant , code saved just incase this changes    #if csVar.sesData[csVar.curInt,sensorChan]>=csVar.sesVarDict['lickAThr'] and csVar.sesVarDict['lickLatch']==0:    nwLk=False    if taskVar.sesData[taskVar.curInt,sensorChan] and (taskVar.lickLatch<=taskVar.curTime):        taskVar.sesData[taskVar.curInt,taskVar.sesVarDict['dStreams']-1]=1        taskVar.lickLatch=taskVar.sesVarDict['lickLatch']+taskVar.curTime        # these are used in states        #taskVar.lickCounter=taskVar.lickCounter+1 # running counter, used to compare to previous count, could just use a flag but whatever        taskVar.timeLastLick=taskVar.curTime #used in task to designate last time  compare in resolve reward        nwLk=True        #print('Lick!')    return nwLkdef enforceNoLickRule():    if taskVar.lickCounter>taskVar.lastLickCount:        taskVar.lastLickCount=taskVar.lickCounter        # if the lick happens such that the minimum         # lick time will go over the pre time,         # then we advance waitTime by the minumum        if taskVar.pyState==0:            if taskVar.preTrialNoLick==1 and (taskVar.curTrialTime>(taskVar.waitTime-taskVar.noLickTime)):                taskVar.waitTime = taskVar.waitTime + (taskVar.curTrialTime-(taskVar.waitTime-taskVar.noLickTime))                waitTimeToInt()                                #TODO set wait time in Panda                # Go through signals and reset them                # call add baseline        #elif taskVar.enforceNoLick==1 and taskVar.pyState == 1:         #   if taskVar.curTrialTime<=taskVar.rewardTime:          #      taskVar.lickTimeOut=1           #     #TODO make all reward stuff assess this flag and make trial Maint or whatever add the timeout dur to waittimedef runDetection(runWin=0.1, wheelDiameter=0.1397, encoderChan=5, runThresh=0.010):    #if we are testing, and can test a moving mean, make M/s velocity and threshold it as running    #default threshold chosen to to conservatively annotate running, too low could lead to bad training outcomes    runningNow=False    if taskVar.runLatch<=taskVar.curTime:        tvDex = varTimeToInt(runWin)        if taskVar.curInt>=tvDex:            diffData=np.diff(taskVar.sesData[taskVar.curInt-tvDex+1:taskVar.curInt+1,encoderChan]) #slicing +1 for last address inclusive - correct width            diffData=diffData[abs(diffData)<2047] #anything more than 2/3rds of a rotation in one sample must be a rollover            #curBitVal = diffData[-1]            #curBitVal = float(abs(sum(diffData)))            dist = ( float(abs(sum(diffData))) /4095.0 )*wheelDiameter*math.pi # this is in meters            #dist = (curBitVal/4095)*wheelDiameter*math.pi            #runT = (len(diffData)/taskVar.sesVarDict['sampRate'])            #runV=dist/runT            runV = dist / varTimeFromInt(len(diffData)) # this is meters per second (adjusted for loss of samps on rollovers and -1 on diff)            if (runV> runThresh):                taskVar.runLatch=taskVar.sesVarDict['runLatch']+taskVar.curTime                #print('Running! {}'.format(curBitVal))                #print('Running! {}'.format(runV))                runningNow=True                # if taskVar.sesVarDict['enforceNoRun'] and (taskVar.curTrialTime>(taskVar.waitTime-taskVar.noRunTime)):                #     addTime(taskVar.curTrialTime-(taskVar.waitTime-taskVar.noRunTime))    return runningNowdef resetSignals():    print('if py=0 resets start sent and time to nan/0 for sent wait and next sent, then calls schedule')    print(' if py = 1 resets start sent and time to nan/o in next sent then calls schedule')    if taskVar.pyState==0:        if taskVar.sendList.shape[0]>0: # If there are still signals to send            sSentList=taskVar.sendList.loc[taskVar.sendList.startSent.eq(1)].index.tolist()            if len(sSentList)>0:                taskVar.sendList.at[sSentList,'startSent']=0                        sTimeNotNull=taskVar.sendList.loc[taskVar.sendList.startTime.notnull()].index.tolist()            if len(sTimeNotNull)>0:                taskVar.sendList.at[sTimeNotNull,'startTime']=np.nan    elif taskVar.pyState==1:        if taskVar.nextSendList.shape[0]>0: # If there are still signals to send            sSentList=taskVar.nextSendList.loc[taskVar.nextSendList.startSent.eq(1)].index.tolist()            if len(sSentList)>0:                taskVar.nextSendList.at[sSentList,'startSent']=0                        sTimeNotNull=taskVar.nextSendList.loc[taskVar.nextSendList.startTime.notnull()].index.tolist()            if len(sTimeNotNull)>0:                taskVar.nextSendList.at[sTimeNotNull,'startTime']=np.nan        def estimateStimWaitTime(strtTrial=0):    # ESWT() estimates the post-baseline trial time for each trial by finding the max length of offset+pulse time and if     # catch or reward + reward window  this can be used to estimate next-trial start times along with baseline duration    #arrayLength=len(set(taskVar.experimentPandas['trialParameters'].index.get_level_values('Trials').tolist()))    arrayLength=max(taskVar.experimentPandas['trialParameters'].index.get_level_values('Trials'))+1    estTimes=pd.Series(np.zeros(arrayLength,dtype=float), name='waitTime')    for wtNum in range(strtTrial,arrayLength):        baseStart=np.array(taskVar.experimentPandas['trialParameters'].loc[wtNum].offset.tolist()) #get min        baseEnd = np.zeros(len(baseStart)) # make empty to store length        totalDuration = np.zeros(len(baseStart)) # result array        #typeD = taskVar.experimentPandas['trialParameters'].loc[wtNum].chanToUseType[taskVar.experimentPandas['trialParameters'].\        #loc[wtNum].chanToUseType.eq(1)].index.values # find digital vars        #adjusted from above to incorporate dummy variable        typeD = taskVar.experimentPandas['trialParameters'].loc[wtNum].chanToUseType[taskVar.experimentPandas['trialParameters'].\        loc[wtNum].chanToUseType.ne(0)].index.values # find digital vars                baseEnd[typeD]=taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseDur[typeD]#store the length of the digitals        typeA = taskVar.experimentPandas['trialParameters'].loc[wtNum].chanToUseType[taskVar.experimentPandas['trialParameters'].\        loc[wtNum].chanToUseType.eq(0)].index.values.tolist()        for pandInd in typeA:            if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseTrainDur[pandInd])) and \            (not type(taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseTrainDur[pandInd])==list):                baseEnd[pandInd]=taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseTrainDur[pandInd]            if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseCount[pandInd])) and\             (not type(taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseCount[pandInd])==list):                baseEnd[pandInd]=taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseCount[pandInd]*\                (taskVar.experimentPandas['trialParameters'].loc[wtNum].pulseDur[pandInd]+\                taskVar.experimentPandas['trialParameters'].loc[wtNum].interPulseDur[pandInd])        for allIndsTrl in range(len(baseStart)):                            if taskVar.experimentPandas['trialParameters'].loc[wtNum].rewardStimulus[allIndsTrl]==1 or\            taskVar.experimentPandas['trialParameters'].loc[wtNum].catchStimulus[allIndsTrl]==1:                baseEnd[allIndsTrl]=max(baseEnd[allIndsTrl],taskVar.sesVarDict['responseWindowMax'])            totalDuration[allIndsTrl]=baseEnd[allIndsTrl]+baseStart[allIndsTrl]        estTimes.at[wtNum]=max(totalDuration)    if 'waitTime' in taskVar.experimentPandas['trialBaselines'].columns:        taskVar.experimentPandas['trialBaselines'].at[strtTrial:arrayLength-1,'waitTime']=\        estTimes.loc[strtTrial:arrayLength-1] # quirk of dataFrames or Series when using .loc upper limit inclusive    else:        taskVar.experimentPandas['trialBaselines']=pd.concat([taskVar.experimentPandas['trialBaselines'],estTimes],axis=1)#Populates sends Lists, the baseline or trial wait time, the trial first pyState, and increments taskVar.tTrial/taskVar.trialNum# !!! effectively calling this starts a new trial !!!# sets trialSamps[0] on all but first trials (set in initialize)# if run after it's call on the last scheduled trial sets sesVarDict.['sessionOn'] to zero killing the task and clears the send lists# resetNext=1 only resets the next send lists and returns a noNextSend value - this is used when/if new trial lists are generateddef populateTrialVariableLists(resetNext=0):    if resetNext==1 and taskVar.sesVarDict['trialNum']<taskVar.sesVarDict['totalTrials']-1: # this block should only be run    # if a trial has already started and new signals were generated for the next trial and on without this update block once.     # Here the trial num reflects the next trail index and this should only run if there is one trial left at least. It resets and re-populates    # the next trial only.        nNextBaseline=0        taskVar.nextSendList=pd.DataFrame(columns=taskVar.sendListColumns)        taskVar.nextWaitList=pd.DataFrame(columns=taskVar.sendListColumns)        # Set Next tracker        trialChannelInfo = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1,('chanToUse','chanToUseType')].values.tolist()        trialChannelInfo = [tuple(s) for s in trialChannelInfo]        # Get the pd indicies         trialSigalIndex = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1].index        trialIndexTuples =list(zip(np.full(trialSigalIndex.shape[0],taskVar.tTrial+1,dtype=np.uint32),trialSigalIndex))        # Check reward status        trialRewardStatus = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1,('rewardStimulus','catchStimulus')].values.tolist()        # If the channel type and number pair (the physical output) are unique, add them to the send list        for chInd in range(len(trialChannelInfo)):            if trialChannelInfo[chInd] not in taskVar.nextSendList.channelInfo.values.tolist():                taskVar.nextSendList=taskVar.nextSendList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                    np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)            else: # if they are duplicate, add them to the waitlist                taskVar.nextWaitList=taskVar.nextWaitList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                    np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)        #This is here so that it doesn't run on first trial        if taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial+1]['trialTime']==0: # check if no baseline            nNextBaseline=1        return nNextBaseline           elif taskVar.sesVarDict['trialNum']<taskVar.sesVarDict['totalTrials']: #if the trials have not been executed        taskVar.tTrial = taskVar.sesVarDict['trialNum'] # set the trial number        nNextBaseline=0        if taskVar.tTrial==0 and taskSer.tState==0: #if before task and teensy idle        #Here for the first trial we populate sendList and waitList only, which is done before the initiation of the trial clock        # If there is no baseLine then the pyState parameter is updated to in-trial here                        if taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial,'trialTime']==0: # check if no baseline                taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['waitTime']  #if so go to stim state                waitTimeToInt()                taskVar.pyState = 1                #TODO RUN THE Stim state header to determine state exit time and set wait time                # Wait time will be set in state 1 by stime scheduling function            else:                taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['trialTime'] #if not go to baseline                waitTimeToInt()                taskVar.pyState = 0            # Get the channel type and number for all the trial pd lines            trialChannelInfo = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial,('chanToUse','chanToUseType')].values.tolist()            trialChannelInfo = [tuple(s) for s in trialChannelInfo]            # Get the pd indicies             trialSigalIndex = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial].index            trialIndexTuples =list(zip(np.full(trialSigalIndex.shape[0],taskVar.tTrial,dtype=np.uint32),trialSigalIndex))            # Check reward status            trialRewardStatus = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial,('rewardStimulus','catchStimulus')].values.tolist()                 # If the channel type and number pair (the physical output) are unique, add them to the send list            lstSent=[]            for chInd in range(len(trialChannelInfo)):                #if trialChannelInfo[chInd] not in taskVar.sendList.channelInfo.values.tolist():                if trialChannelInfo[chInd] not in lstSent:                    lstSent.append(trialChannelInfo[chInd])                    taskVar.sendList=taskVar.sendList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                        np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)                else: # if they are duplicate, add them to the waitlist                    taskVar.waitList=taskVar.waitList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                        np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)            #If there are additional trials populate nextSendList and nextWaitList             # Additionally flag if the next trial has no baseline            if taskVar.sesVarDict['totalTrials']>1:                # Do the same thing but for the next trial stuff                trialChannelInfo = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1,('chanToUse','chanToUseType')].values.tolist()                trialChannelInfo = [tuple(s) for s in trialChannelInfo]                # Get the pd indicies                 trialSigalIndex = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1].index                trialIndexTuples =list(zip(np.full(trialSigalIndex.shape[0],taskVar.tTrial+1,dtype=np.uint32),trialSigalIndex))                # Check reward status                trialRewardStatus = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1,('rewardStimulus','catchStimulus')].values.tolist()                # If the channel type and number pair (the physical output) are unique, add them to the send list                lstSent=[]                for chInd in range(len(trialChannelInfo)):                    #if trialChannelInfo[chInd] not in taskVar.nextSendList.channelInfo.values.tolist():                    if trialChannelInfo[chInd] not in lstSent:                        lstSent.append(trialChannelInfo[chInd])                        taskVar.nextSendList=taskVar.nextSendList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                            np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)                    else: # if they are duplicate, add them to the waitlist                        taskVar.nextWaitList=taskVar.nextWaitList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                            np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)                print('the value is',taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial+1,'trialTime'],taskVar.experimentPandas['trialParameters'].loc[(taskVar.tTrial+1,0),'offset'])                                                                                                                     if (taskVar.nextSendList.shape[0]>0) and (((taskVar.nextSendList.shape[0]*12)+2) > varTimeToInt(taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial+1,'trialTime']+\                taskVar.experimentPandas['trialParameters'].loc[(taskVar.tTrial+1,0),'offset'])): # check if need to send next send in advance                    nNextBaseline=1            else:                nNextBaseline=1        elif taskVar.tTrial < taskVar.sesVarDict['totalTrials']-1: # else if it's before last trial... just set the tTrial, baseline, copy over vars, get next            if taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial,'trialTime']==0: # check if no baseline                taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['waitTime']  #if so go to stim state                waitTimeToInt()                taskVar.pyState = 1            else:                taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['trialTime'] #if not go to baseline                waitTimeToInt()                taskVar.pyState = 0            # Move Next tracker to current tracker            taskVar.sendList=taskVar.nextSendList.copy()            taskVar.waitList=taskVar.nextWaitList.copy()            taskVar.nextSendList=pd.DataFrame(columns=taskVar.sendListColumns)            taskVar.nextWaitList=pd.DataFrame(columns=taskVar.sendListColumns)            # Set Next tracker            trialChannelInfo = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1,('chanToUse','chanToUseType')].values.tolist()            trialChannelInfo = [tuple(s) for s in trialChannelInfo]            # Get the pd indicies             trialSigalIndex = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1].index            trialIndexTuples =list(zip(np.full(trialSigalIndex.shape[0],taskVar.tTrial+1,dtype=np.uint32),trialSigalIndex))            # Check reward status            trialRewardStatus = taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial+1,('rewardStimulus','catchStimulus')].values.tolist()            # If the channel type and number pair (the physical output) are unique, add them to the send list            lstSent=[]            for chInd in range(len(trialChannelInfo)):                if trialChannelInfo[chInd] not in lstSent:                    lstSent.append(trialChannelInfo[chInd])                #if trialChannelInfo[chInd] not in taskVar.nextSendList.channelInfo.values.tolist():                    taskVar.nextSendList=taskVar.nextSendList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                        np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)                else: # if they are duplicate, add them to the waitlist                    taskVar.nextWaitList=taskVar.nextWaitList.append(pd.DataFrame(np.array([0,0,trialIndexTuples[chInd],trialChannelInfo[chInd],\                        np.nan,np.nan,np.nan,np.nan,0,trialRewardStatus[chInd][0],trialRewardStatus[chInd][1]],dtype=object).reshape(1,-1),columns=taskVar.sendListColumns),ignore_index=True)            #This is here so that it doesn't run on first trial            taskVar.trialSamps[0]=taskVar.loopCnt-1            if (taskVar.nextSendList.shape[0]>0) and (((taskVar.nextSendList.shape[0]*12)+2) > varTimeToInt(taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial+1,'trialTime']+\            taskVar.experimentPandas['trialParameters'].loc[(taskVar.tTrial+1,0),'offset'])): # check if need to send next send in advance                nNextBaseline=1                       else: # else if it's last trial... just set the tTrial baseline, copy over vars            # do other stuff            if taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial,'trialTime']==0: # check if no baseline                taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['waitTime'] #if so go to stim state                waitTimeToInt()                taskVar.pyState = 1                #TODO RUN THE Stim state header to determine state exit time and set wait time                # Wait time will be set in state 1 by stime scheduling function            else:                taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['trialTime'] #if not go to baseline                waitTimeToInt()                taskVar.pyState = 0            # Move Next tracker to current tracker            taskVar.sendList=taskVar.nextSendList.copy()            taskVar.waitList=taskVar.nextWaitList.copy()            # clear next so that it doesn't foul other functions            taskVar.nextSendList=pd.DataFrame(columns=taskVar.sendListColumns)            taskVar.nextWaitList=pd.DataFrame(columns=taskVar.sendListColumns)            #This is here so that it doesn't run on first trial            taskVar.trialSamps[0]=taskVar.loopCnt-1            nNextBaseline=1                    # do the rest of trial maintenance stuff            # incrment the trial count and         #if pyState==1:        #    taskVar.waitTime=setStimEpochWaitTime()        #    waitTimeToInt()        taskVar.sesVarDict['trialNum']=taskVar.sesVarDict['trialNum']+1        #  inform the user via the terminal what's going on.        print('starting trial #{} of {}. Estimated Time {:.5f} [s]'.format(taskVar.sesVarDict['trialNum'],taskVar.sesVarDict['totalTrials'],\            taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['trialTime']+taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['waitTime']))        return nNextBaseline    #elif taskVar.sesVarDict['trialNum']>=taskVar.sesVarDict['totalTrials']:        #taskVar.sesVarDict['sessionOn']=0    else:        taskVar.sesVarDict['sessionOn']=0        taskVar.endedOnSchedule=True        #taskVar.sendList=pd.DataFrame(columns=taskVar.sendListColumns)        #taskVar.waitList=pd.DataFrame(columns=taskVar.sendListColumns)        #taskVar.nextSendList=pd.DataFrame(columns=taskVar.sendListColumns)        #taskVar.nextWaitList=pd.DataFrame(columns=taskVar.sendListColumns)    def updateRewardTracker(rwrdIndicies,sndFrm):    # taskVar.rewardTrackingColumns=['indexTuple','startTime','startInt','rsWindowStart','rsWindowEnd','rsReported',    # 'reportTime','respCueTime','respCueEnd','reward','catch','hit','miss','cr','fa','deliverReward','deliverRespCue','addTimeOut','rewardStart',    # 'rewardEnd','widthdrawRwd','evaluated','rwdDelivered','consumed','completed']    # Now called in compute start/end time. this will avoid later unaccounted for additions after timing interdependent cues occur (i.e. timeout cues)    for frmIndx in rwrdIndicies:                 rwrdIndexTuple = sndFrm.loc[frmIndx,'indexTuple'] # frmIndx indexes the sendList used, sndFrm is the sendList used        if (sndFrm.loc[frmIndx,'rewardStimulus']==1):            rwdVar='reward'                             # These must remain mutually exclusive, and if neither - do nothing        elif (sndFrm.loc[frmIndx,'catchStimulus']==1):            rwdVar='catch'        else:            rwdVar=[]            continue # If there are reward/catch signals  - don't do the following work        iTList = taskVar.rewardTracker.indexTuple.values.tolist()        # nwLn=False        if rwrdIndexTuple not in iTList:            # Append the tracker            taskVar.rewardTracker=taskVar.rewardTracker.append(pd.DataFrame(np.array([rwrdIndexTuple,np.nan,0,np.nan,np.nan,False,np.nan,np.nan,np.nan,False,False,\                False,False,False,False,False,False,False,np.nan,np.nan,False,False,-1,False,False],dtype=object).reshape(1,-1),columns=taskVar.rewardTrackingColumns),ignore_index=True)            rwrdTrkrInd = taskVar.rewardTracker.shape[0]-1            # nwLn=True        else:            rwrdTrkrInd = taskVar.rewardTracker.loc[taskVar.rewardTracker.indexTuple==rwrdIndexTuple].index.tolist()[0] #Using zero index to unpack, should be unique        # Now Just set everything        taskVar.rewardTracker.at[rwrdTrkrInd,'startTime']=sndFrm.loc[frmIndx,'startTime']        taskVar.rewardTracker.at[rwrdTrkrInd,'startInt']=sndFrm.loc[frmIndx,'startInt']        taskVar.rewardTracker.at[rwrdTrkrInd,'rsWindowStart']=sndFrm.loc[frmIndx,'startTime']+taskVar.sesVarDict['responseWindowMin']        taskVar.rewardTracker.at[rwrdTrkrInd,'rsWindowEnd']=sndFrm.loc[frmIndx,'startTime']+taskVar.sesVarDict['responseWindowMax']        taskVar.rewardTracker.at[rwrdTrkrInd,rwdVar]=True    # Make sure the list is sorted by the beginning of the response window to more easily evaluate in sequence in-task    # This equates to sorting by start time because the delat to response window is not dynamic by signal (for now)    taskVar.rewardTracker.sort_values(by='rsWindowStart',axis=0,inplace=True,ignore_index=True)    # Update the evaluation triggers    #strtMin=taskVar.rewardTracker.rsWindowStart.loc[(taskVar.rewardTracker['rsWindowStart']>=taskVar.curTime) & (taskVar.rewardTracker['evaluated']==False)].min()    #endMin=taskVar.rewardTracker.rsWindowEnd.loc[(taskVar.rewardTracker['rsWindowEnd']>=taskVar.curTime) & (taskVar.rewardTracker['evaluated']==False)].min()    taskVar.nextRspnsWinTimeStrt=taskVar.rewardTracker.rsWindowStart.loc[taskVar.rewardTracker['evaluated']==False].min()    taskVar.nextRspnsWinTimeEnd=taskVar.rewardTracker.rsWindowEnd.loc[taskVar.rewardTracker['evaluated']==False].min()-taskVar.sampleDt    #taskVar.nextRspnsWinTime=np.min([strtMin,endMin]) def evaluateRewardTimeOut():    # This is where if rewards are scheduled: look for licks, if found, evaluate hit.miss,cr,fa, also if necessary add a time bump of len nextsend *2 +4    #   so that the last full response window can be evaluated    runDeliver=False    if taskVar.rewardTracker.shape[0]>0:        #curTrialReward = taskVar.rewardTracker.loc[map(lambda indNum: indNum[0]==taskVar.tTrial,taskVar.rewardTracker.indexTuple.values)].index        # pull an index for each of the current-trial reward tests        # curResponseWins= taskVar.rewardTracker.loc[\        # (taskVar.rewardTracker['rsWindowStart']<=taskVar.timeLastLick) & (taskVar.rewardTracker['rsWindowEnd']>taskVar.timeLastLick)\        # & (taskVar.rewardTracker['evaluated']==False)].index        # index the rewards responded to        # now evaluate the response        #for thisRwd in np.intersect1d(curTrialReward,curResponseWins):            #Log that it was reported per last-lick logic        for thisRwd in range(taskVar.rewardTracker.shape[0]):            if taskVar.rewardTracker.loc[thisRwd,'indexTuple'][0]==taskVar.tTrial:                if taskVar.rewardTracker.loc[thisRwd,'evaluated']==False:                    if (taskVar.rewardTracker.loc[thisRwd,'rsWindowStart']<=taskVar.timeLastLick) & (taskVar.rewardTracker.loc[thisRwd,'rsWindowEnd']>taskVar.timeLastLick):                        taskVar.rewardTracker.at[thisRwd,'rsReported']=True                        taskVar.rewardTracker.at[thisRwd,'reportTime']=taskVar.timeLastLick                        if taskVar.rewardTracker.loc[thisRwd,'reward']:                            taskVar.rewardTracker.at[thisRwd,'hit']=True                            print('hit')                            if (taskVar.sesVarDict['rewardHit']==1) and taskVar.rewardSet:                                # compute the reward timing                                taskVar.rewardTracker.at[thisRwd,'deliverReward']=True                                runDeliver=True                                taskVar.rewardTracker.at[thisRwd,'rewardStart']=np.max([taskVar.timeLastLick+taskVar.sesVarDict['rwdDelay'],\                                taskVar.sesVarDict['minStim']+taskVar.rewardTracker.loc[thisRwd,'startTime']]) #set reward start                                # to the latest programmed delay                                taskVar.rewardTracker.at[thisRwd,'rewardEnd']=taskVar.rewardTracker.loc[thisRwd,'rewardStart']\                                +taskVar.sesVarDict['rewardWindow']                                # Set widthdraw, no 'if' needed - equivalent                                taskVar.rewardTracker.at[thisRwd,'widthdrawRwd']=taskVar.widthdrawSet                            if taskVar.sesVarDict['timeoutHit']==1 and taskVar.timeOutSet:                                # Flag a Time Out to be enforced in another function (note not mutually exclusive)                                taskVar.rewardTracker.at[thisRwd,'addTimeOut']=True                                #taskVar.flagTimeOut=True                                runDeliver=True                            if taskVar.hitCueSet:                                #Calculate the response to cue time                                taskVar.rewardTracker.at[thisRwd,'respCueTime']=taskVar.timeLastLick+taskVar.sesVarDict['respToCueDelay']                                taskVar.rewardTracker.at[thisRwd,'respCueEnd']=taskVar.timeLastLick+taskVar.sesVarDict['respToCueDelay']+taskVar.sesVarDict['hitCueDur']                                taskVar.rewardTracker.at[thisRwd,'deliverRespCue']=True                                runDeliver=True                            taskVar.rewardTracker.at[thisRwd,'evaluated']=True                        elif taskVar.rewardTracker.loc[thisRwd,'catch']:                            taskVar.rewardTracker.at[thisRwd,'fa']=True                            print('false alarm')                            if (taskVar.sesVarDict['rewardFa']==1) and taskVar.rewardSet:                                # compute the reward timing                                taskVar.rewardTracker.at[thisRwd,'deliverReward']=True                                runDeliver=True                                taskVar.rewardTracker.at[thisRwd,'rewardStart']=np.max([taskVar.timeLastLick+taskVar.sesVarDict['rwdDelay'],\                                taskVar.sesVarDict['minStim']+taskVar.rewardTracker.loc[thisRwd,'startTime']]) #set reward start                                # to the latest programmed delay                                taskVar.rewardTracker.at[thisRwd,'rewardEnd']=taskVar.rewardTracker.loc[thisRwd,'rewardStart']\                                +taskVar.sesVarDict['rewardWindow']                                # Set widthdraw, no 'if' needed - equivalent                                taskVar.rewardTracker.at[thisRwd,'widthdrawRwd']=taskVar.widthdrawSet                            if taskVar.sesVarDict['timeoutFa']==1 and taskVar.timeOutSet:                                # Flag a Time Out to be enforced in another function (note not mutually exclusive)                                taskVar.rewardTracker.at[thisRwd,'addTimeOut']=True                                #taskVar.flagTimeOut=True                                runDeliver=True                            if taskVar.faCueSet:                                #Calculate the response to cue time                                taskVar.rewardTracker.at[thisRwd,'respCueTime']=taskVar.timeLastLick+taskVar.sesVarDict['respToCueDelay']                                taskVar.rewardTracker.at[thisRwd,'respCueEnd']=taskVar.timeLastLick+taskVar.sesVarDict['respToCueDelay']+taskVar.sesVarDict['faCueDur']                                taskVar.rewardTracker.at[thisRwd,'deliverRespCue']=True                                runDeliver=True                            taskVar.rewardTracker.at[thisRwd,'evaluated']=True                    elif taskVar.rewardTracker.loc[thisRwd,'rsWindowEnd']-taskVar.sampleDt<=taskVar.curTime:                        # Window end is not inclusive, and if this is reached, the last included sample would have been evaluated for licks. Without the -dt                        # argument, misses and correct rejections can go un evlauated                        #        # Now look for misses and correct rejections        # pastResponseWins= taskVar.rewardTracker.loc[(taskVar.rewardTracker['rsWindowEnd']<=taskVar.curTime) & (taskVar.rewardTracker['evaluated']==False)].index        # for thisRwd in pastResponseWins:                        #Log that it was not reported                        # LEFT OFF update the following tmeplate for MISS and CR                        if taskVar.rewardTracker.loc[thisRwd,'reward']:                            taskVar.rewardTracker.at[thisRwd,'miss']=True                            print('miss')                            if (taskVar.sesVarDict['rewardMiss']==1) and taskVar.rewardSet:                                # compute the reward timing                                taskVar.rewardTracker.at[thisRwd,'deliverReward']=True                                runDeliver=True                                taskVar.rewardTracker.at[thisRwd,'rewardStart']=np.max([taskVar.curTime,\                                taskVar.sesVarDict['minStim']+taskVar.rewardTracker.loc[thisRwd,'startTime']]) #set reward start                                # to the latest programmed delay                                taskVar.rewardTracker.at[thisRwd,'rewardEnd']=taskVar.rewardTracker.loc[thisRwd,'rewardStart']\                                +taskVar.sesVarDict['rewardWindow']                                # Set widthdraw, no 'if' needed - equivalent                                taskVar.rewardTracker.at[thisRwd,'widthdrawRwd']=taskVar.widthdrawSet                                                if taskVar.sesVarDict['timeoutMiss']==1 and taskVar.timeOutSet:                                # Flag a Time Out to be enforced in another function (note not mutually exclusive)                                taskVar.rewardTracker.at[thisRwd,'addTimeOut']=True                                #taskVar.flagTimeOut=True                                runDeliver=True                                             if taskVar.missCueSet:                                taskVar.rewardTracker.at[thisRwd,'respCueTime']=taskVar.curTime                                taskVar.rewardTracker.at[thisRwd,'respCueEnd']=taskVar.curTime+taskVar.sesVarDict['missCueDur']                                taskVar.rewardTracker.at[thisRwd,'deliverRespCue']=True                                runDeliver=True                                                taskVar.rewardTracker.at[thisRwd,'evaluated']=True                        elif taskVar.rewardTracker.loc[thisRwd,'catch']:                            taskVar.rewardTracker.at[thisRwd,'cr']=True                            print('corr rejct')                            if (taskVar.sesVarDict['rewardCr']==1) and taskVar.rewardSet:                                # compute the reward timing                                taskVar.rewardTracker.at[thisRwd,'deliverReward']=True                                runDeliver=True                                taskVar.rewardTracker.at[thisRwd,'rewardStart']=np.max([taskVar.curTime,\                                taskVar.sesVarDict['minStim']+taskVar.rewardTracker.loc[thisRwd,'startTime']]) #set reward start                                # to the latest programmed delay                                taskVar.rewardTracker.at[thisRwd,'rewardEnd']=taskVar.rewardTracker.loc[thisRwd,'rewardStart']\                                +taskVar.sesVarDict['rewardWindow']                                # Set widthdraw, no 'if' needed - equivalent                                taskVar.rewardTracker.at[thisRwd,'widthdrawRwd']=taskVar.widthdrawSet                                                if taskVar.sesVarDict['timeoutCr']==1 and taskVar.timeOutSet:                                # Flag a Time Out to be enforced in another function (note not mutually exclusive)                                taskVar.rewardTracker.at[thisRwd,'addTimeOut']=True                                #taskVar.flagTimeOut=True                                runDeliver=True                                                   if taskVar.crCueSet:                                taskVar.rewardTracker.at[thisRwd,'respCueTime']=taskVar.curTime                                taskVar.rewardTracker.at[thisRwd,'respCueEnd']=taskVar.curTime+taskVar.sesVarDict['crCueDur']                                taskVar.rewardTracker.at[thisRwd,'deliverRespCue']=True                                runDeliver=True                                                  taskVar.rewardTracker.at[thisRwd,'evaluated']=True        #These two are for making sure that everything gets evaluated (licks and ends)        #strtMin=taskVar.rewardTracker.rsWindowStart.loc[(taskVar.rewardTracker['rsWindowStart']>taskVar.curTime) & (taskVar.rewardTracker['evaluated']==False)].min()        taskVar.nextRspnsWinTimeStrt=taskVar.rewardTracker.rsWindowStart.loc[(taskVar.rewardTracker['evaluated']==False)].min()        #endMin=taskVar.rewardTracker.rsWindowEnd.loc[(taskVar.rewardTracker['rsWindowEnd']>taskVar.curTime) & (taskVar.rewardTracker['evaluated']==False)].min()        taskVar.nextRspnsWinTimeEnd=taskVar.rewardTracker.rsWindowEnd.loc[(taskVar.rewardTracker['evaluated']==False)].min()-taskVar.sampleDt        #taskVar.nextRspnsWinTime=np.min([strtMin,endMin])        #THis is for judging water consumed        #taskVar.nextRwdWinTimeStrt=taskVar.rewardTracker.rewardStart.loc[(~taskVar.rewardTracker['rewardStart'].isnull()) & (~taskVar.rewardTracker['consumed']) &\        taskVar.nextRwdWinTimeStrt=taskVar.rewardTracker.rewardStart.loc[(taskVar.rewardTracker['consumed']==False) &\        (taskVar.rewardTracker['rewardEnd'].gt(taskVar.curTime))].min()        #This is for judging widthdraw time        #endMin=taskVar.rewardTracker.rewardEnd.loc[(taskVar.rewardTracker['rewardEnd']>=taskVar.curTime) & (taskVar.rewardTracker['completed']==False)].min()        #taskVar.nextRwdWinTimeEnd=taskVar.rewardTracker.rewardEnd.loc[(taskVar.rewardTracker['rewardEnd'].ge(taskVar.curTime)) & (taskVar.rewardTracker['widthdrawRwd'])].min()        taskVar.nextRwdWinTimeEnd=taskVar.rewardTracker.rewardEnd.loc[(taskVar.rewardTracker['widthdrawRwd'])].min()        #taskVar.nextRwdWinTime=np.min([strtMin,endMin])        #This is for triggering the response cues        #taskVar.nextCueTime=taskVar.rewardTracker.respCueTime.loc[taskVar.rewardTracker.respCueTime.ge(taskVar.curTime)].min()        taskVar.nextCueTime=taskVar.rewardTracker.respCueTime.loc[taskVar.rewardTracker.deliverRespCue].min()        #This is for insuring reward signals sent        #taskVar.nextRewardTime = taskVar.rewardTracker.rewardStart.loc[(taskVar.rewardTracker['deliverReward']) & (taskVar.rewardTracker['rwdDelivered']==-1)].min()        taskVar.nextRewardTime = taskVar.rewardTracker.rewardStart.loc[(taskVar.rewardTracker['deliverReward'])].min()    return runDeliver        def deliverRewardResponse():    # Here we deliver reward signals, deliver cues, then flip completed, if any time out flip time out bit, evaluate water consumed, but first     #   if there are any end-times greater than current end time and current time is ahead of the time latch - timeBump=the differnce     # evaluate water consumed    # update taskVar.nextRspnsWinTime, taskVar.nextRwdWinTime, and taskVar.nextCueTime    # update pandas    #runSchedule=False    addedATO=False    if taskVar.rewardTracker.shape[0]>0:        curTrialReward = taskVar.rewardTracker.loc[map(lambda indNum: indNum[0]==taskVar.tTrial,taskVar.rewardTracker.indexTuple.values)].index        #Deliver TO        if (not taskVar.flagTimeOut) and taskVar.rewardTracker.addTimeOut.any():            taskVar.rewardTracker.loc[:,'addTimeOut']=False            if (taskVar.waitInt-taskVar.curTrialInt)>=taskVar.timeLatch:                # If so run time bump routine                addTime(taskVar.sesVarDict['timeoutDur'],1)                calculateTimeLatch() # Only makes sense to use this after TO case add time (other time adds effect use of TL but not the TL value itself)                # Log that a timeout was given                taskVar.timingData.at[taskVar.tTrial,'toEnforced']=True                if taskVar.timeoutCueSet:                                 curTrialEnd = taskVar.startTime+taskVar.waitTime                    timeAddNeeded = taskVar.rewardTracker.loc[((curTrialEnd<taskVar.rewardTracker.rsWindowEnd+taskVar.sesVarDict['timeoutCueDur']) & (taskVar.rewardTracker['evaluated']==False))\                    |(curTrialEnd<taskVar.rewardTracker.rewardEnd+taskVar.sesVarDict['timeoutCueDur'])| (curTrialEnd<taskVar.rewardTracker.respCueEnd+taskVar.sesVarDict['timeoutCueDur'])].index                    maxTimePoint= taskVar.rewardTracker.loc[np.intersect1d(curTrialReward,timeAddNeeded),['rsWindowEnd','respCueEnd','rewardEnd']].max(axis=0).max()                    if not np.isnan(maxTimePoint):                        addTime(timeToAdd=(maxTimePoint+taskVar.sesVarDict['timeoutCueDur'])-curTrialEnd)                        taskVar.nextTimeOutCue=maxTimePoint                    else:                        taskVar.nextTimeOutCue=curTrialEnd-taskVar.sesVarDict['timeoutCueDur']                #runSchedule=True                addedATO=True                taskVar.flagTimeOut=True        else:            taskVar.rewardTracker.loc[:,'addTimeOut']=False        # evaluate whether time can be delayed based on latch        if (taskVar.waitInt-taskVar.curTrialInt)>=taskVar.timeLatch:            # If so run time bump routine            curTrialEnd = taskVar.startTime+taskVar.waitTime            if taskVar.timeoutCueSet and taskVar.flagTimeOut and (not addedATO):                #                timeAddNeeded = taskVar.rewardTracker.loc[((curTrialEnd<taskVar.rewardTracker.rsWindowEnd+taskVar.sesVarDict['timeoutCueDur']) & (taskVar.rewardTracker['evaluated']==False))\                |(curTrialEnd<taskVar.rewardTracker.rewardEnd+taskVar.sesVarDict['timeoutCueDur'])| (curTrialEnd<taskVar.rewardTracker.respCueEnd+taskVar.sesVarDict['timeoutCueDur'])].index                maxTimePoint= taskVar.rewardTracker.loc[np.intersect1d(curTrialReward,timeAddNeeded),['rsWindowEnd','respCueEnd','rewardEnd']].max(axis=0).max()                if not np.isnan(maxTimePoint):                    addTime(timeToAdd=(maxTimePoint+taskVar.sesVarDict['timeoutCueDur'])-curTrialEnd)                    taskVar.nextTimeOutCue=maxTimePoint                    #runSchedule=True                            else:                #                timeAddNeeded = taskVar.rewardTracker.loc[((curTrialEnd<taskVar.rewardTracker.rsWindowEnd) & (taskVar.rewardTracker['evaluated']==False))\                |(curTrialEnd<taskVar.rewardTracker.rewardEnd)| (curTrialEnd<taskVar.rewardTracker.respCueEnd)].index                maxTimePoint= taskVar.rewardTracker.loc[np.intersect1d(curTrialReward,timeAddNeeded),['rsWindowEnd','respCueEnd','rewardEnd']].max(axis=0).max()                if not np.isnan(maxTimePoint):                    addTime(timeToAdd=maxTimePoint-curTrialEnd)                    #runSchedule=True        #Deliver TO Cue        if not np.isnan(taskVar.nextTimeOutCue):            if taskVar.curTime>= taskVar.nextTimeOutCue-taskVar.sampleDt:                addSerialMessage(np.nan,(taskVar.sesVarDict['timeoutCueChannel'],1),'startTime',-1,1)                #Log the expected cue time                taskVar.timingData.at[taskVar.tTrial,'timeOutCues']=taskVar.curTime+taskVar.sampleDt                taskVar.nextTimeOutCue=np.nan        #Deliver Cues taskVar.sesVarDict['rewardChannel']. rewardDur        responseCuesNeeded = taskVar.rewardTracker.respCueTime.loc[taskVar.rewardTracker.deliverRespCue].min()        if not np.isnan(responseCuesNeeded):            curRspns = taskVar.rewardTracker.loc[taskVar.rewardTracker['respCueTime']==responseCuesNeeded].index            for curRspInd in curRspns:                if taskVar.curTime>= taskVar.rewardTracker.loc[curRspInd,'respCueTime']-taskVar.sampleDt:                    # figure out which cue it is                    for rspCueNm in ['hit','miss','cr','fa']:                        if taskVar.rewardTracker.loc[curRspInd,rspCueNm]:                            #Send the message                             addSerialMessage(np.nan,(taskVar.sesVarDict[rspCueNm+'CueChannel'],1),'startTime',-1,1)                            break                    taskVar.rewardTracker.at[curRspInd,'deliverRespCue']=False        # Deliver widthdraw signals        widthdrawNeeded = taskVar.rewardTracker.rewardEnd.loc[(taskVar.rewardTracker['widthdrawRwd']) & (~(taskVar.rewardTracker['rwdDelivered']==-1))].min()        if not np.isnan(widthdrawNeeded):            if taskVar.curTime>=widthdrawNeeded-taskVar.sampleDt:                # If it is within one loop of the target send a reward and append it first                addSerialMessage(np.nan,(taskVar.sesVarDict['widthdrawChannel'],1),'startTime',-1,1)                trackInds = taskVar.rewardTracker.loc[taskVar.rewardTracker['rewardEnd']==widthdrawNeeded].index                taskVar.rewardTracker.loc[trackInds,'widthdrawRwd']=False        # Deliver reward Signals        rewardNeeded = taskVar.rewardTracker.rewardStart.loc[(taskVar.rewardTracker['deliverReward'])].min()        if not np.isnan(rewardNeeded):            rwrdInt = varTimeToInt(rewardNeeded)            if taskVar.curInt>=rwrdInt-1:                # If it is within one loop of the target send a reward and append it first                addSerialMessage(np.nan,(taskVar.sesVarDict['rewardChannel'],1),'startTime',-1,1)                trackInds = taskVar.rewardTracker.loc[taskVar.rewardTracker['rewardStart']==rewardNeeded].index                taskVar.rewardTracker.loc[trackInds,'rwdDelivered']=taskVar.curInt+1. #Best estimated, could be one sample later than this                taskVar.rewardTracker.loc[trackInds,'deliverReward']=False        # Water consumed        curConsumedWins= taskVar.rewardTracker.loc[(~(taskVar.rewardTracker['rwdDelivered']==-1)) &\        (taskVar.rewardTracker['rewardStart']<=taskVar.timeLastLick) & (taskVar.rewardTracker['rewardEnd']>taskVar.timeLastLick)].index        if len(curConsumedWins)>0:            taskVar.rewardTracker.loc[curConsumedWins,'consumed']=True        #This is for judging widthdraw time        #Removed complete lines in tracker        removeTracks = taskVar.rewardTracker.loc[(taskVar.rewardTracker['evaluated']) & (taskVar.rewardTracker['deliverReward']==False) \        & (taskVar.rewardTracker['deliverRespCue']==False) & (taskVar.rewardTracker['widthdrawRwd']==False) & ((taskVar.rewardTracker['consumed'])\        | (taskVar.curTime>=taskVar.rewardTracker['rewardEnd']))].index        if taskVar.curTrialInt>=taskVar.waitInt:            curTrialCompleted=np.union1d(removeTracks,curTrialReward)        else:            curTrialCompleted=removeTracks        taskVar.rewardTracker.loc[curTrialCompleted,'completed']=True        taskVar.trialData=taskVar.trialData.append(taskVar.rewardTracker.loc[curTrialCompleted,taskVar.trialDataColumns],ignore_index=True)        taskVar.rewardTracker.drop(curTrialCompleted,axis=0,inplace=True)        taskVar.rewardTracker.reset_index(drop=True,inplace=True)        taskVar.nextRspnsWinTimeStrt=taskVar.rewardTracker.rsWindowStart.loc[(taskVar.rewardTracker['evaluated']==False)].min()        taskVar.nextRspnsWinTimeEnd=taskVar.rewardTracker.rsWindowEnd.loc[(taskVar.rewardTracker['evaluated']==False)].min()-taskVar.sampleDt        taskVar.nextRwdWinTimeStrt=taskVar.rewardTracker.rewardStart.loc[(taskVar.rewardTracker['consumed']==False) &\        (taskVar.rewardTracker['rewardEnd'].gt(taskVar.curTime))].min()        taskVar.nextRewardTime = taskVar.rewardTracker.rewardStart.loc[(taskVar.rewardTracker['deliverReward'])].min()            taskVar.nextRwdWinTimeEnd=taskVar.rewardTracker.rewardEnd.loc[(taskVar.rewardTracker['widthdrawRwd'])].min()        taskVar.nextCueTime=taskVar.rewardTracker.respCueTime.loc[taskVar.rewardTracker.deliverRespCue].min()                            #return runScheduledef calculateTimeLatch():    #Due to unpredictability in mouse responses, and due to time required to send serial updates, there is a limit in which time-bumps can be added for    # reward delivery or for time outs. Ideally this is completely circumvented by adding baselines or offsetts or both but to avoid signal misfires, this    # evaluates the absolute limit in which time of signals can be altered by test-subject responses based on trial structure and locks out alterations after    # this point    # Call this in populate    if taskVar.tTrial < taskVar.sesVarDict['totalTrials']-1:        if taskVar.pyState==1:            # In this case we are waiting on licks to add reward epochs or adding a time out. The limiting factor will be next send list              # evaluate the number of increments len(nextsend)*3+2, then compare it to vartimetoint(next baseline +min (next offset)).             # if less than, latch = neededincrements- vart time to int stiff            # *3 +2 (signals, buffer messgages, accounting for where [loop] the teensy reads new messages)            minIncrementsNeeded = (taskVar.nextSendList.shape[0]*3)+2            if minIncrementsNeeded>2:                incrementsAvailable = varTimeToInt(taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial+1,'trialTime']+\                taskVar.experimentPandas['trialParameters'].loc[(taskVar.tTrial+1,0),'offset']) # can't use nextsend start time because might be np.nan or pre-adjustment                # no need to min() the offset column, they are sorted.                 if minIncrementsNeeded>incrementsAvailable:                    taskVar.timeLatch=minIncrementsNeeded-incrementsAvailable                else:                    taskVar.timeLatch=0                    #indexTuple                    #taskVar.experimentPandas['trialParameters'].loc[taskVar.tTrial            else:                taskVar.timeLatch=0        else:            # in this case we are adding time due to enforcing no-lick / no-run. The limiting factor will be the immediate send list. Here, evaluate the length            # of the send lists relative to the immediate trial offset            minIncrementsNeeded = (taskVar.sendList.shape[0]*3)+2            incrementsAvailable = varTimeToInt(taskVar.experimentPandas['trialParameters'].loc[(taskVar.tTrial,0),'offset']) # no need to min() the offset column, they are sorted.             #TODO Change nonextwait to look at next wait + offset vs. len next send list * 13+2 (buffered times, params, and loop sync)            if minIncrementsNeeded>incrementsAvailable:                taskVar.timeLatch=minIncrementsNeeded-incrementsAvailable            else:                taskVar.timeLatch=0    else:        taskVar.timeLatch=0def addTime(timeToAdd=0.0,tOCase=0):    #this function increases 'waitTime', marks the panda for adding time, sets the start Times of appropriate send lists to 0, start time sent to 0    if taskVar.pyState==1:        #In this case we reset the nextSend list only bc we don't add time to an experiment in progress.        if tOCase and (taskVar.tTrial+1<taskVar.sesVarDict['totalTrials']):            #in this case, we are adding baseline to next trial. we append TO enforced.            taskVar.experimentPandas['trialBaselines'].at[taskVar.tTrial+1,'trialTime']=\            taskVar.experimentPandas['trialBaselines'].loc[taskVar.tTrial+1,'trialTime']+timeToAdd            #We do NOT change taskVar.noNextWait here because that changes how schedule function sends signal paramenters            #   within-trial, and if this occurs on a nNW=1 changed to nNW=0 case (which is the only change adding time can make)            #   I could cause partially sent signals to go un-updated and to fire early and/or signal cross talk.        else:            #Otherwise we are adding current wait time due to reward delivery            taskVar.waitTime = taskVar.waitTime+timeToAdd            waitTimeToInt()                        taskVar.experimentPandas['trialBaselines'].at[taskVar.tTrial,'waitTime']=taskVar.waitTime        taskVar.nextSendList.loc[:,'startSent']=0        taskVar.nextSendList.loc[:,'startTime']=np.nan        taskVar.nextSendList.loc[:,'startInt']=np.nan        taskVar.nextSendList.loc[:,'endTime']=np.nan        taskVar.nextSendList.loc[:,'endInt']=np.nan        taskVar.scheduleCheck=taskVar.curTrialInt    else:        # In this case, we reset the sendlist, bc the waitlist does not get calculated, nor does next send, and last next send which may have been sent, is         # now the send list        # in theory this should all be a no lick or no run delay, but due to uncertainty append those lists in nolick / no run routines - not here        taskVar.waitTime = taskVar.waitTime+timeToAdd        waitTimeToInt()        taskVar.experimentPandas['trialBaselines'].at[taskVar.tTrial,'trialTime']=taskVar.waitTime        taskVar.sendList.loc[:,'startSent']=0        taskVar.sendList.loc[:,'startTime']=np.nan        taskVar.sendList.loc[:,'startInt']=np.nan        taskVar.sendList.loc[:,'endTime']=np.nan        taskVar.sendList.loc[:,'endInt']=np.nan        taskVar.scheduleCheck=taskVar.curTrialInt        def addSerialMessage(pdIndicies,chnlInfo,prmName,prmVal,apndFrst=0,bufferIt=0):    scdMsg=pd.DataFrame(columns=taskVar.scheduledMessageColumns) # initialize a message pack    #taskVar.scheduledMessageColumns=['indexTuple','channelInfo','paramName','paramValue']    if prmName in taskVar.sendParametersDict['chanToUseNeeded']:        sigIndex=pdIndicies        if prmName=='startTime':            paramOrStart=1        else:            paramOrStart=0        # if prmName=='amp' or prmName=='pulseCount':        #     prmVal=int(prmVal)        if bufferIt==1:            if chnlInfo not in taskVar.bufferDict.keys():                # Initialize channel at zero (updated by next send)                taskVar.bufferDict[chnlInfo]=0                                    #Add the open buffer command to the sending queue            scdMsg=scdMsg.append(pd.DataFrame(np.array([pdIndicies,chnlInfo,'buffering',1\                ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)              # Log that the buffer open is pending            scdMsg=scdMsg.append(pd.DataFrame(np.array([pdIndicies,chnlInfo,prmName,prmVal\                ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                  #Add the CLOSE buffer command to the sending queue            scdMsg=scdMsg.append(pd.DataFrame(np.array([pdIndicies,chnlInfo,'buffering',0\                ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                          taskVar.scheduledMessages=taskVar.scheduledMessages.append(scdMsg,ignore_index=True)        else:            # create the message            if chnlInfo not in taskVar.bufferDict.keys():                # Initialize channel at zero (updated by next send)                taskVar.bufferDict[chnlInfo]=0            scdMsg=pd.DataFrame(np.array([pdIndicies,chnlInfo,prmName,prmVal],dtype=object).reshape(1,-1),\                columns=taskVar.scheduledMessageColumns)            if (apndFrst==0) or (taskVar.bufferDict[chnlInfo]==1):                # just append to the list                taskVar.scheduledMessages=taskVar.scheduledMessages.append(scdMsg,ignore_index=True)            else:                taskVar.scheduledMessages=scdMsg.append(taskVar.scheduledMessages,ignore_index=True)       else:        # create the message        scdMsg=pd.DataFrame(np.array([pdIndicies,chnlInfo,prmName,prmVal],dtype=object).reshape(1,-1),\            columns=taskVar.scheduledMessageColumns)        if apndFrst==0:            # just append to the list            taskVar.scheduledMessages=taskVar.scheduledMessages.append(scdMsg,ignore_index=True)        else:            taskVar.scheduledMessages=scdMsg.append(taskVar.scheduledMessages,ignore_index=True)   #Reads selected lines from the sendLists and organizes the required parameters for each signal or the start time info into a list used# to create the individual serial messages that will be transmitted. # If nothing has been sent to the physical channel a sent-mesages tracker line is initialized (sentParametersCurrent) for it, and if #   it is a buffered signal and the channel is not in the buffered parameter tracker a line is initialized there# For buffered signals open and close buffer messages are added to the beginning and end of the channel signal listsdef sendListReader(pdIndicies,paramOrStart,thePdFrame,trackerIndicies,bufferIt=0, apndFrst=0):    #initializes selected signal channels into sent message trackers, if start time is messge for reward or catch    # then calls update Reward to add or update line to reward window or time out and sorts them    # appends the messages to send to message list either at end by default or at first    # append First will not work if channel's buffer is open, appends end - avoids unpredictable behaviors    #taskVar.sendListColumns=['paramSent','startSent','indexTuple','channelInfo','startTime','startInt','endTime','endInt','buffering','rewardStimulus','catchStimulus']        # taskVar.sentParamColumns=['indexTuple','channelInfo','startTime','endTime','amp','pulseDur',\        # 'pulseUpDur','interPulseDur','pulseCount','pulseTrainDur','waveform','buffering']        # taskVar.sentParamBuffColumns=['indexTuple','channelInfo','startTime','endTime','amp','pulseDur',\        # 'pulseUpDur','interPulseDur','pulseCount','pulseTrainDur','waveform','pendingBuffOpen','pendingBuffClose']    # previous sent-parameter tracking (above) removed for debugging (maybe permanent) but necessary to keep track of buffer opening    # on sendNextCommand to allow for append-first without command cross-talk    # so we enter the channel into a dictionary here, and sendNext keeps track of when the buffer line is open     if bufferIt==1:        # Do the buffer stuff        for trackInd in trackerIndicies:            if thePdFrame.loc[trackInd,'channelInfo'][1]!=2:                if thePdFrame.loc[trackInd].channelInfo not in taskVar.bufferDict.keys():                    # Initialize channel at zero (updated by next send)                    taskVar.bufferDict[thePdFrame.loc[trackInd].channelInfo]=0                scdMsg=pd.DataFrame(columns=taskVar.scheduledMessageColumns) # initialize a message pack                #Add the open buffer command to the sending queue                scdMsg=scdMsg.append(pd.DataFrame(np.array([\                    thePdFrame.loc[trackInd].indexTuple,thePdFrame.loc[trackInd].channelInfo,'buffering',1\                    ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                                    if paramOrStart==1:                    #Start Time                    scdMsg=scdMsg.append(pd.DataFrame(np.array([\                        thePdFrame.loc[trackInd].indexTuple,thePdFrame.loc[trackInd].channelInfo,'startTime',\                        thePdFrame.loc[trackInd].startTime\                        ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                    # if (thePdFrame.loc[trackInd].rewardStimulus==1) or (thePdFrame.loc[trackInd].catchStimulus==1):                    #     updateRewardTracker(trackInd,thePdFrame)                else:                    #                    for colNm in ['amp','pulseDur','pulseUpDur','interPulseDur','pulseCount','pulseTrainDur','waveform']:                        paramVal=eval("taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].{}".format(colNm))                        if not(np.isnan(paramVal)):                            scdMsg=scdMsg.append(pd.DataFrame(np.array([\                            thePdFrame.loc[trackInd].indexTuple,thePdFrame.loc[trackInd].channelInfo,colNm,paramVal\                            ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                #Add the CLOSE buffer command to the sending queue                scdMsg=scdMsg.append(pd.DataFrame(np.array([\                    thePdFrame.loc[trackInd].indexTuple,thePdFrame.loc[trackInd].channelInfo,'buffering',0\                    ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                    taskVar.scheduledMessages=taskVar.scheduledMessages.append(scdMsg,ignore_index=True)    else:        for trackInd in trackerIndicies:            if thePdFrame.loc[trackInd,'channelInfo'][1]!=2:                #flagMeSomeBuff=0                #alreadyBuffing=thePdFrame.loc[trackInd].buffering                #if alreadyBuffing==1:                #    if thePdFrame.loc[trackInd].startInt>taskVar.curInt:                #        flagMeSomeBuff=1 # this bad boy should be buffing                if thePdFrame.loc[trackInd].channelInfo not in taskVar.bufferDict.keys():                    # Initialize channel at zero (updated by next send)                    taskVar.bufferDict[thePdFrame.loc[trackInd].channelInfo]=0                sigIndex=thePdFrame.loc[trackInd].indexTuple                scdMsg=pd.DataFrame(columns=taskVar.scheduledMessageColumns) # initialize a message pack                if paramOrStart==1:                    #Start Time                    scdMsg=scdMsg.append(pd.DataFrame(np.array([\                        thePdFrame.loc[trackInd].indexTuple,thePdFrame.loc[trackInd].channelInfo,'startTime',\                        thePdFrame.loc[trackInd].startTime\                        ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                    # if (thePdFrame.loc[trackInd].rewardStimulus==1) or (thePdFrame.loc[trackInd].catchStimulus==1):                    #     updateRewardTracker(trackInd,thePdFrame)                else:                    #                    for colNm in ['amp','pulseDur','pulseUpDur','interPulseDur','pulseCount','pulseTrainDur','waveform']:                        paramVal=eval("taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].{}".format(colNm))                        if not(np.isnan(paramVal)):                            scdMsg=scdMsg.append(pd.DataFrame(np.array([\                            thePdFrame.loc[trackInd].indexTuple,thePdFrame.loc[trackInd].channelInfo,colNm,paramVal\                            ],dtype=object).reshape(1,-1),columns=taskVar.scheduledMessageColumns),ignore_index=True)                if apndFrst==0:                    # just append to the list                    taskVar.scheduledMessages=taskVar.scheduledMessages.append(scdMsg,ignore_index=True)                elif taskVar.bufferDict[thePdFrame.loc[trackInd].channelInfo]==1:                    # don't append first if currently buffer-sending a signal on this channel                    taskVar.scheduledMessages=taskVar.scheduledMessages.append(scdMsg,ignore_index=True)                else:                    taskVar.scheduledMessages=scdMsg.append(taskVar.scheduledMessages,ignore_index=True)    return thePdFramedef sendNextCommnd(resendLast=0,overridePause=False):    #taskVar.scheduledMessageColumns=['indexTuple','channelInfo','paramName','paramValue']    #taskVar.sendingNow=False    #taskVar.pauseSending=False    if resendLast:        lsndTxt= taskVar.lastSentMessage.loc[0,'sndTxt']        taskSer.teensy.write(lsndTxt.encode('utf-8'))  # Send the message         taskVar.resendCount+=1    elif (len(taskVar.scheduledMessages)>0) and (taskVar.pauseSending==False):        #elif (len(taskVar.scheduledMessages)>0) and ((taskVar.pauseSending==False) or (overridePause==True)):        # messges stuff        taskVar.sendingNow=True # Pause sendding and sending now prevent problems with shared scheduledMessages variable between run string and GUI        chnToUz=np.nan        sendParamName=taskVar.scheduledMessages.loc[0].paramName        sendIndex = taskVar.scheduledMessages.loc[0].indexTuple        sendChannelInfo = taskVar.scheduledMessages.loc[0].channelInfo        sendParamValue = taskVar.scheduledMessages.loc[0].paramValue        if sendParamName in taskVar.sendParametersDict['chanToUseNeeded']:            # channel tracker stuff            # choose buffer or current            chnToUz=sendChannelInfo[0] # get channel for message compile        if sendParamName in taskVar.sendParametersDict['chanToUseTypeNeeded']:            headerChar=taskVar.sendParametersDict[sendParamName][sendChannelInfo[1]]        else:            headerChar=taskVar.sendParametersDict[sendParamName]        if sendParamName in taskVar.sendParametersDict['timeValues']:            if sendParamValue<0:                tSendVal=int(round(sendParamValue))            else:                tSendVal = int(round(sendParamValue*100000))    # convert to .01ms (10um) increments (teensy clock)            if (sendParamName == 'startTime') and (type(sendIndex)==tuple):                taskVar.experimentPandas['trialParameters'].at[sendIndex,'tFired']=sendParamValue # record start        elif sendParamName in ['amp','pulseCount','waveform']:            tSendVal=int(round(sendParamValue))        else:            tSendVal = sendParamValue        if not np.isnan(chnToUz):            valueChar=str(tSendVal)+str(chnToUz)        else:            valueChar=str(tSendVal)        sndTxt=headerChar+valueChar+'>'        taskSer.teensy.write(sndTxt.encode('utf-8'))  # Send the message        if sendParamName =='startTime':            sendme = 'Sending ' + sndTxt + " " + str(sendIndex)+  ' CurTime ' + str(taskVar.curTime)+ ' Wait ' + str(taskVar.waitTime) + " CurTrial " + str(taskVar.curTrialTime) +\             " PySt " + str(taskVar.pyState)            print(sendme)        else:            print('Sending '+sndTxt)        if sendParamName=='buffering':            #Update buffering dict            taskVar.bufferDict[sendChannelInfo]=sendParamValue        #Update last sent        taskVar.lastSentMessage.at[0,'indexTuple']=sendIndex        taskVar.lastSentMessage.at[0,'channelInfo']=sendChannelInfo        taskVar.lastSentMessage.at[0,'paramName']=sendParamName        taskVar.lastSentMessage.at[0,'paramValue']=sendParamValue        taskVar.lastSentMessage.at[0,'sndTxt']=sndTxt        # Pop the message from list and append it to last sent        taskVar.scheduledMessages.drop(labels=0,axis=0,inplace=True)        taskVar.scheduledMessages.reset_index(drop=True,inplace=True)        taskVar.sendingNow=False                        def cleanupEmptyParams():    for colKey in taskVar.makeTrialsDict['varsToUse']:        if colKey not in taskVar.experimentPandas['trialParameters'].columns:            taskVar.experimentPandas['trialParameters'][colKey]=np.tile(np.array(np.nan,dtype=object),(taskVar.experimentPandas['trialParameters'].shape[0],1))    rwdCol=taskVar.experimentPandas['trialParameters'].columns.get_loc('rewardStimulus')    ctchCol=taskVar.experimentPandas['trialParameters'].columns.get_loc('catchStimulus')    ampCol=taskVar.experimentPandas['trialParameters'].columns.get_loc('amp')    plsCol=taskVar.experimentPandas['trialParameters'].columns.get_loc('pulseCount')    for curLn in range(taskVar.experimentPandas['trialBaselines'].shape[0]):        for curCol in range(taskVar.experimentPandas['trialBaselines'].shape[1]):            theVar = taskVar.experimentPandas['trialBaselines'].iloc[curLn,curCol]            if type(theVar)==list or np.isnan(theVar):                taskVar.experimentPandas['trialBaselines'].iat[curLn,curCol]=0.0    for curLn in range(taskVar.experimentPandas['trialParameters'].shape[0]):        for curCol in range(taskVar.experimentPandas['trialParameters'].shape[1]):            theVar = taskVar.experimentPandas['trialParameters'].iloc[curLn,curCol]            if (curCol==rwdCol) or (curCol==ctchCol):                            if type(theVar)==list or np.isnan(theVar):                    taskVar.experimentPandas['trialParameters'].iat[curLn,curCol]=0            elif (curCol==ampCol) or (curCol==plsCol):                if (not np.isnan(theVar)) and (not type(theVar)==list):                    taskVar.experimentPandas['trialParameters'].iat[curLn,curCol]=round(theVar)                elif type(theVar)==list:                    taskVar.experimentPandas['trialParameters'].iat[curLn,curCol]=np.nan            else:                if type(theVar)==list:                    taskVar.experimentPandas['trialParameters'].iat[curLn,curCol]=np.nandef removeEmptyDummies():    drpDums=taskVar.experimentPandas['trialParameters'].loc[(taskVar.experimentPandas['trialParameters'].chanToUseType==2) \    & (taskVar.experimentPandas['trialParameters'].rewardStimulus==0) & (taskVar.experimentPandas['trialParameters'].catchStimulus==0)].index    taskVar.experimentPandas['trialParameters'].drop(drpDums,axis=0,inplace=True)def setTrainingOptions():    # Check session cue entry and set them on or off    for varPrefix in taskVar.cueSetDict['cueNames']:        chanVal = eval("taskVar.sesVarDict['"+varPrefix+"Channel']")        durVal =eval("taskVar.sesVarDict['"+varPrefix+"Dur']")        if (type(chanVal) == int) and ((type(durVal) == float) and (durVal>=taskVar.sampleDt)):            exec('taskVar.' + varPrefix + 'Set = True')            addSerialMessage(np.nan,(chanVal,1),'pulseDur',durVal)            if taskVar.tTrial==0:                print(varPrefix+' Channel is '+str(chanVal)+' Duration is '+str(durVal))        else:            exec('taskVar.' + varPrefix + 'Set = False')            if taskVar.tTrial==0:                print(varPrefix+' Not Active')    # Set stuff that needs to be zero if not otherwise modified    if (type(taskVar.sesVarDict['respToCueDelay'])!=float) or (taskVar.sesVarDict['respToCueDelay']<taskVar.sampleDt):        taskVar.sesVarDict['respToCueDelay']=0.0    for varNm in taskVar.rewardParametersDict['setZero']:        checkVal = taskVar.sesVarDict[varNm]        if (type(checkVal)!=float) or (checkVal<taskVar.sampleDt):            taskVar.sesVarDict[varNm]=0.0    # Check checkbox enforce pairs    for varNm, durNm in taskVar.rewardParametersDict['enforcePairs'].items():        activeBool = taskVar.sesVarDict[varNm]        durVal = taskVar.sesVarDict[durNm]        if (activeBool==1) and ((type(durVal)==float) and (durVal>=taskVar.sampleDt)):            if taskVar.tTrial==0:                print(varNm+' set, '+str(durVal)+' duration')        else:            taskVar.sesVarDict[varNm]=0            if taskVar.tTrial==0:                print(varNm+' Not Active')    # Check Reward     # are any set    rewardSelected = False    rewardIntsCheck = False    rewardDursCheck = False    for varNm in taskVar.rewardParametersDict['anyReward']:        if taskVar.sesVarDict[varNm]==1:            rewardSelected = True            break    if rewardSelected:        for varNm in taskVar.rewardParametersDict['allReward']['intVars']:            if type(taskVar.sesVarDict[varNm])==int:                rewardIntsCheck=True        for varNm in taskVar.rewardParametersDict['allReward']['gtDt']:            if ((type(taskVar.sesVarDict[varNm])==float) and (taskVar.sesVarDict[varNm]>=taskVar.sampleDt)):                rewardDursCheck=True        # Other float vars are already correct or set to zero (allowed)        if rewardIntsCheck and rewardDursCheck:            taskVar.rewardSet = True            addSerialMessage(np.nan,(taskVar.sesVarDict['rewardChannel'],1),'pulseDur',taskVar.sesVarDict['rewardDur'])            if taskVar.tTrial==0:                print('Reward Contingencies Active')        else:            taskVar.rewardSet = False    else:        taskVar.rewardSet = False    # Check TimeOut    timeOutSelected = False    timeOutDursCheck= False    for varNm in taskVar.rewardParametersDict['anyTimeOut']:        if taskVar.sesVarDict[varNm]==1:            timeOutSelected = True            break    if timeOutSelected:        for varNm in taskVar.rewardParametersDict['allTimeOut']['gtDt']:            if ((type(taskVar.sesVarDict[varNm])==float) and (taskVar.sesVarDict[varNm]>=taskVar.sampleDt)):                timeOutDursCheck=True        if timeOutDursCheck:            taskVar.timeOutSet = True            if taskVar.tTrial==0:                print('TimeOut Contingencies Active')        else:            taskVar.timeOutSet = False    else:        taskVar.timeOutSet = False    #Check widhdraw    if (type(taskVar.sesVarDict['widthdrawChannel'])==int) and ((type(taskVar.sesVarDict['widthdrawDur'])==float) and (taskVar.sesVarDict['widthdrawDur']>=taskVar.sampleDt)):        taskVar.widthdrawSet = True        addSerialMessage(np.nan,(taskVar.sesVarDict['widthdrawChannel'],1),'pulseDur',taskVar.sesVarDict['widthdrawDur'])    else:        taskVar.widthdrawSet = False#The below computes start times and signal lengths for each signal, it adds waitTime to the py1 state relative to reward windows. # this must be called on upcomming signals in order of earliest to latest or the addition of wait time will confound the start times# if this is called in pyState 0, it must be called on all send, wait, next send signals (all sent=0 and starttime= np.nan)# if this is called in pyState 1 it must be called only on nexttrial signalsdef computeStartEndTime(thePdFrame,trackerIndicies,nextTrial=0):    #print('add flag timeout for non-next, this will take the intended line(s) and figure out timing, and update tracker ,this needs to flag reward,next trial start')    #respIntMax=varTimeToInt(taskVar.sesVarDict['responseWindowMax'])    if nextTrial==1:        for trackInd in trackerIndicies:    #for each of the pushed lines            #compute Stare Time            # This assumes that it is in pyState 1, no pre-send will be made in the baseline period for next trial            #add the current trial length            thePdFrame.at[trackInd,'startTime']=taskVar.startTime+\            taskVar.experimentPandas['trialBaselines'].loc[thePdFrame.loc[trackInd].indexTuple[0]-1,'waitTime']+\            taskVar.experimentPandas['trialBaselines'].loc[thePdFrame.loc[trackInd].indexTuple[0],'trialTime']+\            taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].offset            #now add the next baseline (if there is none is should be listed as zero)            #now add offset            #set start equal to start time plus start offset            #taskVar.experimentPandas['trialParameters'].at[thePdFrame.loc[trackInd].indexTuple,'tFired']=thePdFrame.at[trackInd,'startTime'] # record start            offsetInt=varTimeToInt(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].offset)            thePdFrame.at[trackInd,'startInt']=varTimeToInt(thePdFrame.loc[trackInd,'startTime']) #set start equal to start time plus start offset            #compute end time            pDuration=0.0    #Figure out the pulsing width            #if thePdFrame.loc[trackInd,'channelInfo'][1]==1:  # Changed to account for dummy variables            if thePdFrame.loc[trackInd,'channelInfo'][1]!=0:                pDuration=taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseDur            else:                if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseTrainDur)):                    pDuration = taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseTrainDur                if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseCount)):                    pDuration = taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseCount*\                    (taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseDur +\                    taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].interPulseDur)            thePdFrame.at[trackInd,'endTime']=thePdFrame.loc[trackInd,'startTime']+pDuration #set end equal to start time pulsing width            intPDuration = varTimeToInt(pDuration)            thePdFrame.at[trackInd,'endInt']=thePdFrame.at[trackInd,'startInt']+intPDuration #set end equal to start time pulsing width            #The below block is accurate, but would not account for other sent blocks without zeroing their values and calling             #   schedue / this function again. Estimate wait times, and reward/cueing routines account for this                         # waitAdd =0                        # if thePdFrame.loc[trackInd,'rewardStimulus']==1 or thePdFrame.loc[trackInd,'catchStimulus']==1:            #     waitAdd ==max(offsetInt+intPDuration,offsetInt+respIntMax)            # else:            #     waitAdd=offsetInt+intPDuration            # nxtWaitT= taskVar.experimentPandas['trialBaselines'].loc[thePdFrame.loc[trackInd].indexTuple[0],'waitTime']            # updtWaitT = varTimeFromInt(waitAdd)            # if nxtWaitT<updtWaitT:            #     taskVar.experimentPandas['trialBaselines'].at[thePdFrame.loc[trackInd].indexTuple[0],'waitTime']=updtWaitT    elif taskVar.pyState==1:        for trackInd in trackerIndicies:    #for each of the pushed lines            #compute Stare Time            thePdFrame.at[trackInd,'startTime']=taskVar.startTime+\            taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].offset #set start equal to start time plus start offset            #taskVar.experimentPandas['trialParameters'].at[thePdFrame.loc[trackInd].indexTuple,'tFired']=thePdFrame.at[trackInd,'startTime'] # record start            offsetInt=varTimeToInt(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].offset)            thePdFrame.at[trackInd,'startInt']=taskVar.startInt+offsetInt #set start equal to start time plus start offset            #compute end time            pDuration=0.0    #Figure out the pulsing width            #if thePdFrame.loc[trackInd,'channelInfo'][1]==1:  #changed for same reason above            if thePdFrame.loc[trackInd,'channelInfo'][1]!=0:                pDuration=taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseDur            else:                if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseTrainDur)):                    pDuration = taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseTrainDur                if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseCount)):                    pDuration = taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseCount*\                    (taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseDur +\                    taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].interPulseDur)            thePdFrame.at[trackInd,'endTime']=thePdFrame.loc[trackInd,'startTime']+pDuration #set end equal to start time pulsing width            intPDuration = varTimeToInt(pDuration)            thePdFrame.at[trackInd,'endInt']=thePdFrame.at[trackInd,'startInt']+intPDuration #set end equal to start time pulsing width            #The below block is accurate, but would not account for other sent blocks without zeroing their values and calling             #   schedue / this function again. Estimate wait times, and reward/cueing routines account for this                                     # waitAdd=0            # if thePdFrame.loc[trackInd,'rewardStimulus']==1 or thePdFrame.loc[trackInd,'catchStimulus']==1:            #     waitAdd ==max(offsetInt+intPDuration,offsetInt+respIntMax)            # else:            #     waitAdd=offsetInt+intPDuration            # if taskVar.waitInt<waitAdd:            #     taskVar.waitInt=waitAdd            #     taskVar.waitTime=varTimeFromInt(waitAdd)            #     taskVar.experimentPandas['trialBaselines'].at[thePdFrame.loc[trackInd].indexTuple[0],'waitTime']=taskVar.waitTime    elif taskVar.pyState==0:        for trackInd in trackerIndicies:    #for each of the pushed lines            #compute Stare Time            thePdFrame.at[trackInd,'startTime']=taskVar.startTime+taskVar.waitTime+\            taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].offset #set start equal to start time plus start offset            offsetInt=varTimeToInt(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].offset)            thePdFrame.at[trackInd,'startInt']=taskVar.startInt+offsetInt+taskVar.waitInt #set start equal to start time plus start offset            #compute end time            pDuration=0.0    #Figure out the pulsing width            #if thePdFrame.loc[trackInd,'channelInfo'][1]==1:            if thePdFrame.loc[trackInd,'channelInfo'][1]!=0:                pDuration=taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseDur            else:                if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseTrainDur)):                    pDuration = taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseTrainDur                if (not np.isnan(taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseCount)):                    pDuration = taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseCount*\                    (taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].pulseDur +\                    taskVar.experimentPandas['trialParameters'].loc[thePdFrame.loc[trackInd].indexTuple].interPulseDur)            thePdFrame.at[trackInd,'endTime']=thePdFrame.loc[trackInd,'startTime']+pDuration#set end equal to start time pulsing width            intPDuration = varTimeToInt(pDuration)            thePdFrame.at[trackInd,'endInt']=thePdFrame.at[trackInd,'startInt']+intPDuration #set end equal to start time pulsing width            #The below block is accurate, but would not account for other sent blocks without zeroing their values and calling             #   schedue / this function again. Estimate wait times, and reward/cueing routines account for this                         # waitAdd=0            # if thePdFrame.loc[trackInd,'rewardStimulus']==1 or thePdFrame.loc[trackInd,'catchStimulus']==1:            #     waitAdd ==max(offsetInt+intPDuration,offsetInt+respIntMax)            # else:            #     waitAdd=offsetInt+intPDuration            # waitLen=0.0            # waitAddT=0.0            # waitLen = taskVar.experimentPandas['trialBaselines'].loc[thePdFrame.loc[trackInd].indexTuple[0],'waitTime']            # waitAddT = varTimeFromInt(waitAdd)            # if waitAddT>waitLen:            #     taskVar.experimentPandas['trialBaselines'].at[thePdFrame.loc[trackInd].indexTuple[0],'waitTime']=waitAddT    rewardsAndCatches = thePdFrame.loc[(thePdFrame['rewardStimulus']==1) | (thePdFrame['catchStimulus']==1)].index    updateThese = thePdFrame.loc[np.intersect1d(rewardsAndCatches,trackerIndicies)].index    if (type(updateThese)!=float) and (len(updateThese)>0):        updateRewardTracker(updateThese,thePdFrame)    return thePdFramedef abortTrial():    print('for in-trial cut to timeout structure, read start sent and write all times to -2(kill), if goin update duration, if not null tFired')#This determines what signal parameteres can be sent to the teensy at any given time based on signal times and which physical channel.#It maintains the send lists and updates them with whether parameters and/or start times have been added to trafficing serial messages# everything in the send list is immediately computed and sent, first the signal parameters and then start times. # if a signal has occured and finished in real-time it is removed from the sendList# if in-trial (pyState=1), #       waitList is analyed - anything here is at first on the same channel as something ahead of it in the sendList#       wL start times are calculated, #       if wL signal can move to sendL it's moved#       if nothing in wL ahead of wL on same channel - sends buffered parameters and start time#       nextSendList is analyzed#           if not in the sendL or waitL and noNextWait, sent as if sendList#           if next same ch channel in front is fired , send params and if noWait send start both buffered# returns the next increment this should be run ondef scheduleEvents(noWait=0):    sendingVars=0    if taskVar.sendList.shape[0]>0: # If there are still signals to send        # Add all non-start parameters to send buffer functions        #changing logical tests to optimize performance        taskVar.sendList.at[\        taskVar.sendList.loc[taskVar.sendList.startInt.le(taskVar.curInt)].index,'buffering']=0        notSentParBufList=taskVar.sendList.loc[taskVar.sendList.buffering.eq(1) & taskVar.sendList.paramSent.eq(0)].index        notSentParNoBufList=taskVar.sendList.loc[taskVar.sendList.buffering.eq(0) & taskVar.sendList.paramSent.eq(0)].index        #pSentList=taskVar.sendList.loc[taskVar.sendList.paramSent.eq(0)].index        #if taskVar.sendList.paramSent.eq(0).any():        if len(notSentParNoBufList)>0:            taskVar.sendList=sendListReader(taskVar.sendList.loc[notSentParNoBufList,'indexTuple'],0,taskVar.sendList,notSentParNoBufList) # zero for non-start            taskVar.sendList.at[notSentParNoBufList,'paramSent']=1        #update tracker            sendingVars=1 # update that vars are in process        if len(notSentParBufList)>0:            taskVar.sendList=sendListReader(taskVar.sendList.loc[notSentParBufList,'indexTuple'],0,taskVar.sendList,notSentParBufList,1)             taskVar.sendList.at[notSentParBufList,'paramSent']=1        #update tracker            #no need to se buffering - already confirmed            sendingVars=1 # update that vars are in process                    notSentStarBufList=taskVar.sendList.loc[taskVar.sendList.buffering.eq(1) & taskVar.sendList.startSent.eq(0)].index        notSentStarNoBufList=taskVar.sendList.loc[taskVar.sendList.buffering.eq(0) & taskVar.sendList.startSent.eq(0)].index        #sSentList=taskVar.sendList.loc[taskVar.sendList.startSent.eq(0)].index        #if taskVar.sendList.startSent.eq(0).any():        #TODO Update this to remove the waitInt condition, new fuction to update start times        if (len(notSentStarBufList)>0) or (len(notSentStarNoBufList)>0):            sTimeIsNull=taskVar.sendList.loc[taskVar.sendList.startTime.isnull()].index            if len(sTimeIsNull)>0:            #if taskVar.sendList.startTime.isnull().any(): #If needed, set the start times                taskVar.sendList=computeStartEndTime(taskVar.sendList,sTimeIsNull) #set timing for the stims            if len(notSentStarNoBufList)>0:                #                taskVar.sendList=sendListReader(taskVar.sendList.loc[notSentStarNoBufList,'indexTuple'],1,taskVar.sendList,notSentStarNoBufList) # send for start times                taskVar.sendList.at[notSentStarNoBufList,'startSent']=1        #update tracker                sendingVars=1 # update that vars are in process  #TODO update from panda            if len(notSentStarBufList)>0:                #                taskVar.sendList=sendListReader(taskVar.sendList.loc[notSentStarBufList,'indexTuple'],1,taskVar.sendList,notSentStarBufList,1) # send for start times                taskVar.sendList.at[notSentStarBufList,'startSent']=1        #update tracker                sendingVars=1 # update that vars are in process  #TODO update from panda        if taskVar.pyState ==1:            pastStrtList=taskVar.sendList.loc[taskVar.sendList['endInt']<=taskVar.curInt].index            if len(pastStrtList)>0:# if we are past the end time of the line - drop the line                taskVar.sendList.drop(pastStrtList,axis=0,inplace=True)                taskVar.sendList.reset_index(drop=True,inplace=True)                sendingVars=1                    if taskVar.sendList.shape[0]>0:                if not sendingVars==1:                    minsV=np.min(taskVar.sendList.loc[taskVar.sendList.startInt.gt(taskVar.curInt)].startInt)-taskVar.curInt                    maxV=np.min(taskVar.sendList.loc[taskVar.sendList.endInt.gt(taskVar.curInt)].endInt)-taskVar.curInt                    minall=np.min([minsV,maxV])                    if sendingVars>0:                        sendingVars=np.min([minall,sendingVars])                    else:                        sendingVars=minall    # End of sendList block Wait list can now be sent if not in sendList, or buffered if fired in sendlist    if taskVar.pyState==1:        if taskVar.waitList.shape[0]>0:          #If there are any waitlist signals            #            wlsTimeIsNull=taskVar.waitList.loc[taskVar.waitList.startTime.isnull()].index            if len(wlsTimeIsNull)>0:            #if taskVar.waitList.startTime.isnull().any():  # populate start times - should not need to pre-populate before pySTate1                taskVar.waitList=computeStartEndTime(taskVar.waitList,wlsTimeIsNull) #set timing for the stims                sendingVars=1                        pastStrtList=taskVar.waitList.loc[(taskVar.waitList['endInt']<=taskVar.curInt)].index            if len(pastStrtList)>0:# if we are past the end time of the line - drop the line                taskVar.waitList.drop(pastStrtList,axis=0,inplace=True)                taskVar.waitList.reset_index(drop=True,inplace=True)                sendingVars=1                    ## ANYTHING LEFT IS NOT PAST IT'S END TIME            if taskVar.waitList.paramSent.eq(0).any() or taskVar.waitList.startSent.eq(0).any() or taskVar.waitList.buffering.eq(1).any():                for tvInd in range(taskVar.waitList.shape[0]):# if we passed the corresponding channel start time                    tvVal=taskVar.waitList.loc[tvInd,'channelInfo']                    sendStarted=0                    inSend=0                    sendNotBuffed=0                    sndInd=taskVar.sendList.loc[taskVar.sendList.channelInfo==tvVal].index                    if len(sndInd)>0:                        sndInd=sndInd[-1]                        inSend=1                        if taskVar.sendList.loc[sndInd,'startInt']<=taskVar.curInt:                            sendStarted=1                    waitInd = taskVar.waitList[:tvInd].loc[taskVar.waitList.channelInfo[:tvInd].isin([tvVal])].index.tolist()                    isInWait=0                    waitStarted=0                    if len(waitInd)>0:                        waitInd=waitInd[-1]                        isInWait=1                        if taskVar.waitList.loc[waitInd,'startInt']<=taskVar.curInt:                            waitStarted=1                    if ((inSend==0) and ((isInWait==0) or (waitStarted==1))) or ((isInWait==0) and (sendStarted==1)):                        if (taskVar.waitList.loc[tvInd,'startInt']<=taskVar.curInt) and (taskVar.waitList.loc[tvInd,'startSent']==1) and\                        (taskVar.waitList.loc[tvInd,'paramSent']==1):                            taskVar.waitList.at[tvInd,'buffering']=0 # If nothing is holding up the pulse and is started, it's not being buffered                        elif ((taskVar.waitList.loc[tvInd,'paramSent']==0) or (taskVar.waitList.loc[tvInd,'startSent']==0)):                            # again if nothing is holding it up, send the buffer                            #(not taskVar.waitList.channelInfo[:tvInd].isin([tvVal]).any()): #if there are no in-wait duplicates ahead                            #find the corresponding sendList signal and check if fired, if so send params and start buffered                            #sndInd=taskVar.sendList.loc[taskVar.sendList.channelInfo==tvVal].index.tolist()[-1]                            #if taskVar.curInt>=taskVar.sendList.loc[sndInd,'startInt']:#if fired                                                                   if taskVar.waitList.loc[tvInd,'paramSent']==0:                                taskVar.waitList=sendListReader([taskVar.waitList.loc[tvInd,'indexTuple']],0,taskVar.waitList,[tvInd],1) #1 for  buffered                                taskVar.waitList.at[tvInd,'paramSent']=1                                taskVar.waitList.at[tvInd,'buffering']=1                                sendingVars=1                            if taskVar.waitList.loc[tvInd,'startSent']==0:                                taskVar.waitList=sendListReader([taskVar.waitList.loc[tvInd,'indexTuple']],1,taskVar.waitList,[tvInd],1) #1 for buffered                                taskVar.waitList.at[tvInd,'startSent']=1                                taskVar.waitList.at[tvInd,'buffering']=1                                                         sendingVars=1                        #taskVar.waitList.endInt[:tvInd].loc[taskVar.waitList.channelInfo[:tvInd].isin([tvVal])].values.tolist()[-1]            if taskVar.waitList.shape[0]>0 and (taskVar.waitList.paramSent.eq(0).any() or taskVar.waitList.startSent.eq(0).any()):                if not sendingVars==1:                    minsV=np.min(taskVar.waitList.loc[taskVar.waitList.startInt.gt(taskVar.curInt)].startInt)-taskVar.curInt                    maxV=np.min(taskVar.waitList.loc[taskVar.waitList.endInt.gt(taskVar.curInt)].endInt)-taskVar.curInt                    minall=np.min([minsV,maxV])                    if sendingVars>0:                        sendingVars=np.min([minall,sendingVars])                    else:                        sendingVars=minall                            #sending vars should make this be called again any time there is something potentially needed in current trial vars        # for next send, in pyState 1 if no dups, send params, if start time can be computed (no next waitTime) send start        if taskVar.nextSendList.shape[0]>0: # if there is a next send NOTE This ALSO TESTS FOR LESS THAN LAST TRIAL            if (noWait==1) and (taskVar.nextSendList.paramSent.eq(0).any()) or (taskVar.nextSendList.startSent.eq(0).any()): # If we have params to send                for tvInd in range(taskVar.nextSendList.shape[0]):                    tvVal=taskVar.nextSendList.loc[tvInd,'channelInfo'] #channels in next send should be unique so no need to verify                    if (taskVar.nextSendList.loc[tvInd,'paramSent']==0) or (taskVar.nextSendList.loc[tvInd,'startSent']==0):                        sndClr=0                        wtClr=0                        aheadSend=0                        aheadWait=0                        sndInd=taskVar.sendList.loc[taskVar.sendList.channelInfo==tvVal].index                        if len(sndInd)>0:                            sndInd=sndInd[-1]                            aheadSend=1                            if taskVar.sendList.loc[sndInd,'startInt']<=taskVar.curInt:                                sndClr=1                        wtInd=taskVar.waitList.loc[taskVar.waitList.channelInfo==tvVal].index                        if len(wtInd)>0:                            wtInd=wtInd[-1]                            aheadWait=1                            if taskVar.waitList.loc[wtInd,'startInt']<=taskVar.curInt:                                wtClr=1                                          if ((aheadSend==0) and (aheadWait==0)) or ((aheadWait==0) and (sndClr==1)) or ((aheadSend==0) and (wtClr==1)):                            #                            # send params                            if taskVar.nextSendList.loc[tvInd,'startSent']==0:                                taskVar.nextSendList=computeStartEndTime(taskVar.nextSendList,[tvInd],1) #set timing for the stims, '1' for next Trial                                taskVar.nextSendList=sendListReader([taskVar.nextSendList.loc[tvInd,'indexTuple']],1,taskVar.nextSendList,[tvInd],1)                                taskVar.nextSendList.at[tvInd,'startSent']=1                                taskVar.nextSendList.at[tvInd,'buffering']=1                                 sendingVars=1                               # Note Not ideal to send start ahead of params, but this should always be prefire and computes start updates for buffer catch in read                            if taskVar.nextSendList.loc[tvInd,'paramSent']==0:                                taskVar.nextSendList=sendListReader([taskVar.nextSendList.loc[tvInd,'indexTuple']],0,taskVar.nextSendList,[tvInd],1) #buffered                                taskVar.nextSendList.at[tvInd,'paramSent']=1                                taskVar.nextSendList.at[tvInd,'buffering']=1                                 sendingVars=1                             # if no wait calc and send start    # don't do anything with next wait, just use to hold variables to be moved for next trial.    if sendingVars<0:        sendingVars=1    return sendingVarsdef trialExit():    #Called at trial ends / changeover  before populate (trial incrementation and pystate change, pysate always 1)    taskVar.timingData.at[taskVar.tTrial,'noLickDelays']=taskVar.noLickDelays    taskVar.timingData.at[taskVar.tTrial,'noRunDelays']=taskVar.noRunDelays    taskVar.noLickDelaysCount+=len(taskVar.noLickDelays)    taskVar.noRunDelaysCount+=len(taskVar.noRunDelays)    taskVar.noLickDelays=[]    taskVar.noRunDelays=[]    if (taskVar.endCueSet) and (taskVar.tTrial <= taskVar.sesVarDict['totalTrials']-1):        #This will be the last-trial end, called at trial change before tTrial incremented, for ttrial total-1 = last,         addSerialMessage(np.nan,(taskVar.sesVarDict['endCueChannel'],1),'startTime',-1,1)        taskVar.timingData.at[taskVar.tTrial,'endCues']=taskVar.curTime+taskVar.sampleDt        # Note, def trialEnter():    # Called at trial change over, after populate (trial incrementation and pystate change) but before schedule (signal message creation)    if taskVar.sesVarDict['sessionOn']:        #Accoutns for activity after last trial end        if taskVar.pyState == 0:            # If task starts with a baseline            taskVar.timingData.at[taskVar.tTrial,'baseLineStart']=taskVar.curTime            #Below is redundant to trial exit and doubles the end signal messages            # # Fire last trial's end cue and record time (tTrial is current)            # if (taskVar.endCueSet) and (taskVar.tTrial>0):            #     #send an end cue message            #     addSerialMessage(np.nan,(taskVar.sesVarDict['endCueChannel'],1),'startTime',-1,1)            #     # record time of last trial's expected end cue firing            #     taskVar.timingData.at[taskVar.tTrial-1,'endCues']=taskVar.curTime+taskVar.sampleDt        else:              # Stim Trial Epoch is starting, record it            taskVar.timingData.at[taskVar.tTrial,'trialStart']=taskVar.curTime            # if cue for epoch set then deliver it            if taskVar.startCueSet:                addSerialMessage(np.nan,(taskVar.sesVarDict['startCueChannel'],1),'startTime',-1,1)                # log expected time of cue                taskVar.timingData.at[taskVar.tTrial,'startCues']=taskVar.curTime+taskVar.sampleDtdef baseLineExit():    #Call first when exiting baseline    # Trial starting so record it    taskVar.timingData.at[taskVar.tTrial,'trialStart']=taskVar.curTime    # if cue for epoch set then deliver it    if taskVar.startCueSet:        addSerialMessage(np.nan,(taskVar.sesVarDict['startCueChannel'],1),'startTime',-1,1)        # log expected time of cue        taskVar.timingData.at[taskVar.tTrial,'startCues']=taskVar.curTime+taskVar.sampleDt           def runDetectionTask():    taskVar.sesVarDict['taskType']='detection'    initializeTasks()    while taskVar.sesVarDict['sessionOn']:        # try to execute the task.        try:            #updateTaskVars()            newData = checkTeensyData()            if newData:                #updatePlots()                #lickDetection()                # 4) Now look at what state you are in and evaluate accordingly                genericBody()                if taskVar.pyState == 0:                    # Test state 1 exit:                    if taskVar.curTrialInt>=taskVar.waitInt:                        baseLineExit()                        #We are now in the trial phase initialize the trial phase here and run the body (in the next pystate If)                        taskVar.pyState=1                        genericFooter()                        #Wait time must be first determined here, not needed when populate is called                        taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['waitTime']  #if so go to stim state                        waitTimeToInt()                        # taskVar.newLick=lickDetection()                        # if taskVar.newLick:                        #     if taskVar.taskVar.rewardTracker.shape[0]>0:                        #         evaluateRewardTimeOut()                        #check the send lists and set an alarm for next between next needed and up to 1[s]                        taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                        if taskVar.checkInt==0:                            taskVar.checkInt=taskVar.sesVarDict['sampRate']                        taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                    else:                        #Do everything else that would be in a baseline state                        # taskVar.newLick=lickDetection()                        # #Do the no/lick no run stuff                        if taskVar.curTrialInt>=taskVar.scheduleCheck:                            #check the send lists and set an alarm for next between next needed and up to 1[s]                            taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                            if taskVar.checkInt==0:                                taskVar.checkInt=taskVar.sesVarDict['sampRate']                            taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                        #enforceNoLickRule()                        #runDetection                        # TODO enable enforce by no lick lockout only (taskVar.lickRunLockout=0)                        # add taskVar.lickRunLockout=0 to pystate 1 - this prevents last moment wait time enforcement for var sending                if taskVar.pyState == 1:                    # test state exit:                    if taskVar.curTrialInt>=taskVar.waitInt:                        trialExit()                        #We are now in the 'next' (or a new) either Baseline or Trial phase - populate determines which                        taskVar.noNextWait=populateTrialVariableLists()                        trialEnter()                        genericFooter()                        taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                        if taskVar.checkInt==0:                            taskVar.checkInt=taskVar.sesVarDict['sampRate']                        taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                                                   #do the rest of the pre-trial footer                    else:                        # do the rest of the trial stuff                        if taskVar.curTrialInt>=taskVar.scheduleCheck:                            #check the send lists and set an alarm for next between next needed and up to 1[s]                            taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                            if taskVar.checkInt==0:                                taskVar.checkInt=taskVar.sesVarDict['sampRate']                            taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                    #if taskVar.trialTimeLastLick>0.02:                    #    taskVar.reported=1                    #if taskVar.curTrialTime>taskVar.sesVarDict['minStim']:                        #if taskVar.reported==1 or taskVar.sesVarDict['shapingTrial']:                if taskVar.sesVarDict['sessionOn']:                    #Prevent task related messages if task terminated (reduces cut off signals on teensy shut down)                    sendNextCommnd()                #taskVar.newLick=False            #if taskVar.experimentPandas['trialParameters'].tFired.eq(taskVar.curTime).any():                #print('Channel {} fired. Time is {}'.format(str(taskVar.experimentPandas['trialParameters'].loc[taskVar.experimentPandas['trialParameters'].tFired.eq(taskVar.curTime),\                #    'chanToUse'].values[0]),taskVar.curTime))        except:            sessionCleanup(1)        sessionCleanup(0)def runSimpleRecord():    taskVar.sesVarDict['taskType']='simpleRecording'    initializeTasks()    while taskVar.sesVarDict['sessionOn']:                try:                        #updateTaskVars()   # only used to update gui            newData = checkTeensyData()                        if newData:                # 4) Now look at what state you are in and evaluate accordingly                if taskVar.pyState == 0:                    if taskVar.sHeaders[taskVar.pyState]==0:                        genericHeader()        except:            print('excepted')            sessionCleanup(1)    taskSer.teensy.write('a0>'.encode('utf-8'))    taskSer.cntrlTState=0    print('Recording Lasted: {:.5f} seconds'.format(taskVar.curTime))    sessionCleanup(0)def runMonitorOnly():    taskVar.sesVarDict['taskType']='monitorOnly'    initializeTasks()    while taskVar.sesVarDict['sessionOn']:                try:                        #updateTaskVars()   # only used to update gui            newData = checkTeensyData()                        if newData:                # 4) Now look at what state you are in and evaluate accordingly                if taskVar.pyState == 0:                    if taskVar.sHeaders[taskVar.pyState]==0:                        genericHeader()        except:            print('excepted')            sessionCleanup(1)    taskSer.teensy.write('a0>'.encode('utf-8'))    taskSer.cntrlTState=0    sessionCleanup(0)    def runCalibrateRecording():    taskVar.sesVarDict['taskType']='calibrate'    initializeTasks()    #taskSer.teensy.write('a1>'.encode('utf-8')) # For Debugging    #taskSer.cntrlTState=1        while taskVar.sesVarDict['sessionOn']:        # try to execute the task.        try:            newData = checkTeensyDataCal()                    if newData:                #updatePlots()                if taskVar.pyState == 0:                    # Test state 1 exit:                    if taskVar.curTrialInt>=taskVar.waitInt:                        taskVar.pyState=1                        # This primarily calculates the time latch and resets the clocks at state exit                        genericFooter()                        #Wait time must be first determined here, not needed when populate is called                        taskVar.waitTime = taskVar.experimentPandas['trialBaselines'].iloc[taskVar.tTrial]['waitTime']  #if so go to stim state                        waitTimeToInt()                        # taskVar.newLick=lickDetection()                        # if taskVar.newLick:                        #     if taskVar.taskVar.rewardTracker.shape[0]>0:                        #         evaluateRewardTimeOut()                        #check the send lists and set an alarm for next between next needed and up to 1[s]                        taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                        if taskVar.checkInt==0:                            taskVar.checkInt=taskVar.sesVarDict['sampRate']                        taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                    else:                        #Do everything else that would be in a baseline state                        if taskVar.curTrialInt>=taskVar.scheduleCheck:                            #check the send lists and set an alarm for next between next needed and up to 1[s]                            taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                            if taskVar.checkInt==0:                                taskVar.checkInt=taskVar.sesVarDict['sampRate']                            taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                if taskVar.pyState == 1:                    # test state exit:                    if taskVar.curTrialInt>=taskVar.waitInt:                        #We are now in the 'next' (or a new) either Baseline or Trial phase - populate determines which                        print('Trail end exceed')  #Debugging                        taskVar.noNextWait=populateTrialVariableLists()                        print('Populate executed') # Debugging                        # This primarily calculates the time latch and resets the clocks at state exit                        genericFooter()                        taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                        if taskVar.checkInt==0:                            taskVar.checkInt=taskVar.sesVarDict['sampRate']                        taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                                                   #do the rest of the pre-trial footer                    else:                        # do the rest of the trial stuff                        if taskVar.curTrialInt>=taskVar.scheduleCheck:                            #check the send lists and set an alarm for next between next needed and up to 1[s]                            taskVar.checkInt = scheduleEvents(taskVar.noNextWait)                            if taskVar.checkInt==0:                                taskVar.checkInt=taskVar.sesVarDict['sampRate']                            taskVar.scheduleCheck=taskVar.curTrialInt+taskVar.checkInt                    #if taskVar.trialTimeLastLick>0.02:                    #    taskVar.reported=1                    #if taskVar.curTrialTime>taskVar.sesVarDict['minStim']:                        #if taskVar.reported==1 or taskVar.sesVarDict['shapingTrial']:                if taskVar.sesVarDict['sessionOn']:                    #Prevent task related messages if task terminated (reduces cut off signals on teensy shut down)                    sendNextCommnd()                #taskVar.newLick=False            #if taskVar.experimentPandas['trialParameters'].tFired.eq(taskVar.curTime).any():                #print('Channel {} fired. Time is {}'.format(str(taskVar.experimentPandas['trialParameters'].loc[taskVar.experimentPandas['trialParameters'].tFired.eq(taskVar.curTime),\                #    'chanToUse'].values[0]),taskVar.curTime))        except:            sessionCleanup(1)        sessionCleanup(0)    print('String finished') # for debuggingtaskGUI.master.mainloop()print('done')